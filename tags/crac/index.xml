<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Crac on mazhen.tech</title>
        <link>https://mazhen.tech/tags/crac/</link>
        <description>Recent content in Crac on mazhen.tech</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 03 Sep 2025 10:37:32 +0800</lastBuildDate><atom:link href="https://mazhen.tech/tags/crac/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>追踪 Java 进程创建的 domain socket</title>
        <link>https://mazhen.tech/p/%E8%BF%BD%E8%B8%AA-java-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84-domain-socket/</link>
        <pubDate>Wed, 03 Sep 2025 10:37:32 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E8%BF%BD%E8%B8%AA-java-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84-domain-socket/</guid>
        <description>&lt;p&gt;在使用 CRaC 创建 checkpoint 镜像时，需要 Java 应用能够恰当处理它持有的外部资源，例如打开的日志文件，监听的服务端口，对外创建的数据库连接池等。&lt;/p&gt;
&lt;p&gt;对于 Java 应用打开的文件，可以通过定义&lt;a class=&#34;link&#34; href=&#34;https://docs.azul.com/core/crac/fd-policies&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;文件描述符策略&lt;/a&gt; 让 CRaC 自动处理。对于监听端口或连接池，一般建议应用实现 CRaC 的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/CRaC/org.crac/blob/master/src/main/java/org/crac/Resource.java&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Resource&lt;/a&gt; 接口，在 checkpoint 前关闭资源，在 restore 后重新打开。&lt;/p&gt;
&lt;p&gt;但有一些资源，不是 Java 应用直接打开持有的，而是底层的 JVM 或依赖的 C 库打开的，这类资源要追踪定位是谁创建的比较困难。&lt;/p&gt;
&lt;h2 id=&#34;初步排查过程&#34;&gt;
    &lt;a href=&#34;#%e5%88%9d%e6%ad%a5%e6%8e%92%e6%9f%a5%e8%bf%87%e7%a8%8b&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    初步排查过程
&lt;/h2&gt;&lt;p&gt;最近我就碰到了这样一个例子。在对 Java 应用创建 checkpoint 时，报如下异常：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;An&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;during&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;checkpoint&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;operation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jdk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;internal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;mirror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;CheckpointException&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Suppressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jdk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;internal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;mirror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;CheckpointOpenSocketException&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FD&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2885875383&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;29295&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;at&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;base&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jdk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;internal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;mirror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;translateJVMExceptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;116&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;at&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;base&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jdk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;internal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;mirror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;checkpointRestore1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;189&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;at&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;base&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jdk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;internal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;mirror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;checkpointRestore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;315&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;at&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;base&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jdk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;internal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;mirror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;checkpointRestoreInternal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;328&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;表明 Java 应用持有文件描述 (fd) 6，类型是 socket，inode 为 2885875383.&lt;/p&gt;
&lt;p&gt;于是查看该 Java 进程持有的所有 socket 资源：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ll /proc/2444401/fd  &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep socket
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; root root &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Sep  &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; 11:19 &lt;span class=&#34;m&#34;&gt;6&lt;/span&gt; -&amp;gt; socket:&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;2885875383&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;果然 Java 进程持有的 fd 6，类型是 socket，inode 为 2885875383。进一步使用 &lt;code&gt;lsof&lt;/code&gt; 命令查看这个 socket 资源的详细信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lsof -p &lt;span class=&#34;m&#34;&gt;2444401&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;m&#34;&gt;2885875383&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;exe     &lt;span class=&#34;m&#34;&gt;2444401&lt;/span&gt; root    6u     unix 0x00000000b8935f1c       0t0 &lt;span class=&#34;m&#34;&gt;2885875383&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;STREAM
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第五列为 &lt;code&gt;unix&lt;/code&gt;，表示该文件描述符对应的资源是 &lt;code&gt;unix domain socket&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;想进一步调研这个 domain socket 的来源和作用，它的一端是 Java 进程持有，那么另一端是谁持有呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# -U ：筛选 Unix 域套接字（Unix Domain Sockets）。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# -a：逻辑 “与”（AND） 操作，将前面的条件（-p 和 -U）组合，表示必须同时满足&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# +E：显示套接字的 端点信息（Endpoints）。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lsof -p &lt;span class=&#34;m&#34;&gt;2444401&lt;/span&gt; -U -a +E
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;COMMAND     PID USER   FD   TYPE             DEVICE SIZE/OFF       NODE NAME
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;exe     &lt;span class=&#34;m&#34;&gt;2444401&lt;/span&gt; root    6u  unix 0x00000000b8935f1c      0t0 &lt;span class=&#34;m&#34;&gt;2885875383&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;STREAM
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;exe     &lt;span class=&#34;m&#34;&gt;2444401&lt;/span&gt; root   57u  unix 0x00000000a4202b14      0t0 &lt;span class=&#34;m&#34;&gt;2885883519&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;STREAM
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输出中并没有发现对端的进程信息。&lt;/p&gt;
&lt;p&gt;一般情况下，加了 &lt;code&gt;+E&lt;/code&gt; 参数，输出中会通过 &lt;code&gt;-&amp;gt;INO=&lt;/code&gt; 指示出对端进程信息，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo lsof -p &lt;span class=&#34;m&#34;&gt;1167&lt;/span&gt; -U -a +E
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;container &lt;span class=&#34;m&#34;&gt;1131&lt;/span&gt; root    8u  unix 0xffff9d34cdf28c00      0t0 &lt;span class=&#34;m&#34;&gt;14525&lt;/span&gt; /run/containerd/containerd.sock &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;STREAM -&amp;gt;INO&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;21711&lt;/span&gt; 1167,dockerd,8u &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;CONNECTED&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dockerd   &lt;span class=&#34;m&#34;&gt;1167&lt;/span&gt; root    8u  unix 0xffff9d34cdf29400      0t0 &lt;span class=&#34;m&#34;&gt;21711&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;STREAM -&amp;gt;INO&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;14525&lt;/span&gt; 1131,container,8u &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;CONNECTED&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看出，在 &lt;code&gt;containerd&lt;/code&gt; 这一端，它使用文件描述符 8（标记为 8u，表示可读可写）来管理 domain socket，这个套接字被绑定到文件系统路径 &lt;code&gt;/run/containerd/containerd.sock&lt;/code&gt; 上。行末的 &lt;code&gt;-&amp;gt;INO=21711 1167,dockerd,8u (CONNECTED)&lt;/code&gt; 表明，该套接字的对端是进程 ID 为 1167 的 &lt;code&gt;dockerd&lt;/code&gt;。&lt;code&gt;dockerd&lt;/code&gt; 同样使用文件描述符 8 来管理这个连接，且连接状态为已建立&lt;code&gt;（CONNECTED）&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再查看 &lt;code&gt;dockerd&lt;/code&gt; 进程这端的情况，它也使用文件描述符 8（8u）来维护这个通信通道。与 &lt;code&gt;containerd&lt;/code&gt;不同，&lt;code&gt;dockerd&lt;/code&gt; 端的套接字没有绑定任何文件系统路径，这是一个匿名套接字。同样，行末的 &lt;code&gt;-&amp;gt;INO=14525 1131,container,8u (CONNECTED)&lt;/code&gt; 验证了连接的对称性，对端是进程 ID 为 1131 的 containerd，连接状态同样是已建立。&lt;/p&gt;
&lt;p&gt;而我们上面查看 Java 进程 2444401 持有的 domain socket，并么有发现对端信息。我们现在只知道 Java 进程通过文件描述符 6 持有一个 domain socket，但是 domain socket 的作用是什么，为什么会被创建，完全不知道。如何进一步排查呢？&lt;/p&gt;
&lt;h2 id=&#34;strace&#34;&gt;
    &lt;a href=&#34;#strace&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    strace
&lt;/h2&gt;&lt;p&gt;首先想到的是通过 strace 追踪系统调用，看能不能发现什么有用的信息。在 Java 进程的启动命令前加入 strace：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# -f 跟踪子进程（fork/vfork/clone 创建的进程）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# -yy 增强网络信息显示，打印 socket 的完整协议信息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# -e trace=desc,network  过滤系统调用类型，跟踪文件描述符和网络相关的调用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;strace -f -yy -e &lt;span class=&#34;nv&#34;&gt;trace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;desc,network -o /tmp/startup_trace.log java ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最终在 &lt;code&gt;startup_trace.log&lt;/code&gt; 文件中，没有找到文件描述 6 相关的信息，这条路没走通。&lt;/p&gt;
&lt;h2 id=&#34;安装-bcc&#34;&gt;
    &lt;a href=&#34;#%e5%ae%89%e8%a3%85-bcc&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    安装 BCC
&lt;/h2&gt;&lt;p&gt;然后想到，可以使用 eBPF 追踪系统中，所有 domain socket 的创建信息。先安装 &lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BCC&lt;/a&gt;，当前内核版本较低，从源码编译安装 BCC。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装编译依赖&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dnf groupinstall -y &lt;span class=&#34;s2&#34;&gt;&amp;#34;Development Tools&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dnf install -y cmake clang llvm python3-devel elfutils-libelf-devel
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装 LLVM 和 Clang 开发包&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dnf install -y llvm-devel clang-devel
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 查找 LLVM 安装路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;find /usr -name &lt;span class=&#34;s2&#34;&gt;&amp;#34;LLVMConfig.cmake&amp;#34;&lt;/span&gt; 2&amp;gt;/dev/null
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/usr/lib64/cmake/llvm/LLVMConfig.cmake
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;which llvm-config
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/usr/bin/llvm-config
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 克隆 BCC 源码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/iovisor/bcc.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; bcc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 创建构建目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir build &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; build
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 配置编译，指定 Python 路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用找到的 LLVM 路径配置 CMake，`-DLLVM_DIR` 参数应该指向包含 `LLVMConfig.cmake` 文件的目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake .. -DPYTHON_CMD&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;python3 -DLLVM_DIR&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/lib64/cmake/llvm
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 编译（使用多核加速）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make -j&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;nproc&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ldconfig
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;安装完成后进行验证：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python3 -c &lt;span class=&#34;s2&#34;&gt;&amp;#34;from bcc import BPF; print(&amp;#39;BCC 安装成功！&amp;#39;)&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;BCC 安装成功！
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;bcc-脚本&#34;&gt;
    &lt;a href=&#34;#bcc-%e8%84%9a%e6%9c%ac&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    BCC 脚本
&lt;/h2&gt;&lt;p&gt;指挥 AI 写一个追踪 domain socket 创建的脚本 &lt;code&gt;trace_unix_socket_creation.py&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;ch&#34;&gt;#!/usr/bin/env python3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;re&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;bcc&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# AF_UNIX 的值为 1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;AF_UNIX&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;prog&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;#include &amp;lt;uapi/linux/ptrace.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;#include &amp;lt;linux/sched.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;#include &amp;lt;net/sock.h&amp;gt; // For AF_UNIX
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;struct data_t {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    u32 tid;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    u32 ppid;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    int stack_id;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;BPF_HASH(infotmp, u32, struct data_t);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;BPF_STACK_TRACE(stack_traces, 1024);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;// Hook for socket() syscall
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;int trace_socket_entry(struct pt_regs *ctx, int domain, int type, int protocol) {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    if (domain != AF_UNIX) {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        return 0;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    u32 tid = bpf_get_current_pid_tgid() &amp;gt;&amp;gt; 32;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    struct task_struct *task = (struct task_struct *)bpf_get_current_task();
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    u32 ppid = 0;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    bpf_probe_read_kernel(&amp;amp;ppid, sizeof(ppid), &amp;amp;task-&amp;gt;real_parent-&amp;gt;tgid);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    struct data_t data = &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    data.tid = tid;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    data.ppid = ppid;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    data.stack_id = stack_traces.get_stackid(ctx, BPF_F_USER_STACK);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    infotmp.update(&amp;amp;tid, &amp;amp;data);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    return 0;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;int trace_socket_return(struct pt_regs *ctx) {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    u32 tid = bpf_get_current_pid_tgid() &amp;gt;&amp;gt; 32;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    struct data_t *datap = infotmp.lookup(&amp;amp;tid);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    if (!datap) return 0;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    int retval = PT_REGS_RC(ctx);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    if (retval &amp;gt;= 0) {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        bpf_trace_printk(&amp;#34;socket(AF_UNIX) call: ppid=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%d&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; tid=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%d&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; new_fd=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%d&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;\\n&amp;#34;, datap-&amp;gt;ppid, datap-&amp;gt;tid, retval);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        bpf_trace_printk(&amp;#34;stackid=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%d&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;\\n&amp;#34;, datap-&amp;gt;stack_id);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    infotmp.delete(&amp;amp;tid);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    return 0;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attach_kprobe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;__sys_socket&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;trace_socket_entry&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attach_kretprobe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;__sys_socket&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;trace_socket_return&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Tracing socket(AF_UNIX, ...) calls... Ctrl-C to stop.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;tid_to_tgid_cache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_tgid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tid_to_tgid_cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tid_to_tgid_cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# --- 关键修改：处理竞态条件 ---&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/proc/&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;/status&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;line&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;line&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;startswith&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Tgid:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;n&#34;&gt;tgid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;line&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;split&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;n&#34;&gt;tid_to_tgid_cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tgid&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tgid&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 捕获 FileNotFoundError 或 ProcessLookupError&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;except&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;FileNotFoundError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;ProcessLookupError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# 线程已退出，返回 -1 表示无效&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;task&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;trace_fields&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;decode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;errors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;replace&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;strip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;stackid=&amp;#34;&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;re&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;search&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;stackid=(\d+)&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;sid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;tgid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_tgid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;c1&#34;&gt;# 只有在成功获取 TGID 时才尝试解析符号&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tgid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;stack_traces&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;walk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;    &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%s&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sym&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tgid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;show_module&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;show_offset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;    [Could not get symbols for exited tid &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;]&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;except&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;KeyboardInterrupt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;AI 还贴心的给出了脚本执行的流程图：
&lt;img src=&#34;https://cdn.mazhen.tech/2024/202509031554586.svg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;flow&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;最终定位&#34;&gt;
    &lt;a href=&#34;#%e6%9c%80%e7%bb%88%e5%ae%9a%e4%bd%8d&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    最终定位
&lt;/h2&gt;&lt;p&gt;先停止 Java 进程，然后运行该脚本，在启动 Java 进程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./trace_unix_socket_creation.py &amp;gt; socket_trace
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;socket_trace&lt;/code&gt; 中根据 Java 进程的 PID 搜索，找到了 文件描述 6 的创建调用堆栈：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;socket(AF_UNIX) call: ppid=1527014 tid=1527479 new_fd=6\n
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;stackid=523\n
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;socket+0x8 [libc-2.28.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;[unknown] [libnss_sss.so.2]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;_nss_sss_getpwuid_r+0xe4 [libnss_sss.so.2]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;getpwuid_r+0x14c [libc-2.28.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;get_user_name(unsigned int)+0x5c [libjvm.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;PerfMemory::create_memory_region(unsigned long)+0x94 [libjvm.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;perfMemory_init()+0xa8 [libjvm.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;vm_init_globals()+0x24 [libjvm.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;Threads::create_vm(JavaVMInitArgs*, bool*)+0x234 [libjvm.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;JNI_CreateJavaVM+0x80 [libjvm.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;JavaMain+0x80 [libjli.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;ThreadJavaMain+0xc [libjli.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;[unknown] [libpthread-2.28.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&amp;#39;[unknown] [libc-2.28.so]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;调用堆栈记录了文件描述符 6 被创建的全过程，让我们从下往上，一步步还原：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;JNI_CreateJavaVM&lt;/code&gt;&lt;/strong&gt;: Java 虚拟机的诞生。当我们执行 &lt;code&gt;java&lt;/code&gt; 命令时，&lt;code&gt;libjli.so&lt;/code&gt; (Java Launcher Interface) 库会加载核心的 JVM 库 (&lt;code&gt;libjvm.so&lt;/code&gt;)，并调用 &lt;code&gt;JNI_CreateJavaVM&lt;/code&gt; 这个函数来真正创建和初始化一个 JVM 实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Threads::create_vm&lt;/code&gt; -&amp;gt; &lt;code&gt;vm_init_globals&lt;/code&gt;&lt;/strong&gt;: 在 JVM 内部，&lt;code&gt;create_vm&lt;/code&gt; 函数开始搭建虚拟机运行所需的基础环境，其中一步就是初始化各种全局组件 (&lt;code&gt;vm_init_globals&lt;/code&gt;)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;perfMemory_init&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;perfMemory&lt;/code&gt; 子系统被初始化。这个子系统是 JVM 性能监控的关键。它负责创建一块特殊的内存区域，用于存放 JVM 内部的性能计数器，例如 JIT 编译统计、垃圾回收次数和耗时等。我们熟知的 &lt;code&gt;jps&lt;/code&gt;、&lt;code&gt;jstat&lt;/code&gt;、&lt;code&gt;jcmd&lt;/code&gt; 等命令行工具，正是通过读取这块内存区域来获取 JVM 实时运行数据的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;PerfMemory::create_memory_region&lt;/code&gt; -&amp;gt; &lt;code&gt;get_user_name&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;PerfMemory&lt;/code&gt; 创建的这块内存区域，实际上是以内存映射文件（memory-mapped file）的形式存在的，这些文件通常位于 &lt;code&gt;/tmp/hsperfdata_&amp;lt;username&amp;gt;/&lt;/code&gt; 目录下（&lt;code&gt;hsperfdata&lt;/code&gt; 是 HotSpot Performance Data 的缩写）。为了构建这个目录路径，JVM 需要知道当前运行它的用户名是什么，于是它调用了内部函数 &lt;code&gt;get_user_name&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;getpwuid_r&lt;/code&gt; -&amp;gt; &lt;code&gt;_nss_sss_getpwuid_r&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;get_user_name&lt;/code&gt; 函数通过调用标准的 glibc 函数 &lt;code&gt;getpwuid_r&lt;/code&gt;，根据当前用户的 UID (User ID) 来查询其用户名。在现代 Linux 系统中，这个查询过程并非简单地读取 &lt;code&gt;/etc/passwd&lt;/code&gt; 文件。它是由 &lt;strong&gt;NSS (Name Service Switch)&lt;/strong&gt; 机制来管理的。NSS 会根据 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; 的配置，将这类查询请求转发给相应的处理模块。在我们的例子中，请求被转发给了 &lt;strong&gt;SSSD (System Security Services Daemon)&lt;/strong&gt; 的客户端库 &lt;code&gt;libnss_sss.so.2&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;[unknown] [libnss_sss.so.2]&lt;/code&gt; -&amp;gt; &lt;code&gt;socket&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;libnss_sss.so.2&lt;/code&gt; 库只是一个“中间人”，它需要和后台运行的 &lt;code&gt;sssd&lt;/code&gt; 守护进程进行通信，才能真正完成用户信息的查询。它选择的通信方式正是 Unix Domain Socket。于是，它调用了 &lt;code&gt;socket()&lt;/code&gt; 系统调用来创建一个套接字，准备连接 &lt;code&gt;sssd&lt;/code&gt; 服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;new_fd=6&lt;/code&gt;&lt;/strong&gt;: 在这个精确的时间点，我们的 Java 进程中最小的可用文件描述符编号恰好是 6。因此，内核将 6 这个编号分配给了这个新创建的套接字。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，文件描述符 6 并非由我们的 Java 应用代码直接创建，而是在 JVM 启动的极早期，由其内部的性能监控子系统为了获取当前用户名，间接触发了系统的 NSS 模块，进而由 SSSD 客户端库创建的、用于和 SSSD 后台服务通信的 Unix Domain Socket。&lt;/p&gt;
&lt;h2 id=&#34;sssd-是什么&#34;&gt;
    &lt;a href=&#34;#sssd-%e6%98%af%e4%bb%80%e4%b9%88&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    SSSD 是什么
&lt;/h2&gt;&lt;p&gt;从堆栈分析可知，这个 Domain Socket 是为了连接 SSSD 服务。SSSD (System Security Services Daemon) 是现代 Linux 系统中用于集中管理身份认证、授权和用户信息查询的核心服务。它充当了一个缓存和转发层，可以对接多种后端服务，如本地文件、LDAP、Kerberos 或 Active Directory。&lt;/p&gt;
&lt;p&gt;SSSD 的作用是响应来自 &lt;code&gt;libnss_sss&lt;/code&gt; 库的请求，查询并返回当前 UID 对应的用户名。&lt;code&gt;libc&lt;/code&gt; 库在第一次查询后，通常会保持这个套接字连接打开，以便后续的查询可以复用这个连接，避免重复创建和连接的开销。这解释了为什么在 Java 进程的整个生命周期中，我们都能看到这个 FD 6 的存在。&lt;/p&gt;
&lt;h3 id=&#34;查看-sssd-进程及其配置&#34;&gt;
    &lt;a href=&#34;#%e6%9f%a5%e7%9c%8b-sssd-%e8%bf%9b%e7%a8%8b%e5%8f%8a%e5%85%b6%e9%85%8d%e7%bd%ae&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    查看 SSSD 进程及其配置
&lt;/h3&gt;&lt;p&gt;我们可以使用 &lt;code&gt;systemctl&lt;/code&gt; 来确认 &lt;code&gt;sssd&lt;/code&gt; 服务的运行状态。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 检查 sssd 服务的总体状态&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;systemctl status sssd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;● sssd.service - System Security Services Daemon
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   Loaded: loaded &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;/usr/lib/systemd/system/sssd.service&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; enabled&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; vendor preset: disabled&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   Active: active &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;running&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; since Tue 2025-08-05 11:03:10 CST&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; weeks &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; days ago
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Main PID: &lt;span class=&#34;m&#34;&gt;916&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;sssd&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    Tasks: &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   Memory: 45.8M
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   CGroup: /system.slice/sssd.service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           ├─ &lt;span class=&#34;m&#34;&gt;916&lt;/span&gt; /usr/sbin/sssd -i --logger&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;files
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           ├─1027 /usr/libexec/sssd/sssd_be --domain implicit_files --uid &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; --gid &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; --logger&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;files
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           ├─1054 /usr/libexec/sssd/sssd_nss --uid &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; --gid &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; --logger&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;files
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           └─1055 /usr/libexec/sssd/sssd_pam --uid &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; --gid &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; --logger&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;files
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;查看 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; 文件，是否在 passwd、group、shadow 等关键数据库的查询源列表中包含了 sss。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cat /etc/nsswitch.conf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;passwd:      sss files systemd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;shadow:     files sss
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;group:       sss files systemd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;passwd&lt;/code&gt; 这一行表明，当需要查询用户信息时，首先就去问 SSSD 服务 (sss)，然后再查找本地的 /etc/passwd 文件 (files)，如果前两者都找不到，还会查询由 systemd-logind 管理的动态用户。&lt;/p&gt;
&lt;p&gt;这个配置清晰地表明，SSSD 在该系统的用户和组信息查询中处于最高优先级。这解释了，在 JVM 在启动时，为了获取当前用户名，就会立即触发与 SSSD 的通信。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;
    &lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    总结
&lt;/h2&gt;&lt;p&gt;通过 &lt;code&gt;lsof&lt;/code&gt; 初步定位问题，再借助强大的 eBPF 工具 BCC 深入追踪系统调用，成功地揭开了 JVM 底层的文件描述符的秘密。它并非由应用代码创建，而是 JVM 初始化性能监控模块时，通过 NSS 机制与系统核心的 SSSD 服务建立的通信通道。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>理解 CRaC 背后的 Linux 系统编程</title>
        <link>https://mazhen.tech/p/%E7%90%86%E8%A7%A3-crac-%E8%83%8C%E5%90%8E%E7%9A%84-linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</link>
        <pubDate>Wed, 30 Apr 2025 10:18:47 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E7%90%86%E8%A7%A3-crac-%E8%83%8C%E5%90%8E%E7%9A%84-linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</guid>
        <description>&lt;h2 id=&#34;crac-的性能飞跃与-linux-内核的基石&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e6%80%a7%e8%83%bd%e9%a3%9e%e8%b7%83%e4%b8%8e-linux-%e5%86%85%e6%a0%b8%e7%9a%84%e5%9f%ba%e7%9f%b3&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的性能飞跃与 Linux 内核的基石
&lt;/h2&gt;&lt;p&gt;Java 应用的启动速度，尤其是在微服务和 Serverless 场景下的“冷启动”，一直是其性能优化的重点。传统的启动过程涉及 JVM 初始化、类加载和 JIT 预热，耗时较长。&lt;strong&gt;CRaC (Coordinated Restore at Checkpoint)&lt;/strong&gt; 技术为此提供了一种创新方案：它在应用达到理想状态时捕获其完整运行时快照（Checkpoint），并在需要时快速恢复（Restore），从而实现毫秒级启动和即时峰值性能。&lt;/p&gt;
&lt;p&gt;这种强大的进程“冻结”与“复苏”能力并非凭空而来，它深度依赖于 Linux 操作系统提供的底层机制，并通过 &lt;strong&gt;CRIU (Checkpoint/Restore In Userspace)&lt;/strong&gt; 这个工具集得以实现。因此，要真正理解 CRaC 的工作原理，探究其背后的 Linux 系统编程知识至关重要。本文将为熟悉编程但可能不熟悉 Linux 底层的开发者，解析 CRaC 实现所依赖的关键 Linux 概念（如进程/线程、/proc 文件系统、ptrace 系统调用等），揭示 CRaC 性能飞跃背后的 Linux“魔法”。&lt;/p&gt;
&lt;h2 id=&#34;进程与线程及其生命周期&#34;&gt;
    &lt;a href=&#34;#%e8%bf%9b%e7%a8%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b%e5%8f%8a%e5%85%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    进程与线程及其生命周期
&lt;/h2&gt;&lt;p&gt;要理解 CRaC 如何操作运行中的 Java 应用，我们首先需要了解 Linux 是如何组织和管理程序执行的。其核心概念是&lt;strong&gt;进程 (Process)&lt;/strong&gt;。你可以将进程看作是一个&lt;strong&gt;正在运行的程序的实例&lt;/strong&gt;，它是操作系统分配资源（如内存、文件句柄）和进行调度的基本单位。每个进程都仿佛生活在自己的独立世界里，拥有独立的地址空间，这保证了进程间的隔离性。&lt;/p&gt;
&lt;p&gt;然而，在一个进程内部，往往需要同时执行多个任务流。这时&lt;strong&gt;线程 (Thread)&lt;/strong&gt; 就登场了。线程是进程内部的实际执行单元，有时也被称为轻量级进程（LWP）。与进程不同，同一进程内的所有线程&lt;strong&gt;共享&lt;/strong&gt;该进程的地址空间和大部分资源，这使得线程间的通信和切换更为高效。但每个线程仍然保有自己独立的执行上下文，如程序计数器、寄存器和栈。&lt;/p&gt;
&lt;p&gt;有趣的是，从 Linux 内核的视角来看，它并不严格区分进程和线程。两者都被视为可调度的“&lt;strong&gt;任务 (Task)&lt;/strong&gt;”，并由统一的数据结构 task_struct 来描述。线程仅仅是与其他任务共享了更多资源（特别是内存地址空间）的任务而已。因此，内核调度器可以对它们一视同仁。为了管理这些任务，系统为它们分配了唯一的身份标识：&lt;strong&gt;PID (Process ID)&lt;/strong&gt; 用于标识整个进程（一组共享资源的线程），而 &lt;strong&gt;TID (Thread ID)&lt;/strong&gt; 则用于标识每一个单独的线程（任务）。对于单线程进程，PID 和 TID 是相同的。&lt;/p&gt;
&lt;p&gt;新进程的诞生，最经典的方式是通过 fork() 系统调用。当一个进程调用 fork()，内核会创建出它的一个几乎完全相同的副本——子进程。子进程继承了父进程大部分状态，包括内存内容的副本（通过写时复制优化）、文件描述符等。fork() 的奇妙之处在于它在父进程中返回子进程的 PID，而在子进程中返回 0，使得程序可以根据返回值区分父子，执行不同的逻辑。CRIU 在恢复进程状态时，正是利用 fork() 来重建 Checkpoint 时刻的进程树结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fork() 示例代码 (fork_example.c)&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 创建子进程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// fork 失败  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;fork failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 子进程执行的代码  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;I am the child process, PID: %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 模拟工作  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child process exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_SUCCESS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 子进程正常退出  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 父进程执行的代码  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;I am the parent process, PID: %d, Child PID: %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent waiting for child...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 简单等待任意子进程  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent process: Child finished.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Process %d exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 编译运行：gcc fork_example.c -o fork_example &amp;amp;&amp;amp; ./fork_example
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;除了 fork()，还有一个更底层的系统调用 clone()，它提供了更细粒度的控制，允许指定新创建的任务与父任务共享哪些资源，因此 clone() 既可以用来创建进程，也可以用来创建线程。&lt;/p&gt;
&lt;p&gt;fork() 创建的子进程默认执行的是和父进程相同的代码。如果希望子进程去执行一个&lt;strong&gt;全新的程序&lt;/strong&gt;，就需要 exec 系列系统调用（如 execv(), execlp() 等）的帮助。exec 调用会用新程序的映像&lt;strong&gt;完全替换&lt;/strong&gt;当前进程的内存空间（代码、数据、堆栈），然后从新程序的入口点开始执行。一旦 exec 成功，原来的程序就不复存在了，这个调用本身也不会返回。CRaC 在恢复过程中，criuengine 这个辅助程序就利用了一连串的 execv 调用，不断“变身”，最终成为负责等待恢复后 JVM 退出的 restorewait 进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;execv() 示例代码 (exec_example.c)&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;fork failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 子进程  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child process (PID: %d) will execute &amp;#39;ls -l&amp;#39;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/bin/ls&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;-l&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 准备参数列表  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;execv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 执行新程序  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 如果 execv 返回，说明出错了  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;execv failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 父进程  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent process (PID: %d) waiting for child (PID: %d)...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 等待子进程结束  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent process: Child finished executing &amp;#39;ls -l&amp;#39;.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 编译运行：gcc exec_example.c -o exec_example &amp;amp;&amp;amp; ./exec_example
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;进程有生就有灭。当子进程结束时，它并不会立即消失。内核会保留它的退出状态等信息，等待父进程来“认领”。父进程通过调用 wait() 或 waitpid() 系统调用来获取子进程的终止信息，并告知内核可以彻底清理该子进程了。waitpid() 提供了更多控制，比如可以等待指定的子进程，或者以非阻塞的方式检查子进程状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;waitpid() 示例代码 (waitpid_example.c)&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 创建第一个子进程  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Child 1 */&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child 1 (PID: %d) running...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child 1 exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 创建第二个子进程  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Child 2 */&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child 2 (PID: %d) running...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child 2 exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 父进程等待特定的子进程 pid1  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent waiting for Child 1 (PID: %d)...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;terminated_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;waitpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 阻塞等待 pid1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;terminated_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WIFEXITED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent: Child 1 terminated normally with status: %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WEXITSTATUS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Handle error or abnormal termination */&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 父进程等待另一个子进程 pid2  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent waiting for Child 2 (PID: %d)...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;terminated_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;waitpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 阻塞等待 pid2  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;     &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;terminated_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WIFEXITED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent: Child 2 terminated normally with status: %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WEXITSTATUS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Handle error or abnormal termination */&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 编译运行：gcc waitpid_example.c -o waitpid_example &amp;amp;&amp;amp; ./waitpid_example
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果在子进程终止后，父进程没有及时调用 wait() 或 waitpid()，那么这个子进程就会变成&lt;strong&gt;僵尸进程 (Zombie Process)&lt;/strong&gt;。它虽然不再运行，但仍在进程表中占据一个位置，等待父进程回收。如果父进程先于子进程退出，子进程就成了&lt;strong&gt;孤儿进程 (Orphan Process)&lt;/strong&gt;。为了避免孤儿进程变成无人认领的僵尸，Linux 会自动将它们的父进程设置为 init 进程（PID 1），由 init 进程负责回收它们。&lt;/p&gt;
&lt;p&gt;理解了孤儿进程和父进程回收机制后，就能明白一种常见的编程技巧——&lt;strong&gt;Double Fork&lt;/strong&gt;。它的目的是创建一个与原始父进程完全脱离关系的后台进程（守护进程）。其步骤是：进程 A fork 出子进程 B，然后进程 A 立刻 waitpid() 等待 B 结束并退出；子进程 B 再次 fork 出孙子进程 C，然后 B 自己立刻退出；此时，孙子进程 C 成为孤儿，被 init 进程接管，从而与 A 彻底解耦。CRIU 在执行 Checkpoint 时，就运用了类似 double fork 的方法，让执行 criu dump 命令的进程脱离被操作的 JVM 进程树，避免了“自己冻结自己”的尴尬局面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;double_fork 示例代码 (double_fork_example.c)&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第一次 fork
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;First fork failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第一个子进程 (进程 B)  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第二次 fork  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Second fork failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 孙子进程 (进程 C)  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Grandchild process (PID: %d, Parent PID: %d) starting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getppid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 通常在这里执行 setsid() 等守护进程化操作  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nf&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 模拟后台任务  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Grandchild process finished.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第一个子进程 (进程 B) 立即退出  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;First child process (PID: %d) exiting immediately.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 原始父进程 (进程 A)  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Original parent process (PID: %d) waiting for first child (PID: %d).&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;waitpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 等待第一个子进程退出  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Original parent exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 孙子进程已成为孤儿并由 init 接管  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 编译运行：gcc double_fork_example.c -o double_fork_example &amp;amp;&amp;amp; ./double_fork_example
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;掌握了 Linux 进程和线程的生命周期管理，我们就能更好地理解 CRaC 是如何在这些基础上进行精确的状态捕获与恢复。接下来，我们将目光投向 Linux 提供的一个强大工具——/proc 文件系统，看看它如何帮助我们“透视”运行中进程的内部状态。&lt;/p&gt;
&lt;h2 id=&#34;proc-文件系统内核状态的透视镜&#34;&gt;
    &lt;a href=&#34;#proc-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e5%86%85%e6%a0%b8%e7%8a%b6%e6%80%81%e7%9a%84%e9%80%8f%e8%a7%86%e9%95%9c&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    /proc 文件系统：内核状态的“透视镜”
&lt;/h2&gt;&lt;p&gt;我们已经了解了 Linux 如何创建和管理进程，但要实现像 CRaC 那样的“冻结”与“复苏”，就必须有办法&lt;strong&gt;深入探查&lt;/strong&gt;一个正在运行的进程内部的详细状态。Linux 提供了一个非常强大的机制来做到这一点，那就是 /proc 文件系统。&lt;/p&gt;
&lt;p&gt;初看起来，/proc 像是一个普通的目录，你可以用 cd 进入，用 ls 查看。但它实际上是一个&lt;strong&gt;虚拟文件系统&lt;/strong&gt;。这意味着它里面的文件和目录并不真正存储在磁盘上，而是由 Linux 内核在&lt;strong&gt;运行时动态生成&lt;/strong&gt;的。/proc 是内核向用户空间（运行中的程序和用户）暴露其内部数据结构和系统信息的主要接口之一。你可以把它想象成一扇窗户，透过它，我们可以直接观察到内核管理下的系统状态，特别是&lt;strong&gt;运行中进程的实时信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这对于 CRIU 和 CRaC 来说简直是无价之宝。当 CRIU 需要对一个进程执行 Checkpoint 时，它的大部分信息来源就是 /proc 文件系统。通过读取 /proc 下的特定文件，CRIU 能够获取到目标进程几乎所有的关键状态数据，从而构建出完整的进程快照。&lt;/p&gt;
&lt;p&gt;让我们来看看 /proc 下与进程相关的几个关键“情报站”，它们通常位于以进程 PID 命名的目录下，即 /proc/&amp;lt;pid&amp;gt;/：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存布局图 (/proc/&amp;lt;pid&amp;gt;/maps 和 smaps)&lt;/strong&gt;: 这两个文件揭示了进程的虚拟内存是如何组织的。maps 文件列出了进程的所有内存区域（称为 VMA，Virtual Memory Area），包括代码段、数据段、堆、栈以及内存映射的文件和共享库，标明了每个区域的起止地址和权限。smaps 文件则提供了更详细的信息，包括每个 VMA 实际占用的物理内存（RSS - Resident Set Size）、共享/私有内存量、脏页（Dirty pages）数量等。CRIU 通过解析它们来精确了解进程的内存结构，这是 Checkpoint 和 Restore 内存状态的基础。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;打开的文件和连接 (/proc/&amp;lt;pid&amp;gt;/fd/ 和 fdinfo/)&lt;/strong&gt;: fd 是一个目录，里面包含了指向该进程当前打开的所有文件描述符的符号链接。链接的名称就是文件描述符的数字（如 0, 1, 2 分别代表标准输入、输出、错误），链接的目标则指明了它实际代表的文件、管道或套接字。而 fdinfo 目录下则包含了与 fd 中每个描述符对应的文件，记录了更详细的状态信息，比如文件的当前读写位置（offset）、打开时的标志位（flags）等。CRIU 需要读取这些信息来保存和恢复进程打开的文件状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程状态报告 (/proc/&amp;lt;pid&amp;gt;/stat)&lt;/strong&gt;: 这个文件以一行文本的形式，提供了关于进程的大量状态信息，由空格分隔。包括进程名、状态（运行、睡眠、僵尸等）、父进程 PID、进程组 ID、使用的内存量、CPU 时间统计等等。CRIU 用它来获取进程的基本属性和运行统计。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程成员列表 (/proc/&amp;lt;pid&amp;gt;/task/)&lt;/strong&gt;: 对于多线程进程，这个目录非常重要。它下面包含了以该进程下&lt;strong&gt;所有线程的 TID&lt;/strong&gt; 命名的子目录。通过遍历这个目录，CRIU 可以识别出一个进程包含的所有线程（任务），并对每个线程进行单独的状态捕获。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子进程记录 (/proc/&amp;lt;pid&amp;gt;/task/&amp;lt;tid&amp;gt;/children)&lt;/strong&gt;: 这个文件（位于特定线程目录下）记录了由该线程直接创建的所有子进程的 PID 列表。通过递归地读取这个文件，CRIU 能够准确地构建出完整的进程树或进程家族。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存映射文件访问 (/proc/&amp;lt;pid&amp;gt;/map_files/)&lt;/strong&gt;: 这个目录包含了指向进程内存中通过文件映射（mmap）方式加载的实际文件的符号链接。链接的名称对应 maps 文件中的地址范围。这为 CRIU 提供了一种可靠的方式来访问和读取这些映射文件的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过组合利用 /proc 文件系统提供的这些（以及其他未列出的）信息源，CRIU 能够像侦探一样，细致入微地收集目标进程及其所有线程、子进程在 Checkpoint 时刻的完整状态。没有 /proc 这个强大的“透视镜”，实现用户空间的 Checkpoint/Restore 将会困难得多。&lt;/p&gt;
&lt;p&gt;了解了如何通过 /proc 获取进程状态后，我们接下来将关注进程运行的“舞台”——内存管理，以及进程如何与外部世界交互的“管道”——文件描述符。&lt;/p&gt;
&lt;h2 id=&#34;ptrace-系统调用掌控进程的遥控器&#34;&gt;
    &lt;a href=&#34;#ptrace-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e6%8e%8c%e6%8e%a7%e8%bf%9b%e7%a8%8b%e7%9a%84%e9%81%a5%e6%8e%a7%e5%99%a8&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    ptrace 系统调用：掌控进程的“遥控器”
&lt;/h2&gt;&lt;p&gt;通过 /proc 文件系统，我们获得了观察运行中进程内部状态的强大能力，就像有了一副“透视镜”。但这还不够，要实现像 CRaC/CRIU 的 Checkpoint/Restore，我们不仅需要&lt;strong&gt;观察&lt;/strong&gt;，还需要能够&lt;strong&gt;控制&lt;/strong&gt;和&lt;strong&gt;操纵&lt;/strong&gt;目标进程——在合适的时机让它暂停，读取甚至修改它的内存和寄存器状态，甚至强制它执行某些操作。这时，Linux 提供了一个终极武器，也是一个颇具争议但极其强大的系统调用：ptrace (process trace)。&lt;/p&gt;
&lt;p&gt;ptrace 提供了一种机制，允许一个进程（称为 &lt;strong&gt;tracer&lt;/strong&gt;，追踪者）去&lt;strong&gt;观察和控制&lt;/strong&gt;另一个进程（称为 &lt;strong&gt;tracee&lt;/strong&gt;，被追踪者）的执行，检查和改变 tracee 的内存和寄存器。你可以把它想象成一个赋予 tracer 进程的“远程控制器”，可以用来遥控 tracee 进程的一举一动。&lt;/p&gt;
&lt;p&gt;这个系统调用是许多底层工具的基石：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;调试器 (Debuggers)&lt;/strong&gt;：像 GDB 这样的调试器，其核心功能（设置断点、单步执行、检查变量值、查看调用栈等）几乎完全依赖于 ptrace。调试器就是一个 tracer 进程，而被调试的程序就是 tracee。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统调用追踪工具 (System Call Tracers)&lt;/strong&gt;：strace 命令能够显示一个进程执行的所有系统调用及其参数和返回值，这也是通过 ptrace 实现的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRIU (Checkpoint/Restore In Userspace)&lt;/strong&gt;：正如我们之前提到的，CRIU 大量使用 ptrace 来完成那些仅靠 /proc 无法完成的任务，比如精确地暂停进程、获取和恢复寄存器状态、注入“寄生代码”等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ptrace 本身是一个非常复杂的系统调用，它的行为由传递给它的第一个参数 request 决定。下面我们介绍一些它提供的关键能力，这些能力对于理解 CRIU 的工作至关重要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;建立追踪关系 (Attaching)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;PTRACE_ATTACH 或 PTRACE_SEIZE：这是 tracer 控制 tracee 的第一步。Tracer 使用这两个请求之一来“附着”到目标 tracee 进程上。一旦附着成功，tracee 就会暂停下来，并且其状态变化（如收到信号、执行系统调用）都会通知 tracer。PTRACE_SEIZE 是一个较新的、更推荐的方式，它避免了 PTRACE_ATTACH 中使用 SIGSTOP 信号可能带来的副作用，控制更为精确。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读写寄存器 (Reading/Writing Registers)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;PTRACE_GETREGS, PTRACE_GETFPREGS 等：允许 tracer 读取 tracee 当前的通用寄存器（如指令指针 EIP/RIP、栈指针 ESP/RSP 等）、浮点寄存器等 CPU 状态。&lt;/li&gt;
&lt;li&gt;PTRACE_SETREGS, PTRACE_SETFPREGS 等：允许 tracer 修改 tracee 的寄存器状态。这对于恢复进程到某个精确的执行点至关重要，CRIU 在 Restore 阶段就需要用它来设置好恢复后进程的 CPU 上下文。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读写内存 (Reading/Writing Memory)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;PTRACE_PEEKDATA, PTRACE_PEEKTEXT：允许 tracer 读取 tracee 进程地址空间中任意位置的数据（通常以字长为单位）。&lt;/li&gt;
&lt;li&gt;PTRACE_POKEDATA, PTRACE_POKETEXT：允许 tracer 向 tracee 进程地址空间中任意位置写入数据。CRIU 正是利用这个能力，在 Checkpoint 阶段向目标进程注入“寄生代码”（一段帮助收集内部信息的二进制代码），并在 Restore 阶段将快照中的内存数据写回进程空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制执行 (Controlling Execution)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;PTRACE_CONT：让暂停的 tracee 继续执行。可以选择是否传递一个信号给 tracee。&lt;/li&gt;
&lt;li&gt;PTRACE_SYSCALL：让 tracee 继续执行，直到它进入或退出下一个系统调用时再次暂停，并通知 tracer。strace 就是基于此工作的。CRIU 也用它来精确控制目标进程执行特定的系统调用（如 mmap, munmap）来辅助内存的 Checkpoint 和 Restore。&lt;/li&gt;
&lt;li&gt;PTRACE_SINGLESTEP：让 tracee 执行&lt;strong&gt;一条&lt;/strong&gt;机器指令，然后再次暂停。这是调试器实现单步执行的基础。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解除追踪关系 (Detaching)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;PTRACE_DETACH：Tracer 结束对 tracee 的追踪。Tracee 会恢复正常执行，就像从未被追踪过一样（除非 tracer 修改了它的状态）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这些强大的（甚至可以说是危险的）能力，ptrace 赋予了 CRIU 超越普通进程权限的操作能力。它不仅能通过 /proc 看到进程的状态，更能像外科医生一样，精确地暂停进程、检查和修改其内部状态（内存和寄存器），甚至“借用”目标进程的上下文来执行特定操作（如注入代码、强制执行系统调用）。正是 ptrace 的存在，使得在用户空间实现复杂且精确的进程 Checkpoint/Restore 成为可能，也间接支撑了 CRaC 技术的实现。&lt;/p&gt;
&lt;p&gt;当然，ptrace 的强大也意味着潜在的风险，操作系统通常会对其使用施加一些安全限制（例如，一个普通用户进程不能随意 ptrace 其他用户的进程或特权进程）。&lt;/p&gt;
&lt;p&gt;理解了 ptrace 的核心能力后，我们对 CRIU 如何完成那些看似不可能的任务，应该有了更深的体会。接下来，我们将把前面介绍的知识点串联起来，看看 CRIU 具体是如何一步步实现 Checkpoint 和 Restore 的。&lt;/p&gt;
&lt;h2 id=&#34;criu-如何实现-checkpoint-和-restore&#34;&gt;
    &lt;a href=&#34;#criu-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0-checkpoint-%e5%92%8c-restore&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRIU 如何实现 Checkpoint 和 Restore？
&lt;/h2&gt;&lt;p&gt;现在，我们已经了解了 Linux 的进程线程模型、强大的 /proc 文件系统以及拥有“遥控”能力的 ptrace 系统调用。是时候将这些知识点串联起来，看看 CRIU (Checkpoint/Restore In Userspace) 是如何利用它们来施展“冻结” (Checkpoint) 和“复苏” (Restore) 进程的魔法了。&lt;/p&gt;
&lt;h3 id=&#34;checkpoint-冻结过程为进程拍下精确快照&#34;&gt;
    &lt;a href=&#34;#checkpoint-%e5%86%bb%e7%bb%93%e8%bf%87%e7%a8%8b%e4%b8%ba%e8%bf%9b%e7%a8%8b%e6%8b%8d%e4%b8%8b%e7%b2%be%e7%a1%ae%e5%bf%ab%e7%85%a7&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Checkpoint (冻结过程)：为进程拍下精确快照
&lt;/h3&gt;&lt;p&gt;当 CRIU 被要求对一个进程（及其后代）进行 Checkpoint 时，它会执行一系列精心设计的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;识别目标家族&lt;/strong&gt;: 首先，CRIU 需要确定要冻结的完整目标。它从用户指定的根进程 PID 开始，通过递归地读取 /proc/&amp;lt;pid&amp;gt;/task/&amp;lt;tid&amp;gt;/children 文件，像剥洋葱一样，找出所有相关的子进程和线程，构建出完整的&lt;strong&gt;进程树&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全体“立正”&lt;/strong&gt;: 接下来，CRIU 需要让这个庞大家族的所有成员都暂停下来。它使用 ptrace(PTRACE_SEIZE, &amp;hellip;) 附着到进程树中的&lt;strong&gt;每一个任务&lt;/strong&gt;（进程/线程）上。PTRACE_SEIZE 会让这些任务在下一次内核有机会介入时（比如系统调用或中断）进入暂停状态，并且这种暂停方式比老的 PTRACE_ATTACH 更为干净，不依赖 SIGSTOP 信号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信息大搜集&lt;/strong&gt;: 进程树被冻结后，CRIU 开始扮演“情报员”的角色，通过 /proc 文件系统和 ptrace 收集每个任务的详细状态：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存布局&lt;/strong&gt;: 解析 /proc/&amp;lt;pid&amp;gt;/maps 和 smaps 获取虚拟内存区域（VMA）的地址、大小、权限、映射来源（文件或匿名）等信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件描述符&lt;/strong&gt;: 读取 /proc/&amp;lt;pid&amp;gt;/fd/ 和 fdinfo/ 目录，记录下所有打开的文件、管道、套接字及其类型、路径、当前读写位置、标志位等状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程/线程核心状态&lt;/strong&gt;: 通过 /proc/&amp;lt;pid&amp;gt;/stat 获取进程的基本属性，更重要的是，使用 ptrace(PTRACE_GETREGS, &amp;hellip;) 和 PTRACE_GETFPREGS 等命令，直接读取每个任务暂停时的&lt;strong&gt;CPU 寄存器&lt;/strong&gt;内容（包括指令指针、栈指针、通用寄存器等）。这是确保恢复后能从正确位置继续执行的关键。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他资源&lt;/strong&gt;: 收集如信号处理器设置、定时器、凭证（UID/GID）、命名空间隶属关系等信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存内容转储 (可能需要“寄生虫”帮忙)&lt;/strong&gt;: 获取内存布局只是第一步，还需要把这些内存区域里的&lt;strong&gt;实际数据&lt;/strong&gt;保存下来。对于大部分内存区域，CRIU 可以通过 /proc/&amp;lt;pid&amp;gt;/mem 文件或者 process_vm_readv 系统调用来读取。但对于某些特殊或私有的内存区域，或者为了获取某些无法从外部探测的内部状态（如精确的文件描述符状态），直接读取可能受限或效率不高。这时，CRIU 会祭出它的“杀手锏”——&lt;strong&gt;寄生代码 (Parasite Code)&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;CRIU 使用 ptrace 在目标进程的地址空间中分配一小块内存（通过强制目标进程执行 mmap 系统调用）。&lt;/li&gt;
&lt;li&gt;然后，使用 ptrace(PTRACE_POKEDATA, &amp;hellip;) 将一段预先编译好的、与位置无关的（PIE）二进制代码（寄生代码）写入这块内存。&lt;/li&gt;
&lt;li&gt;最后，通过 ptrace 修改目标进程的指令指针，让它跳转执行这段寄生代码。&lt;/li&gt;
&lt;li&gt;寄生代码运行在目标进程的上下文中，拥有访问其所有资源的权限，可以高效地完成内存转储、收集内部信息等任务，并将结果传递给 CRIU。任务完成后，寄生代码通过 rt_sigreturn 系统调用恢复目标进程之前的寄存器状态，CRIU 再强制目标进程执行 munmap 清理掉寄生代码占用的内存，最后 ptrace(PTRACE_DETACH, &amp;hellip;) 脱离，整个过程对目标进程来说几乎是“无痕”的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写入镜像文件&lt;/strong&gt;: CRIU 将收集到的所有状态信息（内存布局、寄存器、文件描述符状态、内存数据等）组织起来，写入到磁盘上的一系列镜像文件中。这些文件共同构成了进程在 Checkpoint 时刻的完整快照。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(可选) 终止原进程&lt;/strong&gt;: 在某些场景下（比如 CRaC 的默认行为），Checkpoint 完成后，原始的 JVM 进程会被 CRIU 终止。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;restore-复苏过程从快照重建鲜活进程&#34;&gt;
    &lt;a href=&#34;#restore-%e5%a4%8d%e8%8b%8f%e8%bf%87%e7%a8%8b%e4%bb%8e%e5%bf%ab%e7%85%a7%e9%87%8d%e5%bb%ba%e9%b2%9c%e6%b4%bb%e8%bf%9b%e7%a8%8b&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Restore (复苏过程)：从快照重建鲜活进程
&lt;/h3&gt;&lt;p&gt;Restore 过程可以看作是 Checkpoint 的逆操作，它更加复杂，需要精确地重建进程状态：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;解析镜像，规划蓝图&lt;/strong&gt;: CRIU 首先读取 Checkpoint 生成的镜像文件，分析进程间的关系（父子、共享资源等），制定恢复计划。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;搭建骨架&lt;/strong&gt;: CRIU 严格按照镜像中记录的进程树结构，通过多次调用 fork() 来创建新的进程。在这个阶段，通常只创建进程的主线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复基本资源&lt;/strong&gt;: 对于每个新创建的进程，CRIU 开始恢复大部分状态：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件描述符&lt;/strong&gt;: 根据镜像信息重新打开文件（可能需要验证路径有效性）、创建管道和套接字，并设置好它们的状态（如文件偏移量）。对于共享的文件描述符，需要确保它们指向同一个内核对象（可能用到 SCM_RIGHTS 等技术）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存映射 (初步)&lt;/strong&gt;: 使用 mmap() 根据镜像中的 VMA 信息创建内存区域。对于私有内存，会先映射匿名内存，稍后再填充数据；对于文件映射，会重新映射相应的文件。此时映射的虚拟地址可能还不是最终的目标地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命名空间&lt;/strong&gt;: 如果进程使用了非默认的命名空间，CRIU 会负责创建或加入这些命名空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他&lt;/strong&gt;: 恢复工作目录、根目录、信号处理器等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键步骤：切换上下文与精细恢复&lt;/strong&gt;: 这是 Restore 中最精妙也最困难的部分。因为执行 Restore 操作的 CRIU 代码本身可能就位于需要被恢复内容覆盖的内存区域。为了解决这个问题：
&lt;ul&gt;
&lt;li&gt;CRIU 会找到一块临时的、安全的内存“空地”，加载一小段自包含的、位置无关的&lt;strong&gt;恢复器代码 (Restorer Context)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;然后，通过一次跳转，将 CPU 的控制权交给这段恢复器代码。&lt;/li&gt;
&lt;li&gt;在恢复器代码的控制下，进行最后也是最关键的恢复步骤：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;精确内存布局&lt;/strong&gt;: 使用 mremap() 将之前映射在临时地址的内存移动到镜像中记录的&lt;strong&gt;最终虚拟地址&lt;/strong&gt;。使用 mmap() 在正确的位置创建文件映射和共享内存映射。至此，进程的内存布局与 Checkpoint 时完全一致。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;填充内存数据&lt;/strong&gt;: 将镜像文件中保存的内存页数据，通过 read() 或类似方式写回到相应的内存区域。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复线程&lt;/strong&gt;: 在最终的内存布局中，根据保存的状态创建并恢复进程的所有其他线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复寄存器&lt;/strong&gt;: 使用 ptrace(PTRACE_SETREGS, &amp;hellip;)（或者在恢复器代码内部通过特定机制）将每个线程的 CPU 寄存器（特别是指令指针 IP/PC 和栈指针 SP）&lt;strong&gt;精确地设置&lt;/strong&gt;为 Checkpoint 时保存的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复其他细节&lt;/strong&gt;: 恢复定时器、凭证等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;“点火”启动&lt;/strong&gt;: 当所有状态都恢复完毕，恢复器代码会执行最后一步——通常是一个特殊的返回或跳转指令，将 CPU 的控制权彻底交还给恢复后的进程（主线程）。由于指令指针已经被精确设置，进程会从 Checkpoint 时被中断的那条指令&lt;strong&gt;无缝地继续执行&lt;/strong&gt;，仿佛从未被打断过。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管理 Restore 流程 (execv 链)&lt;/strong&gt;: 前面提到，CRaC 的 java -XX:CRaCRestoreFrom=&amp;hellip; 命令启动后，会通过 criuengine 这个辅助程序来协调 Restore。这个过程涉及多次 execv 调用：初始 Java 命令 execv 变成 criuengine restore，后者再 execv 变成 criu restore 来执行真正的恢复操作。当 criu restore 成功恢复目标 JVM 进程后，它会再次 execv 变成 criuengine restorewait，这个最终的进程负责等待恢复后的 JVM 进程结束，并将 JVM 的退出状态传递回去。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这一系列复杂而精密的步骤，结合对 /proc 的读取和对 ptrace 的深度运用，CRIU 实现了在用户空间对运行中进程进行快照和恢复的强大能力，为 CRaC 技术的实现奠定了坚实的基础。&lt;/p&gt;
&lt;p&gt;理解了 CRIU 的基本工作原理后，我们就能更好地理解 CRaC 为何还需要一个“协调”层。接下来，我们将探讨 CRaC 的 Resource API 存在的意义。&lt;/p&gt;
&lt;h2 id=&#34;crac-如何指挥-criu&#34;&gt;
    &lt;a href=&#34;#crac-%e5%a6%82%e4%bd%95%e6%8c%87%e6%8c%a5-criu&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 如何指挥 CRIU
&lt;/h2&gt;&lt;p&gt;我们已经了解了 CRIU 如何利用 Linux 的底层机制来实现进程的 Checkpoint 和 Restore。但 CRaC (Coordinated Restore at Checkpoint) 本身并不直接执行这些复杂的底层操作。相反，CRaC 更像是一个&lt;strong&gt;指挥官&lt;/strong&gt;，它通过协调 JVM 内部状态和外部资源，并在恰当的时机&lt;strong&gt;调用&lt;/strong&gt; CRIU 来完成实际的“冻结”与“复苏”工作。这种调用通常是通过一个辅助程序（在 OpenJDK CRaC 实现中称为 criuengine）来间接完成的。这个过程中，Linux 的进程创建、替换和管理技术，特别是 fork、execv 和 double fork，扮演了至关重要的角色。&lt;/p&gt;
&lt;h3 id=&#34;checkpoint-流程中的进程之舞-double-fork&#34;&gt;
    &lt;a href=&#34;#checkpoint-%e6%b5%81%e7%a8%8b%e4%b8%ad%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%b9%8b%e8%88%9e-double-fork&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Checkpoint 流程中的进程之舞 (double fork)
&lt;/h3&gt;&lt;p&gt;当用户通过 jcmd &amp;lt;pid&amp;gt; JDK.checkpoint 命令触发 CRaC 的 Checkpoint 时，一场精心编排的进程交互就开始了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;JVM 内部准备&lt;/strong&gt;: JVM 接收到命令后，会执行一些准备工作，比如触发一次 Full GC 来减小镜像体积，然后进入一个全局安全点（Safepoint），暂停所有 Java 线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动外部引擎&lt;/strong&gt;: JVM 调用 fork() 创建一个子进程 (我们称之为 P1)，这个子进程 P1 的任务是执行 criuengine checkpoint 命令。JVM 主进程则会暂停，等待 P1 的某种形式的完成信号或退出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;double fork 登场&lt;/strong&gt;: 这里的关键在于 criuengine (P1) 如何调用 criu dump 来冻结原始的 JVM 进程。如果 P1 直接调用 criu dump，那么 criu 进程就会是 JVM 的孙子进程，仍然属于同一个进程组，这在某些情况下可能导致问题（比如尝试冻结自己所在的进程组）。为了彻底解耦，criuengine 使用了 double fork 技巧：
&lt;ul&gt;
&lt;li&gt;P1 (criuengine checkpoint) 调用 fork() 创建子进程 P2。然后 P1 会等待 P2 退出。&lt;/li&gt;
&lt;li&gt;P2 &lt;strong&gt;再次&lt;/strong&gt;调用 fork() 创建孙子进程 P3。&lt;/li&gt;
&lt;li&gt;P2 &lt;strong&gt;立即退出&lt;/strong&gt; (exit())。&lt;/li&gt;
&lt;li&gt;P1 检测到 P2 退出后，P1 也退出。&lt;/li&gt;
&lt;li&gt;此时，P3 成为了&lt;strong&gt;孤儿进程&lt;/strong&gt;，其父进程被系统 init 进程（PID 1）接管。P3 现在与原始的 JVM 进程（它的“曾祖父”）在进程树上已经没有直接关系了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行冻结&lt;/strong&gt;: 成为孤儿的 P3 进程现在可以安全地执行 criu dump -t &amp;lt;jvm_pid&amp;gt; &amp;hellip; 命令，目标直指原始的、正在等待的 JVM 进程。criu 利用我们之前讨论的 /proc 和 ptrace 技术，将 JVM 的完整状态保存到镜像文件中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终结与等待&lt;/strong&gt;: criu dump 在成功创建镜像后，通常会&lt;strong&gt;杀死&lt;/strong&gt; (kill) 被冻结的原始 JVM 进程。而原始 JVM 进程在 fork 出 P1 后，实际上并没有完全阻塞，它会继续执行一小段代码，通常是进入一个 sigwaitinfo() 调用，等待一个特定的信号（RESTORE_SIGNAL），这个信号只有在未来的 Restore 过程中才会被发送。但在此之前，它就被 criu dump 结束了生命。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过 double fork，CRaC 巧妙地确保了执行冻结操作的 criu 进程独立于被冻结的 JVM 进程树之外，保证了 Checkpoint 操作的干净和可靠。&lt;/p&gt;
&lt;h3 id=&#34;restore-流程中的进程变身-execv-链&#34;&gt;
    &lt;a href=&#34;#restore-%e6%b5%81%e7%a8%8b%e4%b8%ad%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%8f%98%e8%ba%ab-execv-%e9%93%be&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Restore 流程中的进程“变身” (execv 链)
&lt;/h3&gt;&lt;p&gt;Restore 过程则展示了 execv 系统调用的威力，它允许一个进程用一个全新的程序映像替换自己，实现“原地变身”：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;启动 Restore 命令&lt;/strong&gt;: 用户执行 java -XX:CRaCRestoreFrom=&amp;lt;checkpoint_dir&amp;gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JVM 的“改道”&lt;/strong&gt;: 这个 Java 命令启动的 JVM 进程（我们称之为 P1）在非常早期的初始化阶段，就会检测到 -XX:CRaCRestoreFrom 参数。它&lt;strong&gt;不会&lt;/strong&gt;继续执行标准的 JVM 启动流程，而是立即“改道”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第一次变身 (execv)&lt;/strong&gt;: P1 调用 execv()，将其自身替换为 criuengine restore 程序。此时，原来的 java 进程 P1 不复存在，取而代之的是运行着 criuengine restore 代码的进程（我们称之为 P2，尽管 PID 可能与 P1 相同）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二次变身 (execv)&lt;/strong&gt;: P2 (criuengine restore) 负责解析参数，准备好调用 criu 所需的环境，然后再次调用 execv()，将自身替换为 criu restore 程序（我们称之为 P3）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRIU 执行恢复&lt;/strong&gt;: P3 (criu restore) 读取镜像文件，利用 fork、mmap、ptrace 等技术，在内存中逐步重建 JVM 进程的状态。这个恢复过程可能相当复杂，涉及创建新的进程（恢复后的 JVM），设置内存，恢复文件描述符，恢复线程等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唤醒与交接&lt;/strong&gt;: 在恢复的目标 JVM 进程状态基本就绪，但尚未开始执行用户代码时，P3 (criu restore) 会通过其配置的动作脚本（通常是 criuengine 自身）向恢复后的 JVM 进程发送一个特定的信号（如 RESTORE_SIGNAL），这个信号会唤醒 JVM 内部等待的代码（还记得 Checkpoint 最后 JVM 等待的 sigwaitinfo 吗？恢复后的 JVM 就从这里“醒来”）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三次变身 (execv)&lt;/strong&gt;: 在成功恢复 JVM 并发送唤醒信号后，P3 (criu restore) 进程的任务也即将结束。根据启动时通过 --exec-cmd 参数的指示，它会执行最后一次 execv()，将自身替换为 criuengine restorewait 程序（我们称之为 P4）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;守望者 (waitpid)&lt;/strong&gt;: P4 (criuengine restorewait) 的唯一使命就是扮演一个“守望者”。它知道刚刚恢复的 JVM 进程的 PID，然后调用 waitpid() 等待这个 JVM 进程结束。当 JVM 最终退出时，P4 会获取其退出状态，并以相同的状态退出。这样，最初启动 java -XX:CRaCRestoreFrom=&amp;hellip; 命令的用户就能得到恢复后 JVM 的最终执行结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这个 execv 调用链中，控制权被平滑地从初始的 Java 命令传递给 criuengine，再到 criu 本身，最后交接给负责等待的 criuengine restorewait。整个过程中，进程的身份（执行的程序）不断变化，但通常是在同一个进程 ID 下完成（除了 criu restore 内部重建 JVM 时会创建新进程），高效地利用了现有的进程上下文来执行不同的任务阶段。&lt;/p&gt;
&lt;p&gt;总结来说，CRaC 并非魔法，而是建立在对 Linux 进程生命周期管理的深刻理解和巧妙运用之上。它通过辅助程序，精确地编排 fork、execv、waitpid 等系统调用，指挥 CRIU 这位“底层大师”完成复杂的 Checkpoint 和 Restore 操作，最终实现了 Java 应用启动性能的巨大飞跃。&lt;/p&gt;
&lt;h2 id=&#34;总结linux-系统编程是-crac-的基石&#34;&gt;
    &lt;a href=&#34;#%e6%80%bb%e7%bb%93linux-%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e6%98%af-crac-%e7%9a%84%e5%9f%ba%e7%9f%b3&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    总结：Linux 系统编程是 CRaC 的基石
&lt;/h2&gt;&lt;p&gt;回顾全文，我们一起探索了 CRaC 技术背后所依赖的关键 Linux 系统编程概念。从基本的进程与线程模型、生命周期管理（fork, execv, waitpid, double fork），到强大的进程状态“透视镜” /proc 文件系统，再到能够精细控制进程的“遥控器”ptrace 系统调用，这些都是 Linux 提供的底层能力。&lt;/p&gt;
&lt;p&gt;我们看到，CRIU 正是巧妙地组合运用了这些机制，才得以在用户空间实现对运行中进程进行精确 Checkpoint 和 Restore 的复杂操作。而 CRaC 则更进一步，通过协调 JVM 内部状态和外部资源，并指挥 CRIU 完成核心的冻结与复苏任务，最终达成了大幅优化 Java 应用启动性能的目标。&lt;/p&gt;
&lt;p&gt;因此，理解这些 Linux 系统编程的知识，不仅能帮助我们揭开 CRaC 实现原理的神秘面纱，更能让我们体会到现代软件技术创新往往是建立在对底层系统深刻理解和创造性应用的基础之上。希望本文能为您打开一扇通往 Linux 系统编程世界的小窗，激发您进一步探索的兴趣。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CRaC 技术深度解析</title>
        <link>https://mazhen.tech/p/crac-%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
        <pubDate>Mon, 28 Apr 2025 16:56:24 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/crac-%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
        <description>&lt;h2 id=&#34;引言&#34;&gt;
    &lt;a href=&#34;#%e5%bc%95%e8%a8%80&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    引言
&lt;/h2&gt;&lt;p&gt;在现代软件架构中，尤其是在微服务和 &lt;code&gt;Serverless&lt;/code&gt; 计算领域，应用的快速启动和高效资源利用变得至关重要。Java 作为企业级应用开发的首选语言，尽管拥有庞大的生态和丰富的开发工具，但在启动速度方面始终面临挑战。与原生编译语言和部分脚本语言相比，Java 应用在启动过程中存在明显的性能差距。“冷启动”，即应用实例首次启动，或是从休眠状态唤醒时，系统需要经历复杂的初始化过程，这不仅会导致显著的时间延迟，还会引发资源消耗的峰值。&lt;/p&gt;
&lt;p&gt;那么，为什么 Java 应用的冷启动会比较慢呢？这并不仅仅是一个单一的步骤，而是涉及多个阶段，通常可以分为“&lt;strong&gt;JVM 启动&lt;/strong&gt;”、“&lt;strong&gt;应用启动&lt;/strong&gt;”和“&lt;strong&gt;应用预热&lt;/strong&gt;”三个主要过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;JVM 启动 (JVM Start - 相对较快):&lt;/strong&gt; 这个阶段主要是 Java 虚拟机（JVM）自身的初始化，包括加载核心库、初始化内存管理（如堆、垃圾收集器）、设置内部数据结构以及进行一些早期的基础优化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用启动 (Application Start - 需要一些时间):&lt;/strong&gt; 在 JVM 准备好之后，开始加载应用程序自身的类和所有依赖库。这是一个密集的过程，涉及查找、验证和解析大量的类。紧接着，应用框架（如 Spring Boot）会执行其初始化逻辑：扫描组件、解析配置、构建依赖注入容器、初始化线程池、建立数据库连接等。这个阶段完成后，应用通常可以处理第一个请求，因此这个阶段的耗时常被称为“&lt;strong&gt;首次响应时间（Time to first response）&lt;/strong&gt;”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用预热 (Application Warmup - 需要较长时间):&lt;/strong&gt; 即使应用能够响应第一个请求，它通常还远未达到最佳性能。Java 的高性能依赖于即时编译器 &lt;strong&gt;JIT&lt;/strong&gt;（Just-In-Time Compiler）。&lt;code&gt;JIT&lt;/code&gt; 会在运行时监控代码执行情况，识别“热点（hotspot）”代码（频繁执行的方法），并将其编译成本地机器码以提升效率。这个编译过程是分层的（例如，从解释执行到 C1 编译，再到更深层次优化的 C2 编译），需要时间和实际的业务负载来触发和完成。此外，还可能涉及缓存的填充、连接池的预热等。只有在 &lt;code&gt;JIT&lt;/code&gt; 完成了关键代码的编译优化，并且应用处理了一定量的请求后，才能达到其峰值性能。这个过程被称为“&lt;strong&gt;应用预热&lt;/strong&gt;”。期间还可能伴随着编译/反优化（Deoptimisations）和垃圾回收暂停（Garbage Collector pauses）带来的性能波动。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504241446155.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM PERFORMANCE GRAPH&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这三个阶段叠加起来，特别是“应用启动”和“应用预热”阶段的耗时，导致了 Java 应用的冷启动时间较长，并且需要一段时间才能达到理想的处理能力。对于需要快速响应和弹性伸缩的微服务和 Serverless 场景，这种延迟是亟待解决的痛点。缓慢的启动影响扩容效率，而漫长的预热则意味着在达到峰值性能前，应用的处理能力受限且响应时间不稳定。&lt;/p&gt;
&lt;p&gt;正是为了解决这一痛点，&lt;strong&gt;CRaC (Coordinated Restore at Checkpoint)&lt;/strong&gt; 技术应运而生。它并非逐一优化上述启动和预热的各个环节，而是另辟蹊径：&lt;strong&gt;通过在应用程序完成初始化并充分“预热”达到接近峰值性能状态后，创建一个包含整个 JVM 进程状态的“快照”（Checkpoint），并在需要新实例时直接从这个快照快速“恢复”（Restore）&lt;/strong&gt;。这种方式几乎完全绕过了耗时的“应用启动”和“应用预热”过程，有望将启动并达到高性能状态的时间缩短到毫秒级别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504241459599.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;MICROSERVICE ENVIRONMENT&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;本文旨在深入探讨 CRaC 技术，从其核心原理、与 AOT 等技术的对比、具体实现机制、实际使用方法，到其在不同场景下的应用和生态发展，全面解析这一旨在革新 Java 启动与预热性能的前沿技术。&lt;/p&gt;
&lt;h2 id=&#34;一crac-概述告别漫长等待&#34;&gt;
    &lt;a href=&#34;#%e4%b8%80crac-%e6%a6%82%e8%bf%b0%e5%91%8a%e5%88%ab%e6%bc%ab%e9%95%bf%e7%ad%89%e5%be%85&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    一、CRaC 概述：告别漫长等待
&lt;/h2&gt;&lt;h3 id=&#34;什么是-crac&#34;&gt;
    &lt;a href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af-crac&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    什么是 CRaC？
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://openjdk.org/projects/crac/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CRaC（Coordinated Restore at Checkpoint）&lt;/a&gt;是 OpenJDK 的一个项目，旨在通过创新的方式显著缩短 Java 应用的启动时间。CRaC  的核心思想是：在应用程序运行到某个理想状态（通常是初始化完成并经过预热后）时，创建一个包含整个 JVM 进程内存状态（包括堆内存、已加载类、已编译代码、线程状态等）的快照，即“检查点”（&lt;strong&gt;Checkpoint&lt;/strong&gt;），并将其持久化。当需要启动新实例时，不再执行传统的启动流程，而是直接从该快照“恢复”（&lt;strong&gt;Restore&lt;/strong&gt;）JVM 状态。这个恢复过程跳过了大部分 JVM 初始化、类加载和应用初始化步骤，从而极大地加快了启动速度。其中，“协调”（&lt;strong&gt;Coordinated&lt;/strong&gt;）是关键，意味着 JVM 需要与应用程序通过特定 API 进行交互，以确保在创建检查点和恢复时，外部资源（如文件句柄、网络连接）能够被妥善地关闭和重新建立。&lt;/p&gt;
&lt;h3 id=&#34;crac-的核心优势&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e6%a0%b8%e5%bf%83%e4%bc%98%e5%8a%bf&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的核心优势
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;极速启动：&lt;/strong&gt; 这是 CRaC 最显著的优势。传统 Java 应用启动可能需要数秒甚至数十秒，而使用 CRaC 从快照恢复，可以将启动时间缩短到数百毫秒甚至更短，接近原生应用的启动速度。因为它直接跳过了 JVM 初始化、类加载、应用初始化和大部分 JIT 预热等耗时环节。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;即时峰值性能：&lt;/strong&gt; 由于 &lt;strong&gt;Checkpoint&lt;/strong&gt; 通常是在应用已经完成 JIT 编译优化和预热后创建的，因此恢复后的实例几乎可以立即达到其最佳性能状态，避免了传统启动后漫长的“预热”等待期。这对于需要快速响应请求的场景（如 Serverless）尤其重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;潜在的资源节约：&lt;/strong&gt; 传统的启动和预热过程通常是 CPU 密集型的。通过 CRaC，这些密集的计算被转移到了 &lt;strong&gt;Checkpoint&lt;/strong&gt; 创建阶段（通常在非高峰时段或构建过程中完成），而在实际需要启动新实例时（如服务扩容或函数调用时），资源消耗显著降低，有助于提高资源利用率和降低成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;crac-的关键概念&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e5%85%b3%e9%94%ae%e6%a6%82%e5%bf%b5&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的关键概念
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Checkpoint (检查点):&lt;/strong&gt; 指创建 JVM 进程状态快照的操作，以及生成的包含该状态的持久化文件或镜像。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Restore (恢复):&lt;/strong&gt; 指从一个已存在的 &lt;strong&gt;Checkpoint&lt;/strong&gt; 快速加载 JVM 状态，启动一个新 JVM 实例的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Coordination (协调):&lt;/strong&gt; 指 JVM 与应用程序之间通过特定 API（&lt;code&gt;jdk.crac&lt;/code&gt; 包）进行的交互。应用程序需要实现接口来管理其资源（如关闭网络连接、文件句柄等）以确保 &lt;strong&gt;Checkpoint&lt;/strong&gt; 的一致性，并在 &lt;strong&gt;Restore&lt;/strong&gt; 后重新建立这些资源。这是保证恢复后的应用能正常工作的关键。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二crac-vs-aot启动优化的两条路径&#34;&gt;
    &lt;a href=&#34;#%e4%ba%8ccrac-vs-aot%e5%90%af%e5%8a%a8%e4%bc%98%e5%8c%96%e7%9a%84%e4%b8%a4%e6%9d%a1%e8%b7%af%e5%be%84&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    二、CRaC vs. AOT：启动优化的两条路径
&lt;/h2&gt;&lt;p&gt;为了解决 Java 启动慢和预热长的问题，业界探索了不同的优化路径。除了 &lt;strong&gt;CRaC&lt;/strong&gt;，另一种广受关注的技术是 &lt;strong&gt;AOT&lt;/strong&gt;（Ahead-of-Time）编译，特别是以 &lt;strong&gt;GraalVM Native Image&lt;/strong&gt; 为代表的实现。两者都旨在缩短启动时间，但它们的原理和特性却大相径庭。&lt;/p&gt;
&lt;h3 id=&#34;aot-技术简介&#34;&gt;
    &lt;a href=&#34;#aot-%e6%8a%80%e6%9c%af%e7%ae%80%e4%bb%8b&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    AOT 技术简介
&lt;/h3&gt;&lt;p&gt;AOT 编译的核心思想是，在应用程序运行之前，就将其 Java 字节码直接编译成本地机器码，生成一个独立的可执行文件（例如 GraalVM Native Image）。这样做带来的主要优势是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无需解释字节码 (No interpreting bytecodes):&lt;/strong&gt; 启动时直接执行本地代码，跳过了 JVM 解释执行字节码的阶段。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无需运行时编译 (No runtime compilation of code):&lt;/strong&gt; 消除了 JIT 在运行时编译代码带来的 CPU 开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动即全速 (Start at &amp;lsquo;full speed&amp;rsquo;, straight away):&lt;/strong&gt; 应用启动后几乎立刻就能达到其稳定性能状态（尽管这个稳定状态可能不是最高峰值），大大缩短了“首次响应时间”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更小的内存占用：&lt;/strong&gt; 生成的本地可执行文件不包含 JVM 和 JIT 编译器，运行时内存占用通常显著低于标准 JVM。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aot-的挑战与局限&#34;&gt;
    &lt;a href=&#34;#aot-%e7%9a%84%e6%8c%91%e6%88%98%e4%b8%8e%e5%b1%80%e9%99%90&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    AOT 的挑战与局限
&lt;/h3&gt;&lt;p&gt;然而，AOT 并非完美无缺，它也面临一些固有的挑战：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态编译的本质 (AOT is, by definition, static)&lt;/strong&gt;
&lt;strong&gt;AOT&lt;/strong&gt; 的本质是代码在运行&lt;strong&gt;之前&lt;/strong&gt;就被编译。这意味着编译器&lt;strong&gt;无法获知代码在运行时的实际行为&lt;/strong&gt; 。&lt;strong&gt;AOT&lt;/strong&gt; 不能像 &lt;strong&gt;JIT&lt;/strong&gt; 那样根据运行时的真实负载和代码路径进行深度优化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Profile Guided Optimization (PGO) 的引入与局限&lt;/strong&gt;
为了缓解静态编译缺乏运行时信息的缺点，&lt;strong&gt;AOT&lt;/strong&gt; 可以结合 &lt;strong&gt;Profile Guided Optimization (PGO)&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;PGO&lt;/strong&gt; 的基本思路是：先通过插桩（Instrumentation）或者采样的方式运行一次程序，收集代码执行频率、分支跳转等信息，生成 Profile 数据（例如 GCC 中使用 &lt;code&gt;-fprofile-generate&lt;/code&gt; 编译运行以生成 profile 文件）；然后，在最终编译时将这些 Profile 数据提供给编译器（例如 GCC 使用 &lt;code&gt;-fprofile-use&lt;/code&gt;），让编译器根据这些“先验知识”进行更针对性的优化，比如更好地安排代码布局、更准确地进行分支预测、更有效地进行函数内联等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而，对于 AOT 编译来说，PGO 只能部分缓解问题 (can partially help)&lt;/strong&gt;。因为收集到的 Profile 数据可能只代表了某一次或某几次运行的特征，无法完全覆盖所有可能的运行时场景和输入数据。因此，基于 &lt;strong&gt;PGO&lt;/strong&gt; 的 &lt;strong&gt;AOT&lt;/strong&gt; 优化效果通常仍&lt;strong&gt;难以媲美 JIT&lt;/strong&gt; 的动态优化能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504241551875.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM PERFORMANCE GRAPH&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;兼容性问题&lt;/strong&gt;
&lt;strong&gt;AOT&lt;/strong&gt; 对 Java 的动态特性（如反射、动态代理、运行时字节码生成）支持有限，通常需要额外的配置或代码调整，并非所有 Java 库都能直接兼容。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;jit-的优势运行时动态优化的威力&#34;&gt;
    &lt;a href=&#34;#jit-%e7%9a%84%e4%bc%98%e5%8a%bf%e8%bf%90%e8%a1%8c%e6%97%b6%e5%8a%a8%e6%80%81%e4%bc%98%e5%8c%96%e7%9a%84%e5%a8%81%e5%8a%9b&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    JIT 的优势：运行时动态优化的威力
&lt;/h3&gt;&lt;p&gt;与 &lt;strong&gt;AOT&lt;/strong&gt; 的静态编译不同，&lt;strong&gt;JIT&lt;/strong&gt; 编译是在程序运行期间进行的。这赋予了 &lt;strong&gt;JIT&lt;/strong&gt; 编译器独特的优势，使其能够进行比 &lt;strong&gt;AOT&lt;/strong&gt; 更深层次、更精准的优化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基于真实运行情况的优化：&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 编译器可以观察到代码&lt;strong&gt;实际&lt;/strong&gt;的运行路径、热点方法、分支跳转频率、数据类型分布等信息。基于这些&lt;strong&gt;动态收集&lt;/strong&gt;的信息，&lt;strong&gt;JIT&lt;/strong&gt; 可以做出更明智的优化决策。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;激进的优化策略：&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 可以采用更激进的优化手段，例如：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法内联 (Method Inlining):&lt;/strong&gt; 将调用频繁的小方法直接嵌入到调用处，消除方法调用的开销。JIT 可以根据实际调用情况决定是否内联以及内联的深度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逃逸分析 (Escape Analysis):&lt;/strong&gt; 分析对象的作用域，如果一个对象只在方法内部使用，不会“逃逸”出去，JIT 可以将其分配在栈上而不是堆上，减轻 GC 压力，甚至进行锁消除。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;投机性优化 (Speculative Optimizations):&lt;/strong&gt; JIT 可以根据观察到的高概率事件进行优化（例如，假设某个类型检查总是成功），并准备好在假设失败时回退到较慢的代码路径（Deoptimization）。&lt;strong&gt;AOT&lt;/strong&gt; 通常无法承担这种风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;针对特定环境的优化：&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 编译器知道程序&lt;strong&gt;当前运行&lt;/strong&gt;的 CPU 架构（例如 Haswell, Skylake, Ice Lake 等），可以生成针对该特定 CPU 指令集优化的机器码，最大化硬件性能。&lt;strong&gt;AOT&lt;/strong&gt; 为了通用性，通常只能编译为“最小公分母”的指令集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持 Java 动态特性：&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 天然与 Java 的动态特性（如反射、运行时字节码生成）协同工作，这些特性对于 &lt;strong&gt;AOT&lt;/strong&gt; 来说往往是难点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正是由于这些基于运行时信息的动态优化能力，经过充分预热的 &lt;strong&gt;JIT&lt;/strong&gt; 代码通常能够达到比 &lt;strong&gt;AOT&lt;/strong&gt; 代码&lt;strong&gt;更高的峰值性能&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;jit-的主要缺点&#34;&gt;
    &lt;a href=&#34;#jit-%e7%9a%84%e4%b8%bb%e8%a6%81%e7%bc%ba%e7%82%b9&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    JIT 的主要缺点
&lt;/h3&gt;&lt;p&gt;尽管 &lt;strong&gt;JIT&lt;/strong&gt; 在峰值性能上有优势，但其缺点也显而易见，这正是 &lt;strong&gt;AOT&lt;/strong&gt; 试图解决的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;启动时间长 (Requires more time to start up):&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 需要经历 JVM 启动、类加载、解释执行、热点分析、代码编译等多个慢速操作后，才能达到较快的执行速度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行时编译开销 (CPU overhead to compile code at runtime):&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 编译本身需要消耗 CPU 资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存占用大 (Larger memory footprint):&lt;/strong&gt; JVM、JIT 编译器、性能分析数据等都需要占用额外的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aot-vs-jit-对比总结&#34;&gt;
    &lt;a href=&#34;#aot-vs-jit-%e5%af%b9%e6%af%94%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    AOT vs. JIT 对比总结
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;特性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;AOT (Ahead-of-Time)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;JIT (Just-In-Time)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;编译时机&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;运行前 (静态)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;运行时 (动态)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;启动速度&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;快 (Time to first response 短)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;慢 (需要 JVM 初始化、类加载、解释执行)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;预热时间&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;短 (几乎无预热)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;长 (需要识别热点、分层编译优化)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;峰值性能&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;通常较低 (缺乏运行时信息和动态优化)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;通常较高 (可进行激进优化、针对性优化)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;内存占用&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;小&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;大 (包含 JVM、JIT 编译器、分析数据等)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;动态特性支持&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有限 (需配置或改造)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;良好 (Java 核心优势之一)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;运行时开销&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;低 (无编译开销)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有 (编译 CPU 开销)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;兼容性&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;挑战较大&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;好&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;优化依据&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;静态分析 (+ 有限的 PGO)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;运行时真实行为&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;crac-的切入点&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e5%88%87%e5%85%a5%e7%82%b9&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的切入点
&lt;/h3&gt;&lt;p&gt;理解了 &lt;strong&gt;AOT&lt;/strong&gt; 和 &lt;strong&gt;JIT&lt;/strong&gt; 各自的优劣后，&lt;strong&gt;CRaC&lt;/strong&gt; 的价值就更加清晰了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CRaC&lt;/strong&gt; 试图结合两者的优点，规避其缺点：它保留了 &lt;strong&gt;JIT&lt;/strong&gt; 带来的峰值性能优势（因为 &lt;strong&gt;Checkpoint&lt;/strong&gt; 是在 &lt;strong&gt;JIT&lt;/strong&gt; 充分预热后创建的），同时通过状态恢复的方式，避免了 &lt;strong&gt;JIT&lt;/strong&gt; 漫长的启动和预热过程，实现了类似 &lt;strong&gt;AOT&lt;/strong&gt; 的快速启动（特别是达到峰值性能的速度）。与 &lt;strong&gt;AOT&lt;/strong&gt; 相比，&lt;strong&gt;CRaC&lt;/strong&gt; 对 Java 动态特性的兼容性更好。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;CRaC&lt;/strong&gt;、&lt;strong&gt;AOT&lt;/strong&gt; 和传统的 &lt;strong&gt;JIT&lt;/strong&gt; 代表了 Java 性能优化的不同策略，适用于不同的场景和需求。&lt;/p&gt;
&lt;h2 id=&#34;三实现原理深入-crac-的心脏&#34;&gt;
    &lt;a href=&#34;#%e4%b8%89%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e6%b7%b1%e5%85%a5-crac-%e7%9a%84%e5%bf%83%e8%84%8f&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    三、实现原理：深入 CRaC 的心脏
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;CRaC&lt;/strong&gt; 技术并非空中楼阁，它的实现依赖于一个强大的 Linux 工具：&lt;a class=&#34;link&#34; href=&#34;https://criu.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CRIU&lt;/a&gt;。虽然 CRIU 是一个运行在用户空间的程序，但它的核心能力建立在 Linux 内核提供的丰富特性和接口之上。理解 &lt;strong&gt;CRIU&lt;/strong&gt; 的工作原理对于深入掌握 &lt;strong&gt;CRaC&lt;/strong&gt; 至关重要。&lt;/p&gt;
&lt;h3 id=&#34;基石criu&#34;&gt;
    &lt;a href=&#34;#%e5%9f%ba%e7%9f%b3criu&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    基石：CRIU
&lt;/h3&gt;&lt;p&gt;CRIU  (Checkpoint/Restore In Userspace) 是一个 Linux 用户空间的工具，它允许你“冻结”（&lt;strong&gt;Checkpoint&lt;/strong&gt;）一个正在运行的应用程序（或一组应用程序），将其状态保存到磁盘文件中，然后在未来的某个时刻从这些文件中“解冻”（&lt;strong&gt;Restore&lt;/strong&gt;）它。被恢复的应用程序将从被冻结的那个精确时刻继续运行，仿佛什么都没有发生过一样。&lt;strong&gt;CRIU&lt;/strong&gt; 的核心能力是保存和恢复进程的各种资源状态。&lt;/p&gt;
&lt;h4 id=&#34;checkpoint-过程详解&#34;&gt;
    &lt;a href=&#34;#checkpoint-%e8%bf%87%e7%a8%8b%e8%af%a6%e8%a7%a3&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Checkpoint 过程详解
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504251743057.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Checkpoint&#34;
	
	
&gt;
&lt;strong&gt;Checkpoint&lt;/strong&gt; 阶段会执行以下步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;收集进程树并冻结&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CRIU 首先需要确定要 &lt;strong&gt;Checkpoint&lt;/strong&gt; 的目标进程及其所有子进程和线程，构成一个完整的进程树。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc&lt;/code&gt; 是一个虚拟文件系统，它并不存在于磁盘上，而是由 Linux 内核动态生成，用来提供有关系统状态和正在运行的进程的信息。对于每个正在运行的进程，&lt;code&gt;/proc&lt;/code&gt; 下都有一个以该进程的 PID（Process ID）命名的目录。&lt;/p&gt;
&lt;p&gt;在一个进程内部，可能有一个或多个线程。在 Linux 内核看来，线程本质上也是一种“任务”（Task），它们共享同一个地址空间和其他资源，但有自己独立的执行流和调度标识符（TID, Thread ID）。&lt;code&gt;/proc/$pid/task/&lt;/code&gt; 这个目录就包含了该进程（PID 为 &lt;code&gt;$pid&lt;/code&gt;）下的所有线程（任务）的信息。该目录下会为每个线程创建一个子目录，目录名就是该线程的 TID。&lt;/p&gt;
&lt;p&gt;通过读取 &lt;code&gt;/proc/$pid/task/&lt;/code&gt; 目录的内容，CRIU 可以识别出属于进程 &lt;code&gt;$pid&lt;/code&gt; 的所有线程（包括主线程和其他子线程），获取它们的 TID 列表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc/$pid/task/$tid/children&lt;/code&gt; 文件位于特定线程的目录下，记录了由 &lt;em&gt;这个特定线程&lt;/em&gt;（PID 为 &lt;code&gt;$pid&lt;/code&gt;，TID 为 &lt;code&gt;$tid&lt;/code&gt;）&lt;strong&gt;直接创建&lt;/strong&gt; 的所有子进程的 PID 列表。子进程是由 &lt;code&gt;fork()&lt;/code&gt; 或 &lt;code&gt;clone()&lt;/code&gt; 系统调用创建的。这个 &lt;code&gt;children&lt;/code&gt; 文件告诉我们，从这个线程出发，诞生了哪些新的进程。&lt;/p&gt;
&lt;p&gt;CRIU 从 &lt;code&gt;--tree&lt;/code&gt; 选项指定的那个初始 PID 开始，首先通过 &lt;code&gt;/proc/$pid/task/&lt;/code&gt; 找到一个进程的所有线程，然后通过 &lt;code&gt;/proc/$pid/task/$tid/children&lt;/code&gt; 找到每个线程创建的子进程，再对这些子进程重复同样的操作，一层层深入下去，最终像剥洋葱一样把整个进程家族（包括所有进程和线程）都识别出来。&lt;/p&gt;
&lt;p&gt;在遍历过程中，CRIU 使用 &lt;code&gt;ptrace&lt;/code&gt; 系统调用，命令为 &lt;code&gt;PTRACE_SEIZE&lt;/code&gt;，来附加（attach）到目标进程树中的每个任务（进程/线程）上，并将它们&lt;strong&gt;暂停&lt;/strong&gt;下来。&lt;/p&gt;
&lt;p&gt;传统的 &lt;code&gt;PTRACE_ATTACH&lt;/code&gt; 依赖信号机制，&lt;code&gt;PTRACE_ATTACH&lt;/code&gt; 会向目标进程发送 &lt;code&gt;SIGSTOP&lt;/code&gt;，&lt;code&gt;SIGSTOP&lt;/code&gt; 信号需要被目标进程的信号处理程序处理，然后进程才停止。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PTRACE_SEIZE&lt;/code&gt; 则不同，它&lt;strong&gt;不依赖用户空间的信号传递来让目标进程停止&lt;/strong&gt;，是内核层面的一个直接操作。当调用 &lt;code&gt;ptrace(PTRACE_SEIZE, tid, ...)&lt;/code&gt; 时，内核会标记目标任务（线程 tid）进入 &lt;code&gt;ptrace-stop&lt;/code&gt; 状态，这个任务会在&lt;strong&gt;下一次内核有机会介入任务执行流的时候&lt;/strong&gt;暂停。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;收集任务资源并转储&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进程树被冻结后，CRIU 开始收集每个任务的详细信息，并将这些信息写入镜像文件（dump files）。这些信息主要来源于 &lt;code&gt;/proc&lt;/code&gt; 文件系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存映射 (Memory maps)&lt;/strong&gt;
CRIU 通过解析 &lt;code&gt;/proc/$pid/maps&lt;/code&gt; 和 &lt;code&gt;/proc/$pid/smaps&lt;/code&gt; 获取虚拟内存区域（&lt;strong&gt;VMA&lt;/strong&gt;）的布局信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;/proc/$pid/maps&lt;/code&gt; 列出了当前进程 ($pid) &lt;strong&gt;所有内存映射区域（Virtual Memory Areas - VMA）&lt;/strong&gt; 的详细信息，每一行代表一个连续的虚拟内存区域，通常包含以下字段，用空格分隔：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;起始地址-结束地址   权限    偏移量   设备号&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;主:次&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;  inode  路径名
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果是&lt;strong&gt;文件映射&lt;/strong&gt;，&lt;strong&gt;设备号&lt;/strong&gt;表示文件所在的设备，&lt;strong&gt;inode&lt;/strong&gt; 表示文件的 &lt;code&gt;inode&lt;/code&gt; 编号，&lt;strong&gt;路径名&lt;/strong&gt;会显示被映射文件的&lt;strong&gt;路径&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;匿名映射&lt;/strong&gt;，即没有关联具体文件，如 malloc 分配的内存、进程的堆、栈等，&lt;strong&gt;inode&lt;/strong&gt; 值为 0，&lt;strong&gt;路径名&lt;/strong&gt;通常为空，或者显示一些特殊标记，如 &lt;code&gt;[heap]&lt;/code&gt; 表示进程的堆内存区域，&lt;code&gt;[stack]&lt;/code&gt;表示进程的主线程栈区域。&lt;/p&gt;
&lt;p&gt;例如查看应用服务器进程的 &lt;code&gt;maps&lt;/code&gt; 文件内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$cat&lt;/span&gt; /proc/10854/maps
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5b565de16000-5b565de17000 rw-p &lt;span class=&#34;m&#34;&gt;00003000&lt;/span&gt; 103:02 &lt;span class=&#34;m&#34;&gt;34101432&lt;/span&gt;                  /home/mazhen/works/jdk-21.0.6/jdk/bin/java
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5b5683910000-5b5683958000 rw-p &lt;span class=&#34;m&#34;&gt;00000000&lt;/span&gt; 00:00 &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;                          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;heap&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7f95a4000000-7f95a4028000 r--p &lt;span class=&#34;m&#34;&gt;00000000&lt;/span&gt; 103:02 58869401                  /usr/lib/x86_64-linux-gnu/libc.so.6
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7fff8da95000-7fff8dab7000 rw-p &lt;span class=&#34;m&#34;&gt;00000000&lt;/span&gt; 00:00 0                          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;stack&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;/proc/$pid/maps&lt;/code&gt; 是 CRIU 理解进程&lt;strong&gt;内存布局&lt;/strong&gt;的核心依据，而 &lt;code&gt;/proc/$pid/smaps&lt;/code&gt; 是 &lt;code&gt;/proc/$pid/maps&lt;/code&gt; 的一个&lt;strong&gt;扩展版本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc/$pid/smaps&lt;/code&gt;为每一个内存映射区域（&lt;strong&gt;VMA&lt;/strong&gt;）提供了更详细的内存占用统计信息（物理内存占用、共享/私有、干净/脏、匿名、交换、锁定等），以及重要的内核内部标志 (VmFlags)。&lt;code&gt;smaps&lt;/code&gt; 由多个&lt;strong&gt;块 (block)&lt;/strong&gt; 组成，每个块对应 &lt;code&gt;/proc/$pid/maps&lt;/code&gt; 文件中的一行（即一个 &lt;strong&gt;VMA&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;还是以应用服务器进程为例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$cat&lt;/span&gt; /proc/10854/smaps
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5b5683910000-5b5683958000 rw-p &lt;span class=&#34;m&#34;&gt;00000000&lt;/span&gt; 00:00 &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;                          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;heap&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Size:                &lt;span class=&#34;m&#34;&gt;288&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;KernelPageSize:        &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;MMUPageSize:           &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Rss:                  &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Pss:                  &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Pss_Dirty:            &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Shared_Clean:          &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Shared_Dirty:          &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Private_Clean:         &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Private_Dirty:        &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Referenced:           &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Anonymous:            &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;KSM:                   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;LazyFree:              &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;AnonHugePages:         &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ShmemPmdMapped:        &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;FilePmdMapped:         &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Shared_Hugetlb:        &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Private_Hugetlb:       &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Swap:                  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SwapPss:               &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Locked:                &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;THPeligible:           &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ProtectionKey:         &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;VmFlags: rd wr mr mw me ac sd 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存映射文件（mapped files）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;/proc/$pid/map_files/&lt;/code&gt; 是一个&lt;strong&gt;目录&lt;/strong&gt;，这个目录包含了&lt;strong&gt;指向实际被映射文件的符号链接 (symbolic links)&lt;/strong&gt;。目录中的每个符号链接的&lt;strong&gt;名称&lt;/strong&gt;对应于 &lt;code&gt;/proc/$pid/maps&lt;/code&gt; 文件中列出的一个&lt;strong&gt;内存区域的地址范围&lt;/strong&gt; (格式为 起始地址 - 结束地址)。&lt;/p&gt;
&lt;p&gt;CRIU 通过 &lt;code&gt;/proc/$pid/map_files/&lt;/code&gt; 获取文件映射区域&lt;strong&gt;底层文件对象的直接链接&lt;/strong&gt;，主要用于&lt;strong&gt;可靠地访问和读取&lt;/strong&gt;这些文件映射区域的内容。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ls -l /proc/10854/map_files   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;total &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lr-------- &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 06:58 5b565de12000-5b565de13000 -&amp;gt; /home/mazhen/works/jdk-21.0.6/jdk/bin/java
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lr-------- &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 06:58 7f95a4000000-7f95a4028000 -&amp;gt; /usr/lib/x86_64-linux-gnu/libc.so.6
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件描述符 (File descriptors)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CRIU 通过读取 &lt;code&gt;/proc/$pid/fd&lt;/code&gt; 和 &lt;code&gt;/proc/$pid/fdinfo&lt;/code&gt; 获取进程打开的文件、管道、套接字等信息。CRIU 能够处理各种类型的文件描述符，包括常规文件、管道、Unix 套接字、TCP 套接字（甚至包括处于 ESTABLISHED 状态的连接）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc/$pid/fd&lt;/code&gt;是一个&lt;strong&gt;目录&lt;/strong&gt;，它包含&lt;strong&gt;符号链接&lt;/strong&gt;，每个符号链接的名称对应一个已打开的&lt;strong&gt;文件描述符编号&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ls -l /proc/10854/fd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;l-wx------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 02:00 &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; -&amp;gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;pipe:[195498]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lr-x------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 02:00 &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; -&amp;gt; /home/mazhen/works/jdk-21.0.6/jdk/lib/modules
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:21 &lt;span class=&#34;m&#34;&gt;379&lt;/span&gt; -&amp;gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;socket:[2629]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:21 &lt;span class=&#34;m&#34;&gt;380&lt;/span&gt; -&amp;gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;socket:[2636]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:21 &lt;span class=&#34;m&#34;&gt;477&lt;/span&gt; -&amp;gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;anon_inode:[eventpoll]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:21 &lt;span class=&#34;m&#34;&gt;478&lt;/span&gt; -&amp;gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;anon_inode:[eventfd]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lr-x------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:21 &lt;span class=&#34;m&#34;&gt;479&lt;/span&gt; -&amp;gt; anon_inode:inotify
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;/proc/$pid/fdinfo&lt;/code&gt;也是一个&lt;strong&gt;目录&lt;/strong&gt;，它包含&lt;strong&gt;普通文件&lt;/strong&gt;（不是符号链接），每个文件的名称对应一个已打开的&lt;strong&gt;文件描述符编号&lt;/strong&gt;。每个文件（例如&lt;code&gt;/proc/$pid/fdinfo/1&lt;/code&gt;）包含关于相应文件描述符的&lt;strong&gt;元数据和状态信息&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ls -l /proc/10854/fdinfo 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;total &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-r--r--r-- &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:31 &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-r--r--r-- &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:31 &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-r--r--r-- &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:31 &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat /proc/10854/fdinfo/20
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pos:	&lt;span class=&#34;m&#34;&gt;381&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;flags:	&lt;span class=&#34;m&#34;&gt;0100000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mnt_id:	&lt;span class=&#34;m&#34;&gt;31&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ino:	&lt;span class=&#34;m&#34;&gt;32775204&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;/proc/$pid/fd&lt;/code&gt;告诉 CRIU 通过哪些描述符编号打开了&lt;strong&gt;哪些&lt;/strong&gt;资源，&lt;code&gt;/proc/$pid/fdinfo&lt;/code&gt;告诉 CRIU 每个已打开描述符的&lt;strong&gt;状态和元数据&lt;/strong&gt;（比如位置和标志）。CRIU 使用来自这两个位置的信息来完整保存进程已打开文件及其状态的情况，以便之后能够准确地恢复它们。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心运行参数 (Core parameters)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了保存一个任务（进程/线程）的核心运行状态以便后续恢复，CRIU 主要结合使用了两种方法。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ptrace&lt;/code&gt; 系统调用的特定命令（例如&lt;code&gt;PTRACE_GETREGS&lt;/code&gt; 或 &lt;code&gt;PTRACE_GETFPREGS&lt;/code&gt; ）来&lt;strong&gt;直接读取&lt;/strong&gt;任务暂停时的&lt;strong&gt;CPU 寄存器 (registers)&lt;/strong&gt; 内容，包括通用寄存器、指令指针、标志寄存器、浮点寄存器等），以及其他密切相关的底层执行状态信息。&lt;/p&gt;
&lt;p&gt;通过读取和解析 &lt;code&gt;/proc/$pid/stat&lt;/code&gt; 文件，获取关于任务的&lt;strong&gt;各种状态参数和统计数据&lt;/strong&gt;。&lt;code&gt;/proc/$pid/stat&lt;/code&gt; 以&lt;strong&gt;单行文本&lt;/strong&gt;的形式提供了关于进程的大量&lt;strong&gt;状态信息 (status information)&lt;/strong&gt;，其中的信息由&lt;strong&gt;空格&lt;/strong&gt;分隔，每个字段代表一个特定的进程属性或统计值。下面列出一些最核心和常用的字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可执行文件名 (comm)&lt;/li&gt;
&lt;li&gt;进程状态 (state)&lt;/li&gt;
&lt;li&gt;父进程 ID (ppid)&lt;/li&gt;
&lt;li&gt;进程组 ID (pgrp)&lt;/li&gt;
&lt;li&gt;会话 ID (session)&lt;/li&gt;
&lt;li&gt;调度优先级和 nice 值 (priority, nice)&lt;/li&gt;
&lt;li&gt;虚拟内存大小 (vsize)&lt;/li&gt;
&lt;li&gt;常驻集大小 (rss)&lt;/li&gt;
&lt;li&gt;进程启动时间 (starttime)&lt;/li&gt;
&lt;li&gt;等待子进程的 CPU 时间 (cutime, cstime)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;注入寄生代码（Parasite Code）并转储内存&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了获取某些无法从外部直接探测的信息（例如进程凭证、精确的内存布局和内容），CRIU 必须在目标进程的地址空间内部执行特定的代码。这正是通过 &lt;strong&gt;寄生代码 (Parasite Code)&lt;/strong&gt; 技术实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寄生代码&lt;/strong&gt;是一段精心构造的小型二进制程序，它以&lt;strong&gt;位置无关可执行文件 (PIE, Position-Independent Executable)&lt;/strong&gt; 格式编译。这一特性至关重要，因为它允许 CRIU 将这段代码加载到目标进程地址空间中的&lt;strong&gt;任何可用位置&lt;/strong&gt;，而无需担心因硬编码地址引发的冲突。该代码通常包含两部分：一小段依赖于具体处理器架构（如 x86, ARM）的汇编&lt;strong&gt;引导程序 (bootstrap)&lt;/strong&gt;，以及一段用 C 语言编写、负责处理命令的通用&lt;strong&gt;核心逻辑 (daemon)&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504251748420.png&#34; alt=&#34;Parasite Code&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;p&gt;要在目标进程中运行，&lt;strong&gt;寄生代码&lt;/strong&gt;需要自己的内存空间来存放其代码、运行栈以及用于和 CRIU 进行通信的参数区域。由于 CRIU 不能直接操作目标进程的内存分配，它巧妙地利用了 &lt;code&gt;ptrace&lt;/code&gt; 机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;准备内存空间&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CRIU 首先使用 &lt;code&gt;ptrace&lt;/code&gt; 控制目标进程，并&lt;strong&gt;保存其当前的寄存器状态&lt;/strong&gt;（尤其是指令指针 CS:IP 和栈指针）。&lt;/li&gt;
&lt;li&gt;接着，CRIU 修改目标进程的寄存器，填入执行 &lt;code&gt;mmap&lt;/code&gt; 系统调用所需的编号和参数。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;ptrace(PTRACE_SYSCALL,...)&lt;/code&gt;，&lt;strong&gt;强制目标进程执行这个 mmap 调用&lt;/strong&gt;。这会在目标进程的地址空间中分配一块&lt;strong&gt;共享内存区域&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注入并执行寄生代码&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CRIU 使用 &lt;code&gt;ptrace(PTRACE_POKEDATA, ...)&lt;/code&gt; ，将预先编译好的完整&lt;strong&gt;寄生代码&lt;/strong&gt;二进制数据写入到刚刚分配的共享内存区域中。&lt;/li&gt;
&lt;li&gt;CRIU 再次使用 &lt;code&gt;ptrace&lt;/code&gt; 修改目标进程的寄存器，将&lt;strong&gt;指令指针 (IP/PC)&lt;/strong&gt; 指向共享内存中&lt;strong&gt;寄生代码&lt;/strong&gt;的入口点。&lt;/li&gt;
&lt;li&gt;CRIU 命令目标进程恢复执行 &lt;code&gt;ptrace(PTRACE_CONT, ...)&lt;/code&gt;。此时，目标进程便开始执行被注入的&lt;strong&gt;寄生代码&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;寄生代码&lt;/strong&gt;运行在目标进程的上下文中，因此拥有访问该进程所有资源的权限。它可以执行 CRIU 指派的各种任务，例如读取和转储私有内存页、收集文件描述符的详细状态等。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;清理 (Cleanup)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当所有需要通过寄生代码完成的任务结束后，必须将其彻底移除，并将目标进程恢复到之前的状态，仿佛从未被打扰过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;寄生代码退出&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CRIU 通过共享内存或专用通信通道向寄生代码发送一个结束命令 (&lt;code&gt;PARASITE_CMD_FINI&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄生代码&lt;/strong&gt;收到命令后，执行必要的清理操作，然后调用 &lt;code&gt;rt_sigreturn()&lt;/code&gt; 系统调用。此系统调用会利用 CRIU 事先准备好的信息，&lt;strong&gt;恢复目标进程在寄生代码注入前一刻的寄存器状态&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRIU 清理环境&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CRIU 通过 &lt;code&gt;ptrace&lt;/code&gt; 监视系统调用，并拦截 &lt;code&gt;rt_sigreturn()&lt;/code&gt; 的退出。&lt;/li&gt;
&lt;li&gt;在目标进程寄存器已恢复、但寄生代码的内存区域还在的短暂时刻，CRIU 再次利用 &lt;code&gt;ptrace&lt;/code&gt; &lt;strong&gt;强制目标进程执行 munmap 系统调用&lt;/strong&gt;，将之前为寄生代码分配的共享内存区域解除映射，彻底抹除其痕迹。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复正常运行&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;最后，CRIU 调用 &lt;code&gt;ptrace(PTRACE_DETACH, ...)&lt;/code&gt; 从目标进程分离。&lt;/li&gt;
&lt;li&gt;目标进程从其原始被中断的指令处（由恢复的寄存器状态决定）继续执行，整个进程树恢复运行，&lt;strong&gt;Checkpoint&lt;/strong&gt; 操作完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;restore-过程详解&#34;&gt;
    &lt;a href=&#34;#restore-%e8%bf%87%e7%a8%8b%e8%af%a6%e8%a7%a3&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Restore 过程详解
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504270949861.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Restore&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restore (恢复)&lt;/strong&gt; 过程可以看作是 &lt;strong&gt;Checkpoint&lt;/strong&gt; (检查点) 的逆向操作。在这个过程中，执行恢复命令的 CRIU 进程会经历一系列精心设计的步骤，最终“变形”成为检查点时刻被冻结的目标进程（或进程树），并从那一刻继续运行。整个过程大致分为以下四个主要阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;解析共享资源&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CRIU 首先读取检查点生成的镜像文件，分析进程间的依赖关系。它会找出哪些资源实例（例如：同一个会话 ID、同一个打开的文件描述符指向的内核文件对象、同一块共享内存区域等）是被多个进程共同使用的。&lt;/p&gt;
&lt;p&gt;识别出这些共享资源后，CRIU 会标记它们，并确定恢复策略。某些资源会通过&lt;strong&gt;继承&lt;/strong&gt;（如会话 ID，在 fork() 时由子进程自然获得），其他的则需要更复杂的机制，比如利用 &lt;strong&gt;Unix domain socket&lt;/strong&gt; 和 &lt;strong&gt;SCM_RIGHTS 消息&lt;/strong&gt; 在进程间传递文件描述符，或者使用 &lt;strong&gt;memfd&lt;/strong&gt; 等技术来重建共享内存区域。这一步是为了确保在后续阶段，这些共享资源能被正确地创建一次，并被所有相关的进程共享，而不是各自创建独立的实例。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;创建进程树&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CRIU 严格按照镜像文件中记录的父子关系，通过多次调用 &lt;code&gt;fork()&lt;/code&gt; 系统调用来重新创建原始的进程树。每个 &lt;code&gt;fork()&lt;/code&gt; 都会产生一个新的进程，其父进程是之前已恢复的对应父进程。&lt;/p&gt;
&lt;p&gt;注意，在这个阶段，&lt;strong&gt;只创建进程的主线程&lt;/strong&gt;。目标进程的所有其他线程的恢复会被&lt;strong&gt;推迟到最后一个阶段&lt;/strong&gt;，主要是为了简化后续内存布局调整时的同步问题。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;恢复基本任务资源&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这个阶段，CRIU 为进程树中的每个进程恢复除了少数几类特殊资源之外的大部分状态。此时恢复的资源包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件描述符：&lt;/strong&gt; 打开检查点时记录的文件（使用保存的路径、访问模式、标志位），并根据需要设置到&lt;strong&gt;确切的文件偏移量&lt;/strong&gt;。对于管道、套接字等也会进行创建。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命名空间 (Namespaces):&lt;/strong&gt; 如果进程使用了非默认的命名空间（如 PID、Mount、Network、IPC、User、UTS），CRIU 会创建或加入相应的命名空间，隔离进程环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;私有内存映射：&lt;/strong&gt; 映射进程的&lt;strong&gt;私有&lt;/strong&gt;内存区域（如代码段、数据段、堆、匿名映射等），并从镜像文件中读取检查点时保存的数据，&lt;strong&gt;填充&lt;/strong&gt;到这些内存区域中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;套接字 (Sockets):&lt;/strong&gt; 创建套接字，并恢复其状态（如 TCP 连接的状态，如果检查点时保存了相关信息并配置了 TCP 修复）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作目录与根目录：&lt;/strong&gt; 调用 chdir() 和 chroot() 恢复进程检查点时刻的当前工作目录和根目录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他：&lt;/strong&gt; 还可能包括恢复信号处理器、进程的 umask 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有四类关键资源在此阶段&lt;strong&gt;不会&lt;/strong&gt;被完全恢复，它们的恢复被特意推迟到了最后阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存映射的&lt;strong&gt;确切虚拟地址&lt;/strong&gt;（此阶段可能映射在临时地址）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定时器 (Timers)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;凭证 (Credentials)&lt;/strong&gt; (如 UID, GID, Capabilities)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 (Threads)&lt;/strong&gt; (除了主线程)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几类资源之所以延迟恢复，主要是因为它们要么依赖于最终的内存布局，要么涉及特权操作，要么在最终执行前恢复可能导致状态不一致或复杂化处理。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;切换到 Restorer Context，恢复剩余资源并继续执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是最关键的一步。因为执行恢复操作的 CRIU 代码本身就位于需要被替换掉的内存区域中。直接执行 &lt;code&gt;munmap()&lt;/code&gt; 卸载旧内存或 &lt;code&gt;mmap()&lt;/code&gt; 映射新内存到当前地址，都会导致 CRIU 自身崩溃。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，CRIU 引入了一个 &lt;strong&gt;Restorer Context (恢复器上下文)&lt;/strong&gt;，这是一小段&lt;strong&gt;自包含的、位置无关的 (PIE)&lt;/strong&gt; 代码，不依赖外部库，并且被加载到一个临时的、既不属于 CRIU 主体也不属于目标进程最终内存布局的“&lt;strong&gt;安全地带 (safe zone)&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;CRIU 准备好恢复所需的数据（如最终内存映射信息、线程状态、凭证等），找到合适的内存“空洞”加载恢复器代码和数据，然后通过一次&lt;strong&gt;跳转&lt;/strong&gt;，将 CPU 的执行控制权转移给这段恢复器代码。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Restorer Context&lt;/strong&gt; 中，完成最后几项资源的恢复：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存映射 (Memory):&lt;/strong&gt; 使用 &lt;code&gt;mremap()&lt;/code&gt; 将之前映射在临时地址的私有匿名内存移动到最终的目标虚拟地址。使用 &lt;code&gt;mmap()&lt;/code&gt; 在正确的地址创建文件映射和共享内存映射（可能通过之前准备好的 &lt;code&gt;memfd&lt;/code&gt; 文件描述符来实现共享）。此时，完整的、精确的进程内存布局被建立起来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定时器 (Timers):&lt;/strong&gt; 恢复并启动所有的定时器。因为此时环境已稳定，可以避免定时器过早触发或计时偏差。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;凭证 (Credentials):&lt;/strong&gt; 设置进程最终的用户 ID、组 ID、能力集等。这通常在需要特权的操作（如 &lt;code&gt;fork()&lt;/code&gt; 指定 PID）完成后，但在彻底放弃特权之前进行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 (Threads):&lt;/strong&gt; 在最终的内存布局中，根据保存的状态创建并恢复目标进程的所有其他线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，&lt;strong&gt;Restorer Context&lt;/strong&gt; 完成所有设置后，它会&lt;strong&gt;精确地恢复目标进程主线程的寄存器状态&lt;/strong&gt;（包括最重要的&lt;strong&gt;指令指针 IP/PC&lt;/strong&gt;，指向检查点时刻被中断的那条指令），然后将 CPU 的控制权彻底交还给目标进程。至此，目标进程就像从未被打断过一样，从检查点时刻的状态&lt;strong&gt;无缝地继续执行&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;criu-小结&#34;&gt;
    &lt;a href=&#34;#criu-%e5%b0%8f%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRIU 小结
&lt;/h4&gt;&lt;p&gt;CRIU 通过 &lt;code&gt;ptrace&lt;/code&gt; 和精心设计的&lt;strong&gt;寄生代码&lt;/strong&gt;机制，以及对 &lt;code&gt;/proc&lt;/code&gt; 文件系统的深度利用，实现了在用户空间对运行中进程进行 &lt;strong&gt;Checkpoint&lt;/strong&gt; 和 &lt;strong&gt;Restore&lt;/strong&gt; 的强大能力，为 CRaC 技术的实现奠定了坚实的基础。&lt;/p&gt;
&lt;h3 id=&#34;crac-的设计理念&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e8%ae%be%e8%ae%a1%e7%90%86%e5%bf%b5&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的设计理念
&lt;/h3&gt;&lt;p&gt;理解了 CRIU 的强大能力后，一个自然的问题是：既然 CRIU 能够处理打开的文件描述符和网络连接，甚至可以透明地恢复它们，为什么 CRaC 却要求开发者通过 API（&lt;code&gt;jdk.crac.Resource&lt;/code&gt;）来手动管理这些外部资源，通常需要在 &lt;code&gt;beforeCheckpoint&lt;/code&gt; 中关闭它们，在 &lt;code&gt;afterRestore&lt;/code&gt; 中重新建立它们呢？&lt;/p&gt;
&lt;p&gt;对于这个问题，我查阅了 CRaC 所有相关的文档，阅读了 CRaC 原型实现的源码，都没有获得满意的答案。于是在 CRaC 的开发者邮件列表中询问，最终从核心 Committer 的&lt;a class=&#34;link&#34; href=&#34;https://mail.openjdk.org/pipermail/crac-dev/2025-April/002313.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;回复&lt;/a&gt;中得到解答。&lt;/p&gt;
&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271032455.jpg&#34; alt=&#34;CRaC 邮件列表&#34; style=&#34;zoom: 33%;&#34; /&gt;
&lt;p&gt;根据 CRaC 开发者的阐述，这并非技术上的限制，而是一个深思熟虑的&lt;strong&gt;架构选择 (architectural choice)&lt;/strong&gt;。其核心设计理念可以概括为 &lt;strong&gt;协调与适应&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CRIU 的主要动机之一是实现运行中容器的透明迁移。在容器迁移场景下，环境（文件系统、网络）通常是被精心管理的。容器运行时（如 Docker、Kubernetes CRI）可以配合 CRIU 工作，确保恢复后，外部环境（比如网络连接的对端、挂载的文件系统）仍然有效或被正确地重新建立，从而对容器内的进程做到“透明”。比如，网络连接恢复时，容器运行时会处理好 IP 地址、路由等问题。&lt;/p&gt;
&lt;p&gt;如果你追求的是 CRIU 那种“透明恢复”，理论上可以直接在 Java 进程上使用 CRIU。但这有风险，可能会破坏应用程序的内部逻辑。因为 Java 应用可能依赖外部资源的状态，如果环境变化而应用没有感知和调整，就会出问题（比如数据库连接指向了旧的、不存在的 IP，或者文件句柄指向了一个在恢复环境中已变化或不存在的文件）。&lt;/p&gt;
&lt;p&gt;CRaC 的目标不是追求完全透明的恢复。它想要的是：保留 JVM 和应用程序内部计算的&lt;strong&gt;有价值的状态&lt;/strong&gt;（比如 JIT 编译结果、缓存数据、业务逻辑状态），但要让应用程序有机会&lt;strong&gt;主动适应&lt;/strong&gt;恢复时可能已经变化的&lt;strong&gt;新环境&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CRaC（Coordinated Restore at Checkpoint）&lt;/strong&gt; 的名字强调了“协调”（&lt;strong&gt;Coordinated&lt;/strong&gt;）。它要求应用程序通过实现 &lt;code&gt;Resource&lt;/code&gt; 接口来参与 &lt;code&gt;Checkpoint&lt;/code&gt; 和 &lt;code&gt;Restore&lt;/code&gt; 过程。CRaC 希望开发者对每一个外部资源（文件、网络连接、数据库连接等）在恢复时如何处理，做出&lt;strong&gt;有意识的决定&lt;/strong&gt;：这个资源在 &lt;strong&gt;Checkpoint&lt;/strong&gt; 前应该如何处理（通常是关闭）？在 &lt;strong&gt;Restore&lt;/strong&gt; 后应该如何处理（通常是重新建立或验证）？&lt;/p&gt;
&lt;p&gt;这种强制性的协调机制被 CRaC 视为一个&lt;strong&gt;特性 (feature)&lt;/strong&gt;，而不是一个缺陷。这确保了应用程序能够优雅地适应 (gracefully adapt) 恢复后的新环境，而不是盲目地假设外部世界一成不变。通过显式地关闭和重新建立连接、验证文件句柄等操作，可以大大提高应用程序在 &lt;strong&gt;Restore&lt;/strong&gt; 后的健壮性和正确性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271102426.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;CRaC design&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;简而言之，CRaC 的设计哲学是，&lt;strong&gt;牺牲一定的透明度，换取应用在恢复后对环境变化的健壮适应能力&lt;/strong&gt;。它要求开发者更加明确地思考和管理应用的外部依赖。虽然这在初期可能带来一些额外的工作（比如处理日志文件句柄），但其目的是为了确保应用在 CRaC 恢复后能够稳定、正确地运行在一个可能已经发生变化的新环境中。&lt;/p&gt;
&lt;h3 id=&#34;openjdk-crac-实现概览&#34;&gt;
    &lt;a href=&#34;#openjdk-crac-%e5%ae%9e%e7%8e%b0%e6%a6%82%e8%a7%88&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    OpenJDK CRaC 实现概览
&lt;/h3&gt;&lt;p&gt;了解了 CRaC 的设计理念和底层依赖 CRIU 后，我们来看看 CRaC 功能在 OpenJDK 内部的大致实现流程。这个过程涉及 Java API 层、JVM 内部实现、外部引擎（默认是包装了 CRIU 的 criuengine）以及操作系统层面的交互。&lt;/p&gt;
&lt;h4 id=&#34;checkpoint-流程概览&#34;&gt;
    &lt;a href=&#34;#checkpoint-%e6%b5%81%e7%a8%8b%e6%a6%82%e8%a7%88&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Checkpoint 流程概览
&lt;/h4&gt;&lt;p&gt;Checkpoint 过程的目标是安全地停止 JVM，通知所有已注册的资源进行准备，然后调用外部引擎来创建进程镜像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271113195.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Checkpoint&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;触发 Checkpoint&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户执行 &lt;code&gt;jcmd &amp;lt;pid&amp;gt; JDK.checkpoint&lt;/code&gt;，&lt;code&gt;CheckpointDCmd::execute&lt;/code&gt; 被调用，它解析 &lt;code&gt;jdk.crac.Core&lt;/code&gt; 类，并调用其静态方法 &lt;code&gt;checkpointRestoreInternal(long jcmdStream)&lt;/code&gt;。&lt;code&gt;jcmdStream&lt;/code&gt; 是用于输出 &lt;code&gt;jcmd&lt;/code&gt; 结果的流。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Java 层准备&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;遍历所有注册到全局上下文 &lt;a class=&#34;link&#34; href=&#34;https://crac.github.io/openjdk-builds/javadoc/api/java.base/jdk/crac/Context.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Context&lt;/a&gt;的 &lt;a class=&#34;link&#34; href=&#34;https://crac.github.io/openjdk-builds/javadoc/api/java.base/jdk/crac/Resource.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Resource&lt;/a&gt; 实现，并调用它们的 &lt;code&gt;beforeCheckpoint&lt;/code&gt; 方法。&lt;code&gt;Resource&lt;/code&gt; 在此方法中执行必要的清理或准备工作（例如，关闭不需要的网络连接、刷新缓冲区等）。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;进入 JVM/Native 层&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;调用 native 方法 &lt;code&gt;checkpointRestore0(int[] fdArr, Object[] objArr, boolean dryRun, long jcmdStream)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;定义在 &lt;code&gt;CracCore.c&lt;/code&gt; 中的 JNI 实现 &lt;code&gt;Java_jdk_crac_Core_checkpointRestore0&lt;/code&gt; 调用 &lt;code&gt;JVM_Checkpoint&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JVM_Checkpoint&lt;/code&gt; 是一个 JVM 标准入口点，它调用 &lt;code&gt;crac::checkpoint&lt;/code&gt;，正式进入 CRaC 的 &lt;code&gt;checkpoint&lt;/code&gt; 阶段。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;JVM 内部 Checkpoint 准备&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;crac::checkpoint&lt;/code&gt; 是 CRaC 的主入口，首先执行一次强制 Full GC (&lt;code&gt;GCCause::_full_gc_alot&lt;/code&gt;) ，清理未使用的堆区域，以减小镜像体积。&lt;/p&gt;
&lt;p&gt;然后通过  &lt;code&gt;VMThread::execute()&lt;/code&gt; 进入 JVM 的 &lt;strong&gt;Safepoint&lt;/strong&gt;，这是所有的 Java 线程都已暂停，准备好执行接下来的 checkpoint 操作。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;checkpoint 操作执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;遍历 &lt;code&gt;/proc/self/fd&lt;/code&gt; 下的所有文件描述符，如果有应用程序打开但未声明的资源，会导致 Checkpoint 失败，操作会提前返回，最终导致 Java 层抛出 CheckpointException。&lt;/p&gt;
&lt;p&gt;如果一切顺利，调用 &lt;code&gt;report_ok_to_jcmd_if_any()&lt;/code&gt;。这会向 jcmd 客户端发送一个初步的成功响应，然后才调用外部引擎。这样做是因为外部引擎（如 CRIU）通常会杀死原始 JVM 进程，所以响应必须在此之前发送。&lt;/p&gt;
&lt;p&gt;接着在  &lt;code&gt;call_crengine&lt;/code&gt; fork 新的进程，加载外部引擎 &lt;code&gt;criuengine&lt;/code&gt;，执行 &lt;code&gt;criuengine&lt;/code&gt;的 &lt;code&gt;checkpoint&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;checkpoint&lt;/code&gt;方法中使用 &lt;strong&gt;double fork&lt;/strong&gt; 技巧，让孙子进程执行 CRIU，这样 CRIU 进程就不再是 JVM 的子进程。&lt;/p&gt;
&lt;p&gt;孙子进程执行的具体命令是 &lt;code&gt;criu dump -t &amp;lt;jvm_pid&amp;gt; -D &amp;lt;checkpoint_dir&amp;gt; --shell-job [options...]&lt;/code&gt;，冻结 JVM 进程，将其状态保存到 &lt;code&gt;&amp;lt;checkpoint_dir&amp;gt;&lt;/code&gt; 下的镜像文件中，然后 &lt;strong&gt;杀死&lt;/strong&gt; 原始的 JVM 进程。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;JVM 暂停点&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JVM 进程从 &lt;code&gt;call_crengine&lt;/code&gt; 快速返回，继续执行至 &lt;code&gt;sigwaitinfo()&lt;/code&gt; 阻塞。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;sigset_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;waitmask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;sigemptyset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;waitmask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// 初始化空信号集
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;sigaddset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;waitmask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RESTORE_SIGNAL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 添加自定义的恢复信号
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;siginfo_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;sig&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sigwaitinfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;waitmask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// &amp;lt;--- JVM 在这里阻塞，阻塞等待指定信号
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sig&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;errno&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EINTR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当 JVM 完成检查点（checkpoint）后，会进入等待循环，后续恢复进程会通过&lt;code&gt;RESTORE_SIGNAL&lt;/code&gt;信号唤醒 JVM。&lt;/p&gt;
&lt;h4 id=&#34;checkpoint-的进程交互&#34;&gt;
    &lt;a href=&#34;#checkpoint-%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%ba%a4%e4%ba%92&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Checkpoint 的进程交互
&lt;/h4&gt;&lt;p&gt;在通过外部引擎 &lt;code&gt;criuengine&lt;/code&gt;执行&lt;code&gt;criu dump&lt;/code&gt;的过程中，使用了 Linux 常见的编程技巧&lt;strong&gt;double fork&lt;/strong&gt;，主要原因是为了&lt;strong&gt;解耦&lt;/strong&gt;：通过让中间进程快速退出，使得执行 &lt;code&gt;criu dump&lt;/code&gt; 的孙子进程成为孤儿进程，被 init 进程收养，从而“逃离”了原始 JVM 的进程树。&lt;/p&gt;
&lt;p&gt;最终执行 &lt;code&gt;criu dump&lt;/code&gt; 的进程不属于原始 JVM 进程的进程树，这避免了 CRIU 在执行 Checkpoint 时尝试冻结其自身的问题，保证了 Checkpoint 操作的正确性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271546812.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;checkpoint&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图总结了 Checkpoint 过程中涉及的多个进程的创建。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;JVM fork -&amp;gt; P1 (criuengine checkpoint)&lt;/strong&gt;: JVM 创建子进程 P1 运行 &lt;code&gt;criuengine checkpoint&lt;/code&gt;，JVM 进程等待 P1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P1 fork -&amp;gt; P2&lt;/strong&gt;: P1 创建子进程 P2，P1 等待 P2。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P2 fork -&amp;gt; P3 &amp;amp; P2 exit&lt;/strong&gt;: P2 创建孙子进程 P3，然后 P2 &lt;strong&gt;立即退出&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P1 exit&lt;/strong&gt;: P1 检测到 P2 退出，于是 P1 也退出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JVM 继续&lt;/strong&gt;: JVM 检测到 P1 退出，&lt;code&gt;call_crengine&lt;/code&gt; 返回，JVM 继续执行直到 &lt;code&gt;sigwaitinfo&lt;/code&gt; 阻塞。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P3 fork -&amp;gt; criu dump&lt;/strong&gt;: P3 成为孤儿进程（被 &lt;code&gt;init/systemd&lt;/code&gt; 接管），创建 &lt;code&gt;criu&lt;/code&gt; 进程，最终执行 &lt;code&gt;criu dump&lt;/code&gt;，冻结并杀死阻塞中的 JVM。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;restore-流程概览&#34;&gt;
    &lt;a href=&#34;#restore-%e6%b5%81%e7%a8%8b%e6%a6%82%e8%a7%88&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Restore 流程概览
&lt;/h4&gt;&lt;p&gt;Restore 过程的目标是从 Checkpoint 镜像启动一个新的 JVM 实例，使其恢复到 Checkpoint 时刻的状态，然后继续执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271552897.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Restore&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;触发 Restore&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户启动 JVM，并指定 Restore 相关的参数  &lt;code&gt;-XX:CRaCRestoreFrom=&amp;lt;checkpoint_dir&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;JVM 初始化&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在创建 JVM 的过程中，检测到 &lt;strong&gt;Restore&lt;/strong&gt; 请求，调用 &lt;code&gt;crac::restore()&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;准备并切换引擎&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进入 &lt;code&gt;crac::restore()&lt;/code&gt; ，首先调用&lt;code&gt;compute_crengine()&lt;/code&gt; ，确定外部引擎的路径和参数。&lt;/p&gt;
&lt;p&gt;然后使用当前进程 ID (&lt;code&gt;os::current_process_id()&lt;/code&gt;) 创建一个唯一的 &lt;strong&gt;共享内存 (SHM)&lt;/strong&gt; 路径，打开 &lt;strong&gt;SHM&lt;/strong&gt; 文件，并将 Restore 参数写入到 &lt;strong&gt;SHM&lt;/strong&gt;（&lt;code&gt;CracRestoreParameters::write_to&lt;/code&gt;）。&lt;strong&gt;SHM&lt;/strong&gt; 用于在 &lt;code&gt;crac::restore&lt;/code&gt;（初始 JVM）和恢复后的 JVM 之间传递新的启动参数、属性和时间戳。&lt;/p&gt;
&lt;p&gt;最后调用 &lt;code&gt;os::execv(_crengine, _crengine_args)&lt;/code&gt;。 &lt;code&gt;execv&lt;/code&gt; 会用新的程序（外部引擎 &lt;code&gt;criuengine&lt;/code&gt;）&lt;strong&gt;替换&lt;/strong&gt;当前的 JVM 进程。初始启动的 JVM 到此结束。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;外部引擎执行 Restore (criuengine restore)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;外部引擎 &lt;code&gt;criuengine&lt;/code&gt; 执行 &lt;code&gt;restore&lt;/code&gt; 方法，构建 &lt;code&gt;criu restore&lt;/code&gt; 命令参数。关键参数包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-D &amp;lt;checkpoint_dir&amp;gt;&lt;/code&gt;: 指定镜像目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--action-script self&lt;/code&gt;: 指定 &lt;code&gt;criuengine&lt;/code&gt; 自身作为 CRIU 的动作脚本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--exec-cmd -- self restorewait&lt;/code&gt;: 指定 CRIU 成功恢复进程后，应该执行 &lt;code&gt;criuengine restorewait&lt;/code&gt; 命令。这个命令会等待恢复后的 JVM 进程结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行 &lt;code&gt;execv&lt;/code&gt; 运行 &lt;code&gt;criu restore&lt;/code&gt; 命令，再次替换当前进程。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;CRIU 执行恢复&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CRIU 读取镜像文件，在内存中重建 JVM 进程的状态（内存映射、线程状态、寄存器等）。&lt;/p&gt;
&lt;p&gt;在进程状态基本恢复但尚未完全运行时，CRIU 会调用 &lt;code&gt;--action-script&lt;/code&gt; 指定的脚本（即 &lt;code&gt;criuengine&lt;/code&gt;），进入 &lt;code&gt;post_resume&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;post_resume&lt;/code&gt; 方法中，获取恢复后的 JVM PID 和之前存入的 SHM ID，然后使用 &lt;code&gt;sigqueue&lt;/code&gt; 向恢复的 JVM 进程发送 &lt;code&gt;RESTORE_SIGNAL&lt;/code&gt; 信号。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;外部等待进程 (criuengine restorewait)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据参数 &lt;code&gt;--exec-cmd&lt;/code&gt; 指定的命令，再次执行 &lt;code&gt;execv&lt;/code&gt;，将执行恢复的 CRIU 进程替换为 &lt;code&gt;criuengine restorewait&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;criuengine&lt;/code&gt; 使用 &lt;code&gt;waitpid&lt;/code&gt; 等待刚刚恢复并继续运行的 JVM 进程，它会捕获发给它自己的信号，并尝试将这些信号转发给 JVM 进程。&lt;/p&gt;
&lt;p&gt;当 JVM 进程最终退出时，&lt;code&gt;waitpid&lt;/code&gt; 返回，&lt;code&gt;criuengine&lt;/code&gt; 进程也以相同的退出码或基于信号的状态退出。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;恢复的 JVM 继续执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271742570.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;jvm restore&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;恢复的 JVM 进程收到 CRIU 进程发送的 &lt;code&gt;RESTORE_SIGNAL&lt;/code&gt; 信号，从 &lt;code&gt;sigwaitinfo()&lt;/code&gt; 醒来，执行流回到 &lt;code&gt;checkpoint_restore&lt;/code&gt; 函数（在 &lt;code&gt;crac.cpp&lt;/code&gt; 中），正好在 &lt;code&gt;call_crengine()&lt;/code&gt; 之后等待信号的地方。&lt;/p&gt;
&lt;p&gt;执行一些 JVM 恢复动作，包括根据 SHM ID 从共享内存中读取新的命令行参数，进行时间校准，唤醒可能在 &lt;strong&gt;Checkpoint&lt;/strong&gt; 时处于 &lt;code&gt;sleep&lt;/code&gt; 或 &lt;code&gt;park&lt;/code&gt; 状态的线程。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;返回 Java 层&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JVM 将新参数返回给 &lt;code&gt;jdk.crac.Core&lt;/code&gt;，&lt;code&gt;Core&lt;/code&gt; 应用新属性，遍历所有注册的 &lt;code&gt;Resource&lt;/code&gt;，调用其 &lt;code&gt;afterRestore&lt;/code&gt; 方法，执行恢复后的初始化工作（例如，重新建立连接、重新加载配置等）。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;完成&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果没有异常，从 &lt;code&gt;Core.checkpointRestoreInternal&lt;/code&gt; 正常退出，Restore 成功，JVM 继续运行。&lt;/p&gt;
&lt;h4 id=&#34;restore-的进程交互&#34;&gt;
    &lt;a href=&#34;#restore-%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%ba%a4%e4%ba%92&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Restore 的进程交互
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Restore&lt;/strong&gt; 过程巧妙地利用了 &lt;code&gt;execv&lt;/code&gt; 系统调用来&lt;strong&gt;替换&lt;/strong&gt;当前进程的映像，从而将控制权逐步交给下一个阶段所需的工具，最终恢复目标 JVM 进程。需要注意的是，在这个流程中，&lt;code&gt;fork&lt;/code&gt; 并不像 &lt;strong&gt;Checkpoint&lt;/strong&gt; 流程那样显式地用于创建等待子进程的父进程，而是由 CRIU 内部管理，但 &lt;code&gt;execv&lt;/code&gt; 是贯穿始终的关键。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271821190.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Restore&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动 Restore 命令 (用户 -&amp;gt; P1)&lt;/strong&gt;
用户执行 &lt;code&gt;java -XX:CRaCRestoreFrom=&amp;lt;checkpoint_dir&amp;gt;&lt;/code&gt; 命令，启动了一个初始的 JVM 进程，我们称之为 &lt;strong&gt;P1&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;P1&lt;/strong&gt; 执行第一次 &lt;code&gt;execv&lt;/code&gt; (&lt;strong&gt;P1&lt;/strong&gt; -&amp;gt; &lt;strong&gt;P2&lt;/strong&gt;: &lt;code&gt;criuengine restore&lt;/code&gt;)
在 &lt;code&gt;crac::restore()&lt;/code&gt;中，&lt;strong&gt;P1&lt;/strong&gt; 准备必要的参数，调用 &lt;code&gt;os::execv(_crengine, _crengine_args)&lt;/code&gt;，这里的 &lt;code&gt;_crengine&lt;/code&gt; 是 &lt;code&gt;criuengine&lt;/code&gt; 的路径，&lt;code&gt;_crengine_args&lt;/code&gt; 包含了 &amp;ldquo;restore&amp;rdquo; 和 Checkpoint 目录等参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结果 &lt;code&gt;execv&lt;/code&gt; 用 &lt;code&gt;criuengine restore&lt;/code&gt; 程序替换了 &lt;strong&gt;P1&lt;/strong&gt; 进程。原来的 Java 进程 &lt;strong&gt;P1&lt;/strong&gt; 不复存在。现在的进程我们称之为 &lt;strong&gt;P2&lt;/strong&gt;，虽然 PID 可能与 &lt;strong&gt;P1&lt;/strong&gt; 相同，但运行的程序已改变，&lt;strong&gt;P2&lt;/strong&gt; 正在执行 &lt;code&gt;criuengine restore&lt;/code&gt; 的代码。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;P2&lt;/strong&gt; 执行第二次 &lt;code&gt;execv&lt;/code&gt; (&lt;strong&gt;P2&lt;/strong&gt; -&amp;gt; &lt;strong&gt;P3&lt;/strong&gt;: &lt;code&gt;criu restore&lt;/code&gt;)
&lt;strong&gt;P2&lt;/strong&gt; 运行 &lt;code&gt;criuengine restore&lt;/code&gt; 代码，进行一些准备工作，构建 criu 命令行的参数，调用 &lt;code&gt;execv(criu, const_cast&amp;lt;char **&amp;gt;(args.data()))&lt;/code&gt; ，用 &lt;code&gt;criu restore&lt;/code&gt; 程序替换了 &lt;strong&gt;P2&lt;/strong&gt; 进程。&lt;code&gt;criuengine restore&lt;/code&gt; 进程 &lt;strong&gt;P2&lt;/strong&gt; 不复存在。现在的进程（我们称之为 &lt;strong&gt;P3&lt;/strong&gt;）正在执行 &lt;code&gt;criu restore&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;P3&lt;/strong&gt; (CRIU) 恢复 JVM 进程，执行第三次 &lt;code&gt;execv&lt;/code&gt; (&lt;strong&gt;P3&lt;/strong&gt; -&amp;gt; &lt;strong&gt;P4&lt;/strong&gt;: &lt;code&gt;criuengine restorewait&lt;/code&gt;)
&lt;strong&gt;P3&lt;/strong&gt; （运行 &lt;code&gt;criu restore&lt;/code&gt;）读取 Checkpoint 镜像文件，恢复（fork）目标 JVM 进程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在成功恢复 JVM 之后，CRIU 本身需要结束。由于指定了 &lt;code&gt;--exec-cmd -- self restorewait&lt;/code&gt;，CRIU 会执行最后一次 &lt;code&gt;execv&lt;/code&gt;，用 &lt;code&gt;criuengine restorewait&lt;/code&gt; 程序替换了 &lt;strong&gt;P3&lt;/strong&gt; 进程。&lt;code&gt;criu restore&lt;/code&gt; 进程 &lt;strong&gt;P3&lt;/strong&gt; 不复存在，现在的进程（我们称之为 &lt;strong&gt;P4&lt;/strong&gt;）正在执行 &lt;code&gt;criuengine restorewait&lt;/code&gt;。与此同时，&lt;strong&gt;JVM&lt;/strong&gt; 已经独立运行起来，并完成了 &lt;code&gt;Restore&lt;/code&gt; 的 Java 层逻辑。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;P4&lt;/strong&gt; (&lt;code&gt;criuengine restorewait&lt;/code&gt;) 等待 JVM
&lt;strong&gt;P4&lt;/strong&gt; （运行 &lt;code&gt;criuengine restorewait&lt;/code&gt; 代码）获取 JVM 的 PID，设置信号处理程序，尝试将接收到的信号转发给 JVM。最后调用 &lt;code&gt;waitpid(pid_P_JVM, &amp;amp;status, 0)&lt;/code&gt;，等待 JVM 进程终止。当 JVM 退出时，&lt;strong&gt;P4&lt;/strong&gt; 获取其退出状态，然后 &lt;strong&gt;P4&lt;/strong&gt; 也以相同的状态退出。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单来说，当 JVM 恢复时，通过 &lt;code&gt;java -XX:CRaCRestoreFrom=...&lt;/code&gt; 启动的进程并不会启动 JVM，而是通过 &lt;code&gt;criuengine&lt;/code&gt; 执行 CRIU，后者将恢复的进程作为其子进程启动。当 CRIU 完成进程重建后，它会执行 &lt;code&gt;criuengine restorewait&lt;/code&gt; ，该程序的唯一任务是等待其唯一子进程（恢复的 JVM）退出并传递其状态。这意味着现在有两个进程，恢复的 JVM 进程是 &lt;code&gt;criuengine&lt;/code&gt; 的子进程。&lt;/p&gt;
&lt;h2 id=&#34;四crac-使用指南&#34;&gt;
    &lt;a href=&#34;#%e5%9b%9bcrac-%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8d%97&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    四、CRaC 使用指南
&lt;/h2&gt;&lt;p&gt;本章将详细介绍如何在你的 Java 应用程序中使用 CRaC 技术，包括理解其协调机制、使用 API、文件描述符策略以及通过一个 Jetty 示例进行实战演练。&lt;/p&gt;
&lt;h3 id=&#34;为何需要-orgcrac-包&#34;&gt;
    &lt;a href=&#34;#%e4%b8%ba%e4%bd%95%e9%9c%80%e8%a6%81-orgcrac-%e5%8c%85&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    为何需要 org.crac 包
&lt;/h3&gt;&lt;p&gt;CRaC 的核心 API（如 &lt;code&gt;Resource&lt;/code&gt; 接口）最初存在于不同的包路径下（例如早期的 &lt;code&gt;javax.crac&lt;/code&gt; 或 JDK 内部的 &lt;code&gt;jdk.crac&lt;/code&gt;）。为了提供一个&lt;strong&gt;稳定且兼容&lt;/strong&gt;的编程接口，社区引入了 &lt;code&gt;org.crac&lt;/code&gt; 这个独立的库。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;org.crac&lt;/code&gt; 库的好处在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;平滑采用：&lt;/strong&gt; 开发者可以依赖这个库来编写 CRaC 相关的代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨运行时兼容：&lt;/strong&gt; 应用程序可以在不同的 Java 运行时上编译和运行，无论该运行时是否内置了 CRaC 支持（如标准的 OpenJDK、带有 jdk.crac 的 CRaC 构建版本，或者更早期的 javax.crac 实现）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;未来适应性：&lt;/strong&gt; 即便未来 CRaC API 的包路径发生变化，应用程序代码也无需修改，只需更新 org.crac 库版本即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;org.crac&lt;/code&gt; 库的核心功能是作为 CRaC API 的一个&lt;strong&gt;适配器&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编译时：&lt;/strong&gt; 它提供了与 &lt;code&gt;jdk.crac&lt;/code&gt;（以及历史上的 &lt;code&gt;javax.crac&lt;/code&gt;）完全镜像的 API 接口，供开发者编译时依赖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行时：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;org.crac&lt;/code&gt; 使用&lt;strong&gt;反射&lt;/strong&gt;机制来检测当前运行的 JVM 是否包含实际的 CRaC 实现（检查是否存在 &lt;code&gt;jdk.crac.Core&lt;/code&gt; 或 &lt;code&gt;javax.crac.Core&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;检测到&lt;/strong&gt; CRaC 实现，所有对 &lt;code&gt;org.crac&lt;/code&gt; API 的调用都会被&lt;strong&gt;转发&lt;/strong&gt;给底层的实际实现。&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;未检测到&lt;/strong&gt; CRaC 实现（例如在标准 OpenJDK 上运行），请求会被转发到一个&lt;strong&gt;虚拟（dummy）实现&lt;/strong&gt;。这个虚拟实现允许应用程序正常运行，&lt;code&gt;Resource&lt;/code&gt; 也可以注册，但任何尝试创建 &lt;code&gt;Checkpoint&lt;/code&gt; 的请求（如调用 &lt;code&gt;Core.checkpointRestore()&lt;/code&gt;）都会&lt;strong&gt;失败并抛出异常&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这种方式，&lt;code&gt;org.crac&lt;/code&gt; 库确保了应用程序即使在不支持 CRaC 的环境中也能运行，同时在支持 CRaC 的环境中能够无缝对接。&lt;/p&gt;
&lt;h3 id=&#34;添加-orgcrac-api-依赖&#34;&gt;
    &lt;a href=&#34;#%e6%b7%bb%e5%8a%a0-orgcrac-api-%e4%be%9d%e8%b5%96&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    添加 org.crac API 依赖
&lt;/h3&gt;&lt;p&gt;可以通过 Maven 或 Gradle 将 &lt;code&gt;org.crac&lt;/code&gt; 库添加到你的项目中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Maven&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dependency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;groupId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;org&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;groupId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;artifactId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;artifactId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dependency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Gradle&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;implementation&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;org&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;crac-的协调机制&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e5%8d%8f%e8%b0%83%e6%9c%ba%e5%88%b6&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的协调机制
&lt;/h3&gt;&lt;p&gt;如前所述，CRaC 的核心设计理念是“协调与适应”。虽然底层的 CRIU 能够冻结和恢复进程的大部分状态，但对于&lt;strong&gt;外部资源&lt;/strong&gt;（External Resources），如打开的文件、网络连接（Socket）、数据库连接等，简单的透明恢复可能会导致问题。原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;环境变化：&lt;/strong&gt; &lt;code&gt;Restore&lt;/code&gt; 发生时，运行环境可能已经改变（例如，IP 地址、主机名、挂载的文件系统内容）。直接恢复旧的资源句柄可能指向无效或错误的目标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;状态失效：&lt;/strong&gt; 某些外部资源的状态可能具有时效性（例如，数据库连接超时、文件被其他进程修改）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源冲突：&lt;/strong&gt; 恢复的进程可能尝试使用已被新环境占用的资源（例如，端口号）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，CRaC &lt;strong&gt;不选择&lt;/strong&gt;让 CRIU 默认透明地处理这些外部资源，而是要求应用程序&lt;strong&gt;必须&lt;/strong&gt;参与到 &lt;strong&gt;Checkpoint&lt;/strong&gt; 和 &lt;strong&gt;Restore&lt;/strong&gt; 的过程中，主动管理这些资源。这就是“协调”的含义。应用程序需要明确告知 CRaC 如何安全地处理这些外部连接和状态，以确保在 &lt;strong&gt;Restore&lt;/strong&gt; 后能够正确地适应新环境。&lt;/p&gt;
&lt;p&gt;为了实现这种协调，&lt;code&gt;org.crac&lt;/code&gt; 包提供了核心的 &lt;code&gt;Resource&lt;/code&gt; 接口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;org.crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ... imports ...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;beforeCheckpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;afterRestore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;需要管理外部资源的类可以实现 &lt;code&gt;Resource&lt;/code&gt; 接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Checkpoint 前调用 &lt;code&gt;beforeCheckpoint(Context&amp;lt;? extends Resource&amp;gt; context)&lt;/code&gt;，用于&lt;strong&gt;释放/关闭&lt;/strong&gt;外部资源，确保状态一致。如果无法准备好，抛出异常阻止 Checkpoint。&lt;/li&gt;
&lt;li&gt;在 Restore 后调用 &lt;code&gt;afterRestore(Context&amp;lt;? extends Resource&amp;gt; context)&lt;/code&gt;，用于&lt;strong&gt;重新建立/验证&lt;/strong&gt;外部资源，恢复状态。如果恢复失败，抛出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 &lt;code&gt;org.crac.Core.getGlobalContext().register(this)&lt;/code&gt; ，将实现了 &lt;code&gt;Resource&lt;/code&gt; 的对象注册给 CRaC 运行时。注册顺序决定了 &lt;code&gt;beforeCheckpoint&lt;/code&gt; 的调用顺序，而 &lt;code&gt;afterRestore&lt;/code&gt; 则以相反顺序调用。&lt;/p&gt;
&lt;h3 id=&#34;文件描述符策略-file-descriptor-policies&#34;&gt;
    &lt;a href=&#34;#%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6%e7%ad%96%e7%95%a5-file-descriptor-policies&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    文件描述符策略 (File Descriptor Policies)
&lt;/h3&gt;&lt;p&gt;虽然 CRaC 推荐通过实现 &lt;code&gt;Resource&lt;/code&gt; 接口来主动管理外部资源，但也提供了一种基于配置的备选方案，称为&lt;strong&gt;文件描述符策略 (File Descriptor Policies)&lt;/strong&gt;。这主要用于处理那些&lt;strong&gt;难以修改&lt;/strong&gt;以添加 &lt;code&gt;Resource&lt;/code&gt; 回调的代码，例如第三方库或 JDK 内部代码（注意：此策略仅适用于通过 JDK API 打开的文件描述符，不适用于 Native 代码打开的 FD）。&lt;/p&gt;
&lt;h4 id=&#34;配置方式&#34;&gt;
    &lt;a href=&#34;#%e9%85%8d%e7%bd%ae%e6%96%b9%e5%bc%8f&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    配置方式
&lt;/h4&gt;&lt;p&gt;通过设置系统属性 &lt;code&gt;jdk.crac.resource-policies&lt;/code&gt; 指向一个策略文件来启用。该文件采用类似 YAML 的格式，包含一个或多个规则，规则之间用 &lt;code&gt;---&lt;/code&gt; 分隔。以 &lt;code&gt;#&lt;/code&gt; 开头的行是注释。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;# 规则示例 1: 关闭特定文件  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;file  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/path/to/my/file  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;close  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 规则示例 2: 忽略所有 .log 文件 (交给 CRIU 处理)  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;FILE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 类型不区分大小写  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;**\*.log&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 支持 glob 模式  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ignore  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;warn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 禁止对此规则匹配的 FD 打印警告  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 规则示例 3: 重新打开 Unix socket  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;socket  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;unix  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;localPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/var/run/app.sock  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reopen&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 注意：socket 的 reopen 目前可能不完善&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;CRaC 在 Checkpoint 时会检查所有打开的文件描述符。对于每个 FD，它会&lt;strong&gt;按顺序&lt;/strong&gt;查找策略文件中的规则，&lt;strong&gt;第一个匹配&lt;/strong&gt;的规则将被应用，后续规则会被忽略。&lt;/p&gt;
&lt;p&gt;每个规则必须包含 &lt;code&gt;type&lt;/code&gt; 和 &lt;code&gt;action&lt;/code&gt; 两个属性（值不区分大小写）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可用类型 (type):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;file: 本地文件系统上的文件或目录。&lt;/li&gt;
&lt;li&gt;pipe: 匿名管道（命名管道使用 file 类型）。&lt;/li&gt;
&lt;li&gt;socket: 网络套接字（TCP, UDP 等）或 Unix 域套接字。&lt;/li&gt;
&lt;li&gt;filedescriptor: 无法通过以上类型识别的原始文件描述符（例如，由 Native 代码打开但通过 JDK API 暴露的）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件-file-规则&#34;&gt;
    &lt;a href=&#34;#%e6%96%87%e4%bb%b6-file-%e8%a7%84%e5%88%99&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    文件 (file) 规则
&lt;/h4&gt;&lt;p&gt;通过 &lt;code&gt;path&lt;/code&gt; 属性匹配，支持 &lt;a class=&#34;link&#34; href=&#34;https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;glob 模式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;**可用操作 (action)**支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;error&lt;/strong&gt;: (默认) 打印错误并导致 Checkpoint 失败。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ignore&lt;/strong&gt;: 忽略此 FD，将其处理完全委托给底层的 Checkpoint/Restore 引擎（如 CRIU）。CRIU 通常会尝试验证并在 Restore 时重新打开文件。&lt;strong&gt;这是将处理责任交给 CRIU 的方式。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;close&lt;/strong&gt;: 在 Checkpoint 前关闭文件。如果在 Restore 后尝试使用该 FD，会导致运行时异常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reopen&lt;/strong&gt;: 在 Checkpoint 前关闭文件，并在 Restore 后尝试在相同位置重新打开它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;管道-pipe-规则&#34;&gt;
    &lt;a href=&#34;#%e7%ae%a1%e9%81%93-pipe-%e8%a7%84%e5%88%99&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    管道 (pipe) 规则
&lt;/h4&gt;&lt;p&gt;匿名管道无法通过名称识别，因此通常最多只有一个 pipe 规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可用操作 (action)&lt;/strong&gt; 支持 &lt;strong&gt;error&lt;/strong&gt;，&lt;strong&gt;ignore&lt;/strong&gt; 和 &lt;strong&gt;close&lt;/strong&gt;，含义和文件规则相同。&lt;/p&gt;
&lt;h4 id=&#34;套接字-socket-规则&#34;&gt;
    &lt;a href=&#34;#%e5%a5%97%e6%8e%a5%e5%ad%97-socket-%e8%a7%84%e5%88%99&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    套接字 (socket) 规则
&lt;/h4&gt;&lt;p&gt;可以通过以下属性细化匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;family&lt;/strong&gt;: &lt;code&gt;ipv4/inet4&lt;/code&gt;, &lt;code&gt;ipv6/inet6&lt;/code&gt;, &lt;code&gt;ip/inet&lt;/code&gt; (任意 IP), &lt;code&gt;unix&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;localAddress&lt;/strong&gt;, &lt;strong&gt;remoteAddress&lt;/strong&gt;: IP 地址或 &lt;code&gt;*&lt;/code&gt; (任意地址)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;localPort&lt;/strong&gt;, &lt;strong&gt;remotePort&lt;/strong&gt;: 端口号或 &lt;code&gt;*&lt;/code&gt; (任意端口)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;localPath&lt;/strong&gt;, &lt;strong&gt;remotePath&lt;/strong&gt;: Unix 套接字路径，支持 glob 模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;可用操作 (action)&lt;/strong&gt;  支持 &lt;strong&gt;error&lt;/strong&gt;，&lt;strong&gt;ignore&lt;/strong&gt; 和 &lt;strong&gt;close&lt;/strong&gt;。&lt;strong&gt;reopen&lt;/strong&gt; 也可以使用，它会在 Checkpoint 前关闭套接字，但目前重新打开的逻辑（特别是对于监听套接字）可能尚未完全实现。&lt;/p&gt;
&lt;h4 id=&#34;原始文件描述符-filedescriptor-规则&#34;&gt;
    &lt;a href=&#34;#%e5%8e%9f%e5%a7%8b%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6-filedescriptor-%e8%a7%84%e5%88%99&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    原始文件描述符 (filedescriptor) 规则
&lt;/h4&gt;&lt;p&gt;用于匹配那些没有对应 Java 对象（如 &lt;code&gt;FileOutputStream&lt;/code&gt;）的文件描述符。&lt;/p&gt;
&lt;p&gt;可以通过数值 &lt;code&gt;value: 123&lt;/code&gt; ，或原生描述的正则表达式 &lt;code&gt;regex: .*something.*&lt;/code&gt; (Java 正则语法) 来匹配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可用操作 (action)&lt;/strong&gt;  支持 &lt;strong&gt;error&lt;/strong&gt;， &lt;strong&gt;ignore&lt;/strong&gt; 和 &lt;strong&gt;close&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;重要提示&#34;&gt;
    &lt;a href=&#34;#%e9%87%8d%e8%a6%81%e6%8f%90%e7%a4%ba&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    重要提示
&lt;/h4&gt;&lt;p&gt;文件描述符策略被认为是&lt;strong&gt;权宜之计&lt;/strong&gt;，用于处理无法直接修改代码的情况。&lt;strong&gt;首选且更健壮的方式仍然是实现 Resource 接口&lt;/strong&gt;，因为应用程序最了解如何正确、安全地处理其外部资源，尤其是在面对环境变化时。过度依赖 ignore 策略可能隐藏潜在的 Restore 后问题。&lt;/p&gt;
&lt;h3 id=&#34;crac-实战&#34;&gt;
    &lt;a href=&#34;#crac-%e5%ae%9e%e6%88%98&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 实战
&lt;/h3&gt;&lt;p&gt;下面我们通过一个简单的 Jetty Web 服务器示例，演示如何使用 &lt;code&gt;org.crac&lt;/code&gt; API 来支持 CRaC。完整代码可在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/org-crac/example-jetty&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;example-jetty&lt;/a&gt; 仓库找到。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;初始 Jetty 应用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设我们有一个简单的 Jetty 应用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;App&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AbstractHandler&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;serverManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;handle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(...)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;serverManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;App&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;添加 org.crac 依赖&lt;/strong&gt;&lt;br&gt;
在 &lt;code&gt;pom.xml&lt;/code&gt; (Maven) 或 &lt;code&gt;build.gradle&lt;/code&gt; (Gradle) 中添加 &lt;code&gt;org.crac&lt;/code&gt; 依赖。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dependency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;groupId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;org&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;groupId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;artifactId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;artifactId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dependency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;尝试 Checkpoint (预期失败)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;编译并运行应用，启用 CRaC 并指定 Checkpoint 目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 编译&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ mvn clean package
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 运行  &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ java -XX:CRaCCheckpointTo&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr -Djdk.crac.collect-fd-stacktraces&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt; -jar target/example-jetty-1.0-SNAPSHOT.jar
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;应用启动后，尝试访问 &lt;code&gt;http://localhost:8080&lt;/code&gt;，应该能看到“Hello World”。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl localhost:8080
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Hello World
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后尝试触发 Checkpoint：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 查找 PID &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ jps
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;35297&lt;/span&gt; example-jetty-1.0-SNAPSHOT.jar
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;36051&lt;/span&gt; Jps
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 触发 Checkpoint&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;jcmd &lt;span class=&#34;m&#34;&gt;35297&lt;/span&gt; JDK.checkpoint
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此时，应用控制台会打印类似以下的异常并退出，因为 Jetty 打开了监听端口（一个 Socket 文件描述符），而我们没有处理它：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;An exception during a checkpoint operation:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;jdk.internal.crac.mirror.CheckpointException
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Suppressed: jdk.internal.crac.mirror.impl.CheckpointOpenSocketException: sun.nio.ch.ServerSocketChannelImpl&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;/&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0:0:0:0:0:0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;:8080&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		at java.base/jdk.internal.crac.JDKSocketResourceBase.lambda&lt;span class=&#34;nv&#34;&gt;$beforeCheckpoint$0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;JDKSocketResourceBase.java:68&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		at java.base/jdk.internal.crac.mirror.Core.checkpointRestore1&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;Core.java:170&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		at java.base/jdk.internal.crac.mirror.Core.checkpointRestore&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;Core.java:315&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		at java.base/jdk.internal.crac.mirror.Core.checkpointRestoreInternal&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;Core.java:328&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;实现 Resource 接口&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们需要让 &lt;code&gt;ServerManager&lt;/code&gt; 实现 &lt;code&gt;Resource&lt;/code&gt; 接口，在 Checkpoint 前停止 Jetty 服务器（关闭 Socket），在 Restore 后重新启动它。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;org.crac.Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;org.crac.Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;org.crac.Resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;beforeCheckpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Stop the connectors only and keep the expensive application running&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;asList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getConnectors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;forEach&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LifeCycle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;afterRestore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;asList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getConnectors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;forEach&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LifeCycle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;将 &lt;code&gt;Resource&lt;/code&gt; 注册到一个 &lt;code&gt;Context&lt;/code&gt; 中，该 &lt;code&gt;Context&lt;/code&gt; 将调用 &lt;code&gt;Resource&lt;/code&gt; 的方法作为通知。有一个全局的 &lt;code&gt;Context&lt;/code&gt; 可以作为默认选择。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;		&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getGlobalContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;再次尝试 Checkpoint (预期成功)&lt;/strong&gt;&lt;br&gt;
重新编译并运行应用&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ mvn  clean package  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ java -XX:CRaCCheckpointTo&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr -jar target/example-jetty-1.0-SNAPSHOT.jar
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;访问 &lt;code&gt;http://localhost:8080&lt;/code&gt; 进行预热。然后再次触发 Checkpoint：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ jcmd &amp;lt;pid&amp;gt; JDK.checkpoint
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这次，你应该在应用控制台看到类似输出，表明 Jetty 被停止，然后 Checkpoint 被创建，最后原始 JVM 被杀死：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;INFO: Starting checkpoint
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2025-04-28 02:42:16.653:INFO:oejs.AbstractConnector:Attach Listener: Stopped ServerConnector@270421f5&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;HTTP/1.1, &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;http/1.1&lt;span class=&#34;o&#34;&gt;)}{&lt;/span&gt;0.0.0.0:8080&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;42035&lt;/span&gt; killed     java -XX:CRaCCheckpointTo&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr -jar target/example-jetty-1.0-SNAPSHOT.jar
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;同时，在 &lt;code&gt;cr&lt;/code&gt; 目录下会生成 Checkpoint 镜像文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ls cr                                                                                                                                                   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42035.img  core-42045.img  core-42081.img  core-42092.img  core-42426.img  core-42436.img  core-42446.img     pstree.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42036.img  core-42046.img  core-42082.img  core-42093.img  core-42427.img  core-42437.img  dump4.log          seccomp.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42037.img  core-42047.img  core-42083.img  core-42094.img  core-42428.img  core-42438.img  fdinfo-2.img       stats-dump
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42038.img  core-42048.img  core-42084.img  core-42116.img  core-42429.img  core-42439.img  files.img          timens-0.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42039.img  core-42049.img  core-42085.img  core-42119.img  core-42430.img  core-42440.img  fs-42035.img       tty-info.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42040.img  core-42050.img  core-42086.img  core-42121.img  core-42431.img  core-42441.img  ids-42035.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42041.img  core-42051.img  core-42088.img  core-42422.img  core-42432.img  core-42442.img  inventory.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42042.img  core-42052.img  core-42089.img  core-42423.img  core-42433.img  core-42443.img  mm-42035.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42043.img  core-42079.img  core-42090.img  core-42424.img  core-42434.img  core-42444.img  pagemap-42035.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42044.img  core-42080.img  core-42091.img  core-42425.img  core-42435.img  core-42445.img  pages-1.img
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;从 Checkpoint 恢复&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;-XX:CRaCRestoreFrom&lt;/code&gt; 参数启动一个新的 JVM 实例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ java -XX:CRaCRestoreFrom&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2025-04-28 02:46:57.664:INFO:oejs.AbstractConnector:Attach Listener: Started ServerConnector@270421f5&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;HTTP/1.1, &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;http/1.1&lt;span class=&#34;o&#34;&gt;)}{&lt;/span&gt;0.0.0.0:8080&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;现在，你可以再次访问 &lt;code&gt;http://localhost:8080&lt;/code&gt;，应用应该能够正常响应。&lt;/p&gt;
&lt;p&gt;查看进程的父子关系：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ps axfo pid,ppid,command
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;31809&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;31807&lt;/span&gt;  &lt;span class=&#34;se&#34;&gt;\_&lt;/span&gt; sshd: mazhen &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;priv&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;31830&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;31809&lt;/span&gt;      &lt;span class=&#34;se&#34;&gt;\_&lt;/span&gt; sshd: mazhen@pts/0,pts/1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;31831&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;31830&lt;/span&gt;          &lt;span class=&#34;se&#34;&gt;\_&lt;/span&gt; -zsh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;44224&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;31831&lt;/span&gt;          &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;   &lt;span class=&#34;se&#34;&gt;\_&lt;/span&gt; /home/mazhen/21.0.5.crac/lib/criuengine restorewait
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;42035&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;44224&lt;/span&gt;          &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;       &lt;span class=&#34;se&#34;&gt;\_&lt;/span&gt; java -XX:CRaCCheckpointTo&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr -jar target/example-jetty-1.0-SNAPSHOT.jar
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;和前面 CRaC 实现原理分析一致，恢复的 JVM 进程是 &lt;code&gt;criuengine&lt;/code&gt; 的子进程。&lt;/p&gt;
&lt;h3 id=&#34;注意事项&#34;&gt;
    &lt;a href=&#34;#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    注意事项
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;架构与环境限制&lt;/strong&gt;
CRaC 的 Checkpoint 和 Restore &lt;strong&gt;必须在相同的 CPU 架构&lt;/strong&gt;（例如，都是 x64 或都是 ARM64）上进行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，它目前主要依赖 &lt;strong&gt;Linux&lt;/strong&gt; 操作系统和特定的支持 CRaC 的 JDK 构建版本（如 Azul Zulu CRaC builds, Apusic JDK with CRaC Support 等）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统时钟变化&lt;/strong&gt;
应用程序需要注意，从 Checkpoint 到 Restore 之间可能存在显著的&lt;strong&gt;系统时钟跳跃&lt;/strong&gt;。对于依赖时间的逻辑（如缓存过期、定时任务、同步机制），可能需要在 afterRestore 回调中进行校准或特殊处理，以避免因时间差导致的行为异常。虽然 OpenJDK CRaC 内部会尝试校准 System.nanoTime()，但应用层面的时间敏感逻辑仍需开发者关注。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;幂等性&lt;/strong&gt;
&lt;code&gt;beforeCheckpoint&lt;/code&gt; 和 &lt;code&gt;afterRestore&lt;/code&gt; 的实现应该是幂等的，即多次调用也应该产生相同的结果或无副作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安全性&lt;/strong&gt;
Checkpoint 镜像包含了 JVM 进程的完整内存状态，可能包含敏感数据（如密码、密钥、用户数据等）。必须像对待生产数据库备份一样，妥善保管 Checkpoint 文件，控制访问权限。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五crac-的应用场景与生态&#34;&gt;
    &lt;a href=&#34;#%e4%ba%94crac-%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e4%b8%8e%e7%94%9f%e6%80%81&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    五、CRaC 的应用场景与生态
&lt;/h2&gt;&lt;p&gt;CRaC 技术以其显著缩短启动时间和实现即时峰值性能的优势，在多个领域展现出巨大的应用潜力，并且其生态系统正在逐步发展壮大。&lt;/p&gt;
&lt;h3 id=&#34;理想应用场景&#34;&gt;
    &lt;a href=&#34;#%e7%90%86%e6%83%b3%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    理想应用场景
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Serverless Functions (FaaS)&lt;/strong&gt;
这是 CRaC 最典型的应用场景之一。Serverless 函数的冷启动延迟是影响用户体验和成本的关键因素。CRaC 可以将函数的启动时间从秒级降低到毫秒级，极大地改善冷启动性能，使得 Java 在 Serverless 领域更具竞争力。AWS Lambda SnapStart 就是基于类似 CRaC 的技术实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微服务&lt;/strong&gt;
在微服务架构中，服务实例需要频繁地启动、停止和水平扩展。CRaC 可以显著加快新服务实例的启动速度，提高自动伸缩（Auto-scaling）的响应能力和效率，尤其是在应对突发流量时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;批处理作业&lt;/strong&gt;
对于需要快速启动、执行任务然后退出的批处理作业，CRaC 可以消除大部分启动开销，提高作业执行效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资源受限环境&lt;/strong&gt;
在内存或 CPU 资源受限的环境中，CRaC 通过避免启动和预热阶段的高资源消耗，有助于更高效地利用资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;框架与平台支持&#34;&gt;
    &lt;a href=&#34;#%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%b9%b3%e5%8f%b0%e6%94%af%e6%8c%81&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    框架与平台支持
&lt;/h3&gt;&lt;p&gt;随着 CRaC 技术的发展，越来越多的 Java 框架和平台开始提供对其的支持，以简化开发者的使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring Framework / Spring Boot&lt;/strong&gt;
从 Spring Framework 6.1 和 Spring Boot 3.2 开始，提供了对 CRaC 的官方支持。开发者可以通过简单的配置（例如 &lt;code&gt;-Dspring.context.checkpoint=onRefresh&lt;/code&gt;）实现应用启动时的自动 Checkpoint，或者手动触发 Checkpoint 以包含更完整的应用状态。Spring 会自动处理内部管理的资源（如数据库连接池、消息监听器等）的 CRaC 回调。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Micronaut&lt;/strong&gt;
Micronaut 框架提供了专门的 micronaut-crac 模块，可以方便地集成 CRaC 支持。它内置了对常见资源（如 Hikari 数据源、Redis 连接）的协调处理。Micronaut 的构建插件（如 Gradle 插件）甚至可以一键生成包含 CRaC 镜像的 Docker 镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Quarkus&lt;/strong&gt;
Quarkus 从 2.10.0 版本开始内置了对 CRaC 的基本支持。利用 Quarkus 的构建时优化和 CRaC 的运行时恢复能力，可以进一步提升应用的启动性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AWS Lambda SnapStart&lt;/strong&gt;
虽然底层实现细节未完全公开，但 AWS Lambda 的 SnapStart 功能在原理和效果上与 CRaC 非常相似，它允许用户为 Lambda 函数创建快照，并在调用时快速恢复，显著降低 Java Lambda 函数的冷启动延迟。这表明 CRaC 的理念已经在主流云平台上得到了应用和验证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Azul Zulu Builds of OpenJDK&lt;/strong&gt;
Azul 作为 CRaC 技术的主要推动者之一，提供了包含 CRaC 功能的 OpenJDK 发行版（Zulu），支持 Linux/x64 和 Linux/ARM64 平台，并为 Windows 和 macOS 提供用于开发和测试的模拟版本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;crac-部署方案&#34;&gt;
    &lt;a href=&#34;#crac-%e9%83%a8%e7%bd%b2%e6%96%b9%e6%a1%88&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 部署方案
&lt;/h3&gt;&lt;p&gt;CRaC 的部署方案旨在收集 Java 应用程序初始化和预热所需的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504281423303.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;flow&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;在金丝雀环境中部署并预热应用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;将 Java 应用程序部署到金丝雀（canary）测试环境中。&lt;/li&gt;
&lt;li&gt;应用程序处理金丝雀请求，这会触发类加载和 JIT 编译，从而完成预热。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建 Checkpoint&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;对正在运行的应用程序进行 Checkpoint 操作。&lt;/li&gt;
&lt;li&gt;这将创建 JVM 和应用程序的镜像（image），该镜像被视为新部署包的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在生产环境中部署和恢复&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;将带有镜像的 Java 应用程序部署到生产环境中。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;-XX:CRaCRestoreFrom=PATH&lt;/code&gt; 选项从镜像恢复 Java 进程。&lt;/li&gt;
&lt;li&gt;恢复后的 Java 进程将直接使用镜像中已加载的类和 JIT 代码，从而实现快速启动和即时达到最佳性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;性能基准&#34;&gt;
    &lt;a href=&#34;#%e6%80%a7%e8%83%bd%e5%9f%ba%e5%87%86&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    性能基准
&lt;/h3&gt;&lt;p&gt;由 Java 社区及主流框架开发者进行的广泛性能基准测试一致表明，CRaC (Coordinated Restore at Checkpoint) 技术能够为 Java 应用带来显著的性能提升，尤其在启动速度方面表现突出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504281408920.webp&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;crac&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对于常见的 Web 应用程序，例如基于 Spring Boot、Micronaut 或 Quarkus 构建的应用，采用 CRaC 的恢复机制可以将原先需要数秒的启动过程，&lt;strong&gt;缩短至几十毫秒级别&lt;/strong&gt;。这意味着应用能够更快地进入服务状态，提升用户体验和资源利用率。&lt;/p&gt;
&lt;p&gt;为了具体展示 CRaC 的效果，我对 Glassfish 7 进行了 CRaC 的改造适配。在部署了标准 Spring PetClinic 应用的场景下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;常规启动耗时：&lt;/strong&gt; 通过标准 &lt;code&gt;./bin/asadmin start-domain&lt;/code&gt; 命令启动，完成整个启动过程需要 &lt;strong&gt;8.813 秒&lt;/strong&gt; (8813 毫秒)。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./bin/asadmin start-domain
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Waiting &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; domain1 to start ........
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Waiting finished after 8,813 ms.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Successfully started the domain : domain1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;domain  Location: /home/mazhen/works/glassfish7/glassfish/domains/domain1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Log File: /home/mazhen/works/glassfish7/glassfish/domains/domain1/logs/server.log
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Admin Port: 4,848
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Command start-domain executed successfully.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CRaC 恢复耗时：&lt;/strong&gt; 从预先生成的 CRaC 快照 (checkpoint) 文件恢复，使用 &lt;code&gt;java -XX:CRaCRestoreFrom=cr&lt;/code&gt; 命令，启动过程&lt;strong&gt;仅需约 36.88 毫秒&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ java -XX:CRaCRestoreFrom&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.559868Z|INFO|GF 7.0.23-SNAPSHOT|jakarta.enterprise.logging.stdout|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  STARTUPTIME &lt;span class=&#34;m&#34;&gt;519895593501838&lt;/span&gt; restore&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.571942Z|INFO|GF 7.0.23-SNAPSHOT|org.glassfish.grizzly.config.GenericGrizzlyListener|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  After restore, start transport, &lt;span class=&#34;nv&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/0.0.0.0, &lt;span class=&#34;nv&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;8080&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.572851Z|INFO|GF 7.0.23-SNAPSHOT|org.glassfish.grizzly.config.GenericGrizzlyListener|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  After restore, start transport, &lt;span class=&#34;nv&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/0.0.0.0, &lt;span class=&#34;nv&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;8181&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.573165Z|INFO|GF 7.0.23-SNAPSHOT|org.glassfish.grizzly.config.GenericGrizzlyListener|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  After restore, start transport, &lt;span class=&#34;nv&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/0.0.0.0, &lt;span class=&#34;nv&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;4848&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.573409Z|INFO|GF 7.0.23-SNAPSHOT|org.glassfish.grizzly.config.GenericGrizzlyListener|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  After restore, start transport, &lt;span class=&#34;nv&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/0.0.0.0, &lt;span class=&#34;nv&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;3700&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.607504Z|INFO|GF 7.0.23-SNAPSHOT|jakarta.enterprise.logging.stdout|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  STARTUPTIME &lt;span class=&#34;m&#34;&gt;519895630386924&lt;/span&gt; restore-finish&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;恢复时间计算：&lt;code&gt;restore-finish - restore&lt;/code&gt;，恢复过程耗时为 &lt;code&gt;519895630386924 - 519895593501838 = 36,885,086&lt;/code&gt; 纳秒，即 &lt;strong&gt;36.88 毫秒&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对比结果清晰显示，使用 CRaC 恢复，启动时间缩短了约 239 倍 (8813 ms / 36.88 ms)，实现了数量级的性能飞跃。&lt;/p&gt;
&lt;p&gt;除了惊人的启动速度提升，CRaC 更为核心的优势在于实现了“即时峰值性能”。与传统启动方式不同，恢复后的应用程序&lt;strong&gt;几乎可以瞬间达到其完全预热 (warmed-up) 后的最佳运行性能&lt;/strong&gt;。这是因为它跳过了耗时的类加载、初始化以及 JIT (Just-In-Time) 编译器的早期编译和优化阶段。对于需要快速响应负载变化、频繁弹性伸缩或要求低延迟的场景 (如 Serverless、微服务快速扩容)，这一特性具有极其重要的价值。&lt;/p&gt;
&lt;h3 id=&#34;未来展望生态持续完善&#34;&gt;
    &lt;a href=&#34;#%e6%9c%aa%e6%9d%a5%e5%b1%95%e6%9c%9b%e7%94%9f%e6%80%81%e6%8c%81%e7%bb%ad%e5%ae%8c%e5%96%84&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    未来展望：生态持续完善
&lt;/h3&gt;&lt;p&gt;随着 OpenJDK 对 CRaC 项目的持续推进和标准化，以及越来越多第三方库、框架（如 Spring、Micronaut、Quarkus、Open Liberty 等）的积极适配与集成，CRaC 的生态系统正逐步成熟和完善。这预示着未来在 Java 应用中利用 Checkpoint/Restore 技术将变得更加便捷和普遍，有望成为提升 Java 应用启动性能和运行时效率的标准实践之一。&lt;/p&gt;
&lt;h2 id=&#34;六apusic-jdk-with-crac-support&#34;&gt;
    &lt;a href=&#34;#%e5%85%adapusic-jdk-with-crac-support&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    六、Apusic JDK with CRaC Support
&lt;/h2&gt;&lt;p&gt;Apusic JDK 是金蝶天燕（Apusic）公司基于 OpenJDK 项目构建和维护的 Java 开发工具包（JDK）发行版。为了满足用户对高性能和快速启动的需求，Apusic JDK 团队积极跟进社区前沿技术，并提供了对主流 LTS 版本的广泛支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基于 BiSheng JDK&lt;/strong&gt;
Apusic JDK 的上游是华为公司开源的 BiSheng JDK。BiSheng JDK 本身在 OpenJDK 的基础上进行了性能优化和特性增强，Apusic JDK 继承了这些优势，并结合自身在中间件领域的深厚积累，为企业级应用提供了稳定、高效的 Java 运行时环境。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持多 LTS 版本&lt;/strong&gt;
Apusic JDK 致力于提供稳定可靠的 Java 环境，目前为 &lt;strong&gt;Java 8, 11, 17, 21&lt;/strong&gt; 等多个长期支持（LTS）版本提供构建和支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为 JDK 17 和 21 引入 CRaC 支持&lt;/strong&gt;
Apusic 团队认识到 CRaC（Coordinated Restore at Checkpoint）技术在解决 Java 应用冷启动慢和提升运行时效率方面具有巨大潜力。然而，由于 CRaC 项目尚未正式合并到 OpenJDK 主线，Apusic 采用了与 Azul 等厂商类似的方式，&lt;strong&gt;主动将其核心功能移植（Port）并集成到了 Apusic JDK 17 和 Apusic JDK 21 发行版中&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提供特定版本的双重发行版&lt;/strong&gt;
为了方便用户根据实际需求进行选择，针对集成了 CRaC 功能的 &lt;strong&gt;JDK 17 和 JDK 21&lt;/strong&gt;，Apusic 提供了两种发行版：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标准的 Apusic JDK (17 / 21)&lt;/strong&gt; ：不包含 CRaC 功能，适用于不需要 Checkpoint/Restore 特性的标准 Java 应用场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Apusic JDK with CRaC Support (17 / 21)&lt;/strong&gt; ：内置了 CRaC 功能的特殊版本。用户可以使用这个版本来开发、测试和部署需要利用 CRaC 进行启动优化的 Java 应用程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过提供带有 CRaC 支持的 JDK 版本（目前为 JDK 17 和 21），Apusic 使得其用户能够在其熟悉的 JDK 发行版上，提前体验和应用 CRaC 技术带来的显著优势，特别是在微服务、Serverless 等对启动速度有严苛要求的场景下，能够获得明显的性能提升。用户在使用 Apusic JDK with CRaC Support 时，可以遵循 CRaC 的标准使用方法和最佳实践。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
