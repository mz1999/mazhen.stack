<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Performance on mazhen.tech</title>
        <link>https://mazhen.tech/tags/performance/</link>
        <description>Recent content in Performance on mazhen.tech</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 20 Jun 2025 11:10:02 +0800</lastBuildDate><atom:link href="https://mazhen.tech/tags/performance/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Perf 的 cpu-clock 与 cpu-cycles 采样实现与对比</title>
        <link>https://mazhen.tech/p/perf-%E7%9A%84-cpu-clock-%E4%B8%8E-cpu-cycles-%E9%87%87%E6%A0%B7%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%AF%94/</link>
        <pubDate>Fri, 20 Jun 2025 11:10:02 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/perf-%E7%9A%84-cpu-clock-%E4%B8%8E-cpu-cycles-%E9%87%87%E6%A0%B7%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%AF%94/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202506201359538.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Feature image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在上一篇&lt;a class=&#34;link&#34; href=&#34;https://mazhen.tech/p/wall-clock-%E4%B8%8E-cpu-cycles-%E9%87%87%E6%A0%B7%E7%9A%84%E5%8C%BA%E5%88%AB/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;博客&lt;/a&gt;中，我们深入探讨了性能分析中两个概念：&lt;strong&gt;Wall-Clock 采样&lt;/strong&gt;与 &lt;strong&gt;CPU-Cycles 采样&lt;/strong&gt;的本质区别。这一次我想使用 &lt;code&gt;perf&lt;/code&gt; 这个强大的工具来验证上一篇的内容。&lt;/p&gt;
&lt;p&gt;对于 &lt;strong&gt;CPU-Cycles 采样&lt;/strong&gt;，路径非常明确：&lt;code&gt;perf record -e cycles&lt;/code&gt;，或者干脆不带 &lt;code&gt;-e&lt;/code&gt; 参数时，默认使用的就是这种基于硬件的 On-CPU 分析。&lt;/p&gt;
&lt;p&gt;但问题来了：如何用 &lt;code&gt;perf&lt;/code&gt; 实现 Wall-Clock 采样呢？&lt;/p&gt;
&lt;p&gt;一个看似可能的答案是 &lt;code&gt;cpu-clock&lt;/code&gt; 软件事件。然而，&lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/perf_event_open.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;对它的描述只有一句，语焉不详：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This reports the CPU clock, a high-resolution per-CPU timer.&lt;/p&gt;
&lt;p&gt;报告提供 CPU 时钟信息，即一种高精度的每 CPU 计时器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我尝试用各种 AI DeepResearch 一番，仍然没有找到答案，而且发现自己之前写的那篇&lt;a class=&#34;link&#34; href=&#34;https://mazhen.tech/p/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2-perf-cpu-profiling-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《深入探索 perf CPU Profiling 实现原理》&lt;/a&gt;竟排在参考引用文档列表中很高的位置。同时，另一位知名开发者 Robert Haas（PostgreSQL 的核心贡献者）也曾&lt;a class=&#34;link&#34; href=&#34;https://rhaas.blogspot.com/2012/06/perf-good-bad-ugly.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;抱怨过&lt;/a&gt; &lt;code&gt;cpu-clock&lt;/code&gt; 缺乏文档说明。&lt;/p&gt;
&lt;p&gt;既然现有的资料无法给出确切答案，唯一的办法就是到 Linux 内核源码中找答案，搞清楚 &lt;code&gt;cpu-clock&lt;/code&gt; 和 &lt;code&gt;cycles&lt;/code&gt; 这对采样事件，究竟在底层是如何实现的，也算给 AI 贡献一些原创素材。&lt;/p&gt;
&lt;h2 id=&#34;深入内核两种采样事件的实现&#34;&gt;
    &lt;a href=&#34;#%e6%b7%b1%e5%85%a5%e5%86%85%e6%a0%b8%e4%b8%a4%e7%a7%8d%e9%87%87%e6%a0%b7%e4%ba%8b%e4%bb%b6%e7%9a%84%e5%ae%9e%e7%8e%b0&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    深入内核：两种采样事件的实现
&lt;/h2&gt;&lt;h3 id=&#34;cpu-clock-的实现&#34;&gt;
    &lt;a href=&#34;#cpu-clock-%e7%9a%84%e5%ae%9e%e7%8e%b0&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    &lt;code&gt;cpu-clock&lt;/code&gt; 的实现
&lt;/h3&gt;&lt;p&gt;通过内核源码 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/master/kernel/events/core.c&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;kernel/events/core.c&lt;/a&gt;，我们可以分析出 &lt;code&gt;cpu-clock&lt;/code&gt; 事件实现的核心逻辑，它的实现依赖于 Linux 的高精度定时器（&lt;code&gt;hrtimer&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;整个流程可以概括为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;：当一个 &lt;code&gt;cpu-clock&lt;/code&gt; 事件被创建时，&lt;code&gt;cpu_clock_event_init()&lt;/code&gt; 会调用 &lt;code&gt;perf_swevent_init_hrtimer()&lt;/code&gt;。这会在每个被监控的 CPU 上设置一个周期性的 &lt;code&gt;hrtimer&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定时中断&lt;/strong&gt;：这个 &lt;code&gt;hrtimer&lt;/code&gt; 会以我们指定的频率（例如 &lt;code&gt;-F 99&lt;/code&gt; 就是 99Hz）周期性地触发一个硬件中断。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断处理&lt;/strong&gt;：中断会激活 &lt;code&gt;perf_swevent_hrtimer()&lt;/code&gt; 这个处理函数。在这个函数里，内核会判断事件是否需要记录样本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;样本采集&lt;/strong&gt;：如果需要，它会调用 &lt;code&gt;__perf_event_overflow()&lt;/code&gt;，最终触发 &lt;code&gt;overflow_handler&lt;/code&gt;（如 &lt;code&gt;perf_event_output_forward&lt;/code&gt;），后者会收集当前上下文的数据（如调用栈、寄存器等），打包成一个 &lt;code&gt;PERF_RECORD_SAMPLE&lt;/code&gt;，然后写入 Ring Buffer。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单来说，&lt;strong&gt;&lt;code&gt;cpu-clock&lt;/code&gt; 是一个纯粹的软件事件，使用 hrtimer 周期性地触发一个中断，中断处理函数负责生成并记录一个样本。&lt;/strong&gt; 它就像一个设定的闹钟，每隔固定的时间就响一次，然后记录下那个瞬间 CPU 正在处理的任务。&lt;/p&gt;
&lt;h3 id=&#34;cpu-cycles-的实现&#34;&gt;
    &lt;a href=&#34;#cpu-cycles-%e7%9a%84%e5%ae%9e%e7%8e%b0&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    &lt;code&gt;cpu-cycles&lt;/code&gt; 的实现
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;cpu-cycles&lt;/code&gt; 是一个硬件事件，它直接利用 CPU 内部的性能监控单元（PMU）来统计 CPU 时钟周期，它的实现与 &lt;code&gt;cpu-clock&lt;/code&gt; 软件事件有本质区别。&lt;/p&gt;
&lt;p&gt;以  x86 平台上为例，&lt;code&gt;cpu-cycles&lt;/code&gt; 事件的实现在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/master/arch/x86/events/core.c&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;arch/x86/events/core.c&lt;/a&gt; 文件中，我们可以看到它的实现与硬件紧密耦合。整体流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化与编程&lt;/strong&gt;：当一个 &lt;code&gt;cpu-cycles&lt;/code&gt; 事件被创建时，&lt;code&gt;x86_pmu_event_init()&lt;/code&gt; 会将这个通用事件类型映射为一个特定的硬件事件编码。事件被启用时，调度器（&lt;code&gt;x86_schedule_events&lt;/code&gt;）会为其分配一个可用的硬件性能计数器（PMC）。内核通过 &lt;code&gt;wrmsr&lt;/code&gt; 指令将事件编码写入 &lt;code&gt;PerfEvtSel&lt;/code&gt; 寄存器，并设置 &lt;code&gt;PMC&lt;/code&gt; 寄存器的初始值为一个负数（例如 &lt;code&gt;-sample_period&lt;/code&gt;），然后启动该计数器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;硬件计数&lt;/strong&gt;：CPU 硬件开始自动对每个时钟周期进行计数。&lt;code&gt;PMC&lt;/code&gt; 的值从初始的负数开始，每个周期加一，向零逼近。这个过程完全由硬件执行，没有软件开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;硬件中断 (PMI)&lt;/strong&gt;：当硬件计数器从 &lt;code&gt;0xFFFF...&lt;/code&gt; 溢出到 &lt;code&gt;0&lt;/code&gt; 时，PMU 会自动触发一个&lt;strong&gt;性能监控中断（PMI）&lt;/strong&gt;。在 x86 平台上，这通常是一个&lt;strong&gt;不可屏蔽中断（NMI）&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中断处理&lt;/strong&gt;：NMI 会激活 &lt;code&gt;perf_event_nmi_handler()&lt;/code&gt;，它会调用特定于 PMU 的中断处理函数（如 &lt;code&gt;x86_pmu.handle_irq&lt;/code&gt;）。此函数会：
a.  &lt;strong&gt;识别溢出&lt;/strong&gt;：检查是哪个 &lt;code&gt;PMC&lt;/code&gt; 发生了溢出。
b.  &lt;strong&gt;重置计数器&lt;/strong&gt;：调用 &lt;code&gt;x86_perf_event_set_period()&lt;/code&gt; 将该 &lt;code&gt;PMC&lt;/code&gt; 的值重新设置为初始的负数，为下一次采样做准备。
c.  &lt;strong&gt;样本采集&lt;/strong&gt;：调用 &lt;code&gt;perf_event_overflow()&lt;/code&gt;，最终触发 &lt;code&gt;overflow_handler&lt;/code&gt;（如 &lt;code&gt;perf_event_output_forward&lt;/code&gt;），后者会收集当前上下文的数据（如调用栈、寄存器等），打包成一个 &lt;code&gt;PERF_RECORD_SAMPLE&lt;/code&gt;，然后写入 Ring Buffer。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;简而言之，&lt;code&gt;cpu-cycles&lt;/code&gt; 是一个硬件事件。&lt;/strong&gt; 它不像闹钟，更像一个只在工作时才计数的“计步器”。它关心的是 &lt;strong&gt;CPU 完成的工作量&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;它们采集了哪些数据&#34;&gt;
    &lt;a href=&#34;#%e5%ae%83%e4%bb%ac%e9%87%87%e9%9b%86%e4%ba%86%e5%93%aa%e4%ba%9b%e6%95%b0%e6%8d%ae&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    它们采集了哪些数据？
&lt;/h3&gt;&lt;p&gt;无论是哪种方式触发了采样，最终内核都会通过 &lt;code&gt;perf_prepare_sample()&lt;/code&gt; 和 &lt;code&gt;perf_output_sample()&lt;/code&gt; 这一系列的函数，将当时的“现场快照”打包成一个 &lt;code&gt;PERF_RECORD_SAMPLE&lt;/code&gt; 记录。这份快照通常包含（取决于你的 &lt;code&gt;-g&lt;/code&gt; 和其他 &lt;code&gt;perf&lt;/code&gt; 参数）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;指令指针 (IP)&lt;/strong&gt;: CPU 当时正在执行哪一条指令的地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程 ID 和线程 ID (PID/TID)&lt;/strong&gt;: 是哪个进程/线程在执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间戳 (Time)&lt;/strong&gt;: 采样发生的时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU 编号&lt;/strong&gt;: 在哪个 CPU 核心上发生的采样。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用链 (Callchain)&lt;/strong&gt;: 这是通过 &lt;code&gt;-g&lt;/code&gt; 参数启用的。内核会从当前的栈帧指针（Frame Pointer）开始，回溯整个调用栈，记录下从当前函数到顶层函数的完整路径。对于系统调用，它能同时抓取到用户栈和内核栈，拼接成一个完整的调用链。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他元数据&lt;/strong&gt;: 如事件周期、地址信息等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正是这些丰富的数据，让我们能够在事后通过 &lt;code&gt;perf report&lt;/code&gt; 或火焰图，重构出程序的运行画像。&lt;/p&gt;
&lt;h3 id=&#34;两个事件的对比&#34;&gt;
    &lt;a href=&#34;#%e4%b8%a4%e4%b8%aa%e4%ba%8b%e4%bb%b6%e7%9a%84%e5%af%b9%e6%af%94&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    两个事件的对比
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;特性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;code&gt;cpu-clock&lt;/code&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;code&gt;cpu-cycles&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;事件源&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;软件 (内核 &lt;code&gt;hrtimer&lt;/code&gt;)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;硬件 (CPU PMU)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;触发机制&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;固定&lt;strong&gt;时间&lt;/strong&gt;间隔到达，触发定时器中断&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;固定&lt;strong&gt;工作量&lt;/strong&gt;完成，触发 PMC 溢出中断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;CPU 空闲时&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;计时器&lt;strong&gt;继续&lt;/strong&gt;运行，会采样到&lt;code&gt;idle&lt;/code&gt;任务&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;计数器&lt;strong&gt;暂停&lt;/strong&gt;，不会产生任何采样&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;动手验证&#34;&gt;
    &lt;a href=&#34;#%e5%8a%a8%e6%89%8b%e9%aa%8c%e8%af%81&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    动手验证
&lt;/h2&gt;&lt;p&gt;理论分析之后，我们需要一个实验来直观地感受这种差异。一个好的实验，应该能创造出极端的对比场景，直观的展示出两种采样方式的差异。&lt;/p&gt;
&lt;p&gt;我的思路是构建一个“脉冲式”的负载模型，让程序在两种截然不同的状态间切换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU 饱和阶段&lt;/strong&gt;: 计算密集型，消耗系统所有的 CPU 资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空闲阶段&lt;/strong&gt;: 程序进入长时间的休眠，让所有 CPU 核心休息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实验程序&#34;&gt;
    &lt;a href=&#34;#%e5%ae%9e%e9%aa%8c%e7%a8%8b%e5%ba%8f&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    实验程序
&lt;/h3&gt;&lt;p&gt;实验程序是一个多线程 C 程序 &lt;code&gt;work_and_wait_mt.c&lt;/code&gt;，它会创建与核心数相同的工作线程，所有线程通过屏障（barrier）同步，同时开始计算，同时结束计算，实现“集体计算 100 毫秒，集体休眠 900 毫秒”的脉冲式负载。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdbool.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// --- Configuration ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;burn_time_ms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;idle_time_ms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;900&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;total_cycles&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;multiplier&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;200000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// **重要**: 请先用单线程校准这个值！
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// --- Globals for thread coordination ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;pthread_barrier_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;barrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;time_to_exit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// CPU 密集型计算函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;__attribute__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;noinline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;burn_cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;milliseconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;milliseconds&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;multiplier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// Burn baby burn
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 工作线程的执行函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;worker_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thread_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Worker thread %d started.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thread_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time_to_exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 1. 等待主线程的“开始计算”信号
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;//    所有工作线程和主线程都会在此集合
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;pthread_barrier_wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;barrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 如果是退出信号，则跳出循环
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time_to_exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 2. 执行计算任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;burn_cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;burn_time_ms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 3. 等待所有其他工作线程完成计算
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;//    主线程也在此等待，以确认计算阶段结束
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;pthread_barrier_wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;barrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Worker thread %d exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thread_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 自动检测可用的 CPU 核心数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_cores&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sysconf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_SC_NPROCESSORS_ONLN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_cores&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;num_cores&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 备用值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Detected %ld CPU cores.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_cores&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// +1 是因为主线程也要参与屏障同步
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;pthread_barrier_init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;barrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_cores&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;pthread_t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threads&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;malloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_cores&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;pthread_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thread_ids&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;malloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_cores&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 创建工作线程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_cores&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;thread_ids&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;pthread_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;threads&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;worker_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thread_ids&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;Starting multi-threaded workload...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;----------------------------------------------------------&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;total_cycles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Cycle %d/%d: Orchestrating CPU burn...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;total_cycles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 1. 主线程到达屏障，释放所有等待的 worker 线程开始计算
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;pthread_barrier_wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;barrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 2. 主线程也在此等待，直到所有 worker 线程都完成计算
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;pthread_barrier_wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;barrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Cycle %d/%d: Orchestrating idle period...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;total_cycles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;usleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idle_time_ms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;----------------------------------------------------------&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Workload finished. Signaling threads to exit.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 通知所有线程退出
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;time_to_exit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 最后一次释放屏障，让所有在等待的线程可以检查到退出标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;pthread_barrier_wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;barrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 等待所有线程结束并清理资源
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_cores&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;pthread_join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;threads&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;pthread_barrier_destroy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;barrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;threads&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thread_ids&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在编写和测试这样的程序时，有两个细节需要注意。&lt;/p&gt;
&lt;h4 id=&#34;防止函数内联&#34;&gt;
    &lt;a href=&#34;#%e9%98%b2%e6%ad%a2%e5%87%bd%e6%95%b0%e5%86%85%e8%81%94&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    防止函数内联
&lt;/h4&gt;&lt;p&gt;现代编译器非常智能，当你使用 &lt;code&gt;-O2&lt;/code&gt; 等优化选项时，它可能会发现 &lt;code&gt;burn_cpu&lt;/code&gt; 函数非常简单，从而执行&lt;strong&gt;函数内联（Function Inlining）&lt;/strong&gt;——直接把 &lt;code&gt;burn_cpu&lt;/code&gt; 的循环代码“复制 - 粘贴”到调用它的 &lt;code&gt;worker_function&lt;/code&gt; 中。这会导致在 &lt;code&gt;perf&lt;/code&gt; 报告里，我们看不到 &lt;code&gt;burn_cpu&lt;/code&gt; 这个独立的函数，所有的开销都会被算在 &lt;code&gt;worker_function&lt;/code&gt; 头上，这会干扰我们的分析。为了避免这种情况，我们必须明确地告诉编译器不要这么做：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;__attribute__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;noinline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;burn_cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;milliseconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;校准计算强度&#34;&gt;
    &lt;a href=&#34;#%e6%a0%a1%e5%87%86%e8%ae%a1%e7%ae%97%e5%bc%ba%e5%ba%a6&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    校准计算强度
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;burn_cpu&lt;/code&gt; 函数里的循环次数需要根据你的 CPU 性能进行调整。一个固定的循环次数，在我的电脑上可能运行 100 毫秒，在你的高性能服务器上可能只需要 30 毫秒。我们需要一个合适的“乘数（multiplier）”，让 &lt;code&gt;burn_cpu(100)&lt;/code&gt; 能在你的机器上&lt;strong&gt;大致运行 100 毫秒&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我使用了一个简单的校准程序 &lt;code&gt;calibrate.c&lt;/code&gt;，它只包含 &lt;code&gt;burn_cpu(1000)&lt;/code&gt;，然后用 &lt;code&gt;time&lt;/code&gt; 命令来测量其**&lt;code&gt;user&lt;/code&gt;时间**（即 CPU 在用户态的实际耗时）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;burn_cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;milliseconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 这是我们要调整的乘数，先从一个初始值开始
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;multiplier&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;200000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;milliseconds&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;multiplier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// Just burn cycles
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test_duration_ms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 我们期望它运行 1 秒钟
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Burning CPU for a target of %ldms...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test_duration_ms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;burn_cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;test_duration_ms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Calibration burn finished.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;现在，我们编译并使用 &lt;code&gt;time&lt;/code&gt; 命令来测量这个程序的实际运行时间。我们使用 &lt;code&gt;-O2&lt;/code&gt; 优化，这更接近生产环境的编译设置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ gcc -O2 -o calibrate calibrate.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;time&lt;/span&gt; ./calibrate
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;time&lt;/code&gt; 命令会输出类似下面的结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Burning CPU &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; a target of 1000ms...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Calibration burn finished.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;real	0m0.052s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;user	0m0.051s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sys	  0m0.001s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这里的关键是 &lt;strong&gt;&lt;code&gt;user&lt;/code&gt; 时间&lt;/strong&gt;。它表示程序在用户态实际消耗的 CPU 时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;目标时间&lt;/strong&gt;: 1.0 秒 (1000ms)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实际时间&lt;/strong&gt;: 0.051 秒&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这说明我们当前的乘数 &lt;code&gt;200000&lt;/code&gt; 太小了，程序运行得太快。我们可以用一个简单的比例来计算新的乘数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新乘数 = 旧乘数 * (目标时间 / 实际时间)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中：
新乘数 = 200,000 * (1.0 / 0.051) ≈ 200,000 * 19.6 ≈ &lt;strong&gt;3920000&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以取一个整数，比如 &lt;strong&gt;4000000&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在，修改 &lt;code&gt;calibrate.c&lt;/code&gt; 中的乘数为 &lt;code&gt;4000000&lt;/code&gt;，然后再次运行校准测试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ gcc -O2 -o calibrate calibrate.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;time&lt;/span&gt; ./calibrate
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Burning CPU &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; a target of 1000ms...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Calibration burn finished.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;real	0m0.987s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;user	0m0.984s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sys	  0m0.002s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这次的输出 &lt;code&gt;user&lt;/code&gt; 时间应该会非常接近 1.0 秒了，现在就可以用这个新的乘数修改 &lt;code&gt;work_and_wait_mt.c&lt;/code&gt; ，来进行 &lt;code&gt;perf&lt;/code&gt; 对比实验了。&lt;/p&gt;
&lt;h3 id=&#34;编译实验程序&#34;&gt;
    &lt;a href=&#34;#%e7%bc%96%e8%af%91%e5%ae%9e%e9%aa%8c%e7%a8%8b%e5%ba%8f&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    编译实验程序
&lt;/h3&gt;&lt;p&gt;我们使用以下命令进行编译：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcc -g -O2 -o work_and_wait_mt work_and_wait_mt.c -pthread
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-g&lt;/code&gt;: 生成调试信息，这是 &lt;code&gt;perf&lt;/code&gt; 能够将内存地址翻译成函数名的关键。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-O2&lt;/code&gt;: 开启二级优化，这更接近生产环境的编译设置，也使得我们防止内联的操作变得必要。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-pthread&lt;/code&gt;: 链接 &lt;code&gt;pthread&lt;/code&gt; 库，因为我们用到了多线程和屏障。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;执行采样&#34;&gt;
    &lt;a href=&#34;#%e6%89%a7%e8%a1%8c%e9%87%87%e6%a0%b7&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    执行采样
&lt;/h3&gt;&lt;p&gt;现在，我们用两种不同的采样方式，在**系统全局模式（&lt;code&gt;-a&lt;/code&gt;）**下，对这个程序进行分析。&lt;/p&gt;
&lt;p&gt;我们使用系统全局（&lt;code&gt;-a&lt;/code&gt;）模式，以确保能捕获到 &lt;code&gt;idle&lt;/code&gt; 任务。&lt;/p&gt;
&lt;h4 id=&#34;实验一cpu-cycles-事件&#34;&gt;
    &lt;a href=&#34;#%e5%ae%9e%e9%aa%8c%e4%b8%80cpu-cycles-%e4%ba%8b%e4%bb%b6&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    实验一：&lt;code&gt;cpu-cycles&lt;/code&gt; 事件
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;采集数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo perf record -a -F &lt;span class=&#34;m&#34;&gt;99&lt;/span&gt; -g -- ./work_and_wait_mt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;生成报告&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo perf report
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;报告解读&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Samples: 3K of event &lt;span class=&#34;s1&#34;&gt;&amp;#39;cpu_core/cycles/P&amp;#39;&lt;/span&gt;, Event count &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;approx.&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;: &lt;span class=&#34;m&#34;&gt;124421182834&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Children      Self  Command          Shared Object          Symbol
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+   99.28%    99.12%  work_and_wait_m  work_and_wait_mt       &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;.&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; burn_cpu
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.25%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; secondary_startup_64_no_verify
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.25%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; cpu_startup_entry
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.25%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; do_idle
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.20%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; start_secondary
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.19%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; asm_sysvec_apic_timer_interrupt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.19%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; cpuidle_idle_call
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.16%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; sysvec_apic_timer_interrupt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.16%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; __sysvec_apic_timer_interrupt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.16%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; hrtimer_interrupt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.16%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; __hrtimer_run_queues
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.16%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; tick_nohz_highres_handler
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.16%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; tick_sched_handle
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.16%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; update_process_times
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.16%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; scheduler_tick
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.16%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; task_tick_fair
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.16%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; call_cpuidle
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第一行是报告的标题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Samples: 3K&lt;/strong&gt;: 在程序运行期间，perf 总共捕获了 3000 个样本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;event &amp;lsquo;cpu_core/cycles/P&amp;rsquo;&lt;/strong&gt;: perf 告诉你它采样的是 cycles 事件。这个名字 cpu_core/cycles/P 是一个更具体的硬件事件名称，但本质就是 CPU 时钟周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event count (approx.)&lt;/strong&gt;: 程序在运行时，大约产生了 1 千 2 百亿个 CPU 周期。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来是表格的列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Children&lt;/strong&gt;: &lt;strong&gt;子项开销&lt;/strong&gt;。表示这个函数&lt;strong&gt;以及它调用的所有子函数&lt;/strong&gt;总共占用的 CPU 时间百分比。可以理解为，当程序执行到这个函数所在的调用链上时，所花费的时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Self&lt;/strong&gt;: &lt;strong&gt;自身开销&lt;/strong&gt;。表示 CPU 时间&lt;strong&gt;只花在这个函数本身内部&lt;/strong&gt;的百分比，不包括它调用的其他函数。这是定位代码热点的最关键指标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Command&lt;/strong&gt;: 运行的命令名 (work_and_wait)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shared Object&lt;/strong&gt;: 该符号所在的库或可执行文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Symbol&lt;/strong&gt;: 函数名或内核符号名。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Self: 99.12%&lt;/strong&gt;，这是最重要的信息。在所有样本中，有 &lt;strong&gt;99.12%&lt;/strong&gt; 的样本都是在 CPU 执行 &lt;code&gt;burn_cpu&lt;/code&gt; 函数内部的指令时捕获的。这清晰地表明，这个函数是程序中唯一的 CPU 性能热点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swapper&lt;/code&gt;（即 idle 任务）在这里也出现了，但它的占比极小，与 &lt;code&gt;burn_cpu&lt;/code&gt; 产生的海量周期相比，这些内核自身的管理开销几乎可以忽略不计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结 cpu-cycles 报告：&lt;/strong&gt; &lt;code&gt;burn_cpu&lt;/code&gt;消耗了 &lt;strong&gt;99.12%&lt;/strong&gt; 的 CPU 算力，&lt;code&gt;perf&lt;/code&gt; 准确地抓住了那个让 CPU 发热的元凶。&lt;strong&gt;&lt;code&gt;swapper&lt;/code&gt;（idle 任务）几乎可以忽略不计&lt;/strong&gt;，证明了 &lt;code&gt;cpu-cycles&lt;/code&gt; 采样在程序休眠时是“暂停”的，它只关心工作，不关心等待。&lt;/p&gt;
&lt;h4 id=&#34;实验二cpu-clock-事件&#34;&gt;
    &lt;a href=&#34;#%e5%ae%9e%e9%aa%8c%e4%ba%8ccpu-clock-%e4%ba%8b%e4%bb%b6&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    实验二：&lt;code&gt;cpu-clock&lt;/code&gt; 事件
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;采集数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo perf record -a -F &lt;span class=&#34;m&#34;&gt;99&lt;/span&gt; -e cpu-clock -g -- ./work_and_wait_mt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;生成报告&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo perf report
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;报告解读&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Samples: 15K of event &lt;span class=&#34;s1&#34;&gt;&amp;#39;cpu-clock&amp;#39;&lt;/span&gt;, Event count &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;approx.&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;: &lt;span class=&#34;m&#34;&gt;156434341870&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Children      Self  Command          Shared Object          Symbol
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+   63.88%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; secondary_startup_64_no_verify
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+   63.88%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; cpu_startup_entry
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+   63.88%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; do_idle
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+   63.87%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; cpuidle_idle_call
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+   63.87%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; call_cpuidle
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+   63.87%    63.85%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; cpuidle_enter_state
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+   63.87%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; cpuidle_enter
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+   58.09%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; start_secondary
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+   36.08%    36.08%  work_and_wait_m  work_and_wait_mt       &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;.&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; burn_cpu
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+    5.79%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; x86_64_start_kernel
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+    5.79%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; x86_64_start_reservations
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+    5.79%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; start_kernel
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+    5.79%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; arch_call_rest_init
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+    5.79%     0.00%  swapper          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; rest_init
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.01%     0.01%  Lingma           &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; finish_task_switch.isra.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;情况发生了戏剧性的反转。在这份报告中，&lt;code&gt;swapper&lt;/code&gt; （空闲任务）成为了绝对的主角。有 &lt;strong&gt;63.85%&lt;/strong&gt; 的时间样本，都捕获到 CPU 正处于 &lt;code&gt;cpuidle_enter_state&lt;/code&gt; 这个函数内部，这正是内核让 CPU“休眠”的地方。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;burn_cpu&lt;/code&gt; &lt;strong&gt;沦为配角 (36.08% Self)&lt;/strong&gt;，曾经消耗了 99% CPU 算力的 &lt;code&gt;burn_cpu&lt;/code&gt; 函数，在时间的维度上，只占了 36.08% 的份额。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结 cpu-clock 报告：&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;swapper&lt;/code&gt; 成了主角&lt;/strong&gt;，占据了 &lt;strong&gt;63.85%&lt;/strong&gt; 的时间样本，证明了 CPU 在绝大部分&lt;strong&gt;时间&lt;/strong&gt;里，都处于内核安排的“睡眠”状态。&lt;strong&gt;&lt;code&gt;burn_cpu&lt;/code&gt; 沦为配角&lt;/strong&gt;，只占了 &lt;strong&gt;36.08%&lt;/strong&gt; 的时间。&lt;/p&gt;
&lt;h4 id=&#34;对比总结&#34;&gt;
    &lt;a href=&#34;#%e5%af%b9%e6%af%94%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    对比总结
&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;采样事件&lt;/th&gt;
&lt;th&gt;核心问题&lt;/th&gt;
&lt;th&gt;burn_cpu 表现&lt;/th&gt;
&lt;th&gt;swapper 表现&lt;/th&gt;
&lt;th&gt;分析视角&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;cpu-cycles&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;“谁消耗了&lt;strong&gt;算力&lt;/strong&gt;？”&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;绝对主力 (99%)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;微不足道&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;On-CPU&lt;/strong&gt; (工作量分析)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;cpu-clock&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;“&lt;strong&gt;时间&lt;/strong&gt;花在哪了？”&lt;/td&gt;
&lt;td&gt;少数派 (~36%)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;绝对主力 (64%)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Wall-Clock&lt;/strong&gt; (延迟/等待分析)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;一个有用的技巧进程专属模式下的-cpu-clock&#34;&gt;
    &lt;a href=&#34;#%e4%b8%80%e4%b8%aa%e6%9c%89%e7%94%a8%e7%9a%84%e6%8a%80%e5%b7%a7%e8%bf%9b%e7%a8%8b%e4%b8%93%e5%b1%9e%e6%a8%a1%e5%bc%8f%e4%b8%8b%e7%9a%84-cpu-clock&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    一个有用的技巧：进程专属模式下的 &lt;code&gt;cpu-clock&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;如果不使用 &lt;code&gt;-a&lt;/code&gt; 参数，而是运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo perf record -F &lt;span class=&#34;m&#34;&gt;99&lt;/span&gt; -e cpu-clock -g -- ./work_and_wait_mt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;得到的报告竟然和 &lt;code&gt;cycles&lt;/code&gt; 采样的结果惊人地一致，&lt;code&gt;swapper&lt;/code&gt; 消失了，&lt;code&gt;burn_cpu&lt;/code&gt; 再次占据了 99% 以上的份额，休息时间（swapper/idle）完全消失了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Samples: 5K of event &lt;span class=&#34;s1&#34;&gt;&amp;#39;cpu-clock&amp;#39;&lt;/span&gt;, Event count &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;approx.&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;: &lt;span class=&#34;m&#34;&gt;56252524690&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Children      Self  Command          Shared Object      Symbol
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+   99.98%    99.98%  work_and_wait_m  work_and_wait_mt   &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;.&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; burn_cpu
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.02%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; __check_heap_object
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.00%  work_and_wait_m  work_and_wait_mt   &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;.&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; worker_function
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.00%  work_and_wait_m  libc.so.6          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;.&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; __printf_chk
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.00%  work_and_wait_m  libc.so.6          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;.&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; __vfprintf_internal
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.00%  work_and_wait_m  libc.so.6          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;.&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; __printf_buffer_to_file_done
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.00%  work_and_wait_m  libc.so.6          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;.&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; _IO_file_xsputn@@GLIBC_2.2.5
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.00%  work_and_wait_m  libc.so.6          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;.&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; _IO_do_write@@GLIBC_2.2.5
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.00%  work_and_wait_m  libc.so.6          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;.&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; _IO_file_write@@GLIBC_2.2.5
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.00%  work_and_wait_m  libc.so.6          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;.&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; __GI___libc_write
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; entry_SYSCALL_64_after_hwframe
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; do_syscall_64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     0.02%     0.00%  work_and_wait_m  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;kernel.kallsyms&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;k&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; x64_sys_call
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;原因是这次使用的命令是&lt;strong&gt;进程专属（Process-Specific）模式&lt;/strong&gt;，而不是&lt;strong&gt;系统全局（System-Wide）模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;参数的全称是 &lt;strong&gt;&lt;code&gt;--all-cpus&lt;/code&gt;&lt;/strong&gt;，是对全系统范围内所有 CPU 进行收集。如果不加 &lt;code&gt;-a&lt;/code&gt;，上面的命令明确告诉 perf，&lt;strong&gt;只监控 ./work_and_wait_mt 这个进程以及它创建的所有子进程。对于任何其他进程的活动，请直接忽略。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;perf&lt;/code&gt; 在&lt;strong&gt;进程专属模式&lt;/strong&gt;下运行时，它内部有一个强大的“过滤器”，当 &lt;code&gt;cpu-clock&lt;/code&gt; 的“闹钟”响起时，&lt;code&gt;perf&lt;/code&gt; 会检查当前在 CPU 上运行的是哪个进程。如果恰好是我们的 &lt;code&gt;work_and_wait_mt&lt;/code&gt;，样本就被记录下来。如果在程序休眠期间，CPU 上运行的是 &lt;code&gt;swapper&lt;/code&gt; 任务，&lt;code&gt;perf&lt;/code&gt; 会发现这个任务不属于它的监控目标，于是&lt;strong&gt;直接丢弃了这个样本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过这个实验我们发现，在&lt;strong&gt;进程专属模式&lt;/strong&gt;下，&lt;code&gt;cpu-clock&lt;/code&gt; 的行为会因为进程过滤器的存在而变得非常像 &lt;code&gt;cpu-cycles&lt;/code&gt;。这意味着，&lt;strong&gt;在不方便使用硬件 &lt;code&gt;cycles&lt;/code&gt; 事件，或者想纯粹用软件事件来分析一个特定程序的 On-CPU 热点时，使用“进程专属模式”下的 &lt;code&gt;cpu-clock&lt;/code&gt; 是一个完全可行的替代方案。&lt;/strong&gt; 同时，要真正地用 &lt;code&gt;cpu-clock&lt;/code&gt; 来分析等待时间（Off-CPU），&lt;strong&gt;必须使用 -a 参数切换到系统全局模式&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;
    &lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    总结
&lt;/h2&gt;&lt;p&gt;通过对内核源码的剖析，以及一系列实验，现在我们可以回答开头那个令人困惑的问题了：cpu-clock 和 cycles 到底有何不同？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;cpu-clock&lt;/code&gt;&lt;/strong&gt; 基于&lt;strong&gt;时间&lt;/strong&gt;，它的闹钟忠实地记录下每个时间点的系统状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;cpu-cycles&lt;/code&gt;&lt;/strong&gt; 基于&lt;strong&gt;工作量&lt;/strong&gt;，它的计步器精准地衡量了 CPU 的实际消耗。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，在&lt;strong&gt;进程专属模式&lt;/strong&gt;下，perf 内置的“过滤器”会将所有非目标进程的样本（包括 swapper）丢弃，使得 &lt;code&gt;cpu-clock&lt;/code&gt; 的行为趋近于 &lt;code&gt;cpu-cycles&lt;/code&gt;，成为一种纯软件实现的 On-CPU 分析替代方案。&lt;/p&gt;
&lt;p&gt;当面对文档的语焉不详和网络信息的模糊不清时，只有深入源码、亲手验证，才是揭开迷雾正确路径。希望这篇文章对你也有帮助。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Wall-Clock 与 CPU-Cycles 采样的区别</title>
        <link>https://mazhen.tech/p/wall-clock-%E4%B8%8E-cpu-cycles-%E9%87%87%E6%A0%B7%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
        <pubDate>Wed, 18 Jun 2025 10:09:54 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/wall-clock-%E4%B8%8E-cpu-cycles-%E9%87%87%E6%A0%B7%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202506181047949.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Feature image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我曾写过一篇 &lt;a class=&#34;link&#34; href=&#34;https://mazhen.tech/p/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2-perf-cpu-profiling-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入探索 perf CPU Profiling 实现原理&lt;/a&gt; 的文章，希望能帮助大家理解这个强大工具背后的运作机制。在那篇文章里，我尽可能地拆解了从中断到调用栈还原的整个流程。&lt;/p&gt;
&lt;p&gt;然而，在后续的技术学习和思考过程中，我意识到其中一个核心概念的阐述，虽然看似合理，却隐含着一个重要且易被误解的核心概念。今天，我想写下这篇“勘误与续篇”，与大家一同分享这个让我醍醐灌顶的“Aha!”时刻，重新探讨两种采样方式：&lt;strong&gt;Wall-Clock 采样&lt;/strong&gt;与 &lt;strong&gt;CPU-Cycles 采样&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;最初的误解cpu-的节拍是恒定的吗&#34;&gt;
    &lt;a href=&#34;#%e6%9c%80%e5%88%9d%e7%9a%84%e8%af%af%e8%a7%a3cpu-%e7%9a%84%e8%8a%82%e6%8b%8d%e6%98%af%e6%81%92%e5%ae%9a%e7%9a%84%e5%90%97&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    最初的误解：CPU 的节拍是恒定的吗？
&lt;/h2&gt;&lt;p&gt;在我之前的文章中，关于为何采样 &lt;code&gt;cycles&lt;/code&gt; 事件能分析 CPU 性能，我是这样描述的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“每经过一个 CPU 周期都会触发一个 cycles 事件。可以认为，cycles 事件是均匀的分布在程序的执行期间。这样，以固定频率去采样的 cycles 事件，也是均匀的分布在程序的执行期间。我们在采样 cycles 事件时，记录 CPU 正在干什么，持续一段时间收集到多个采样后，我们就能基于这些信息分析程序的行为&amp;hellip;”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个逻辑听起来是不是无懈可击？一个 4 GHz 的 CPU，每秒不就是产生 40 亿个时钟周期（cycles）吗？那么按 &lt;code&gt;cycles&lt;/code&gt; 采样不就等同于按一个极其精确的时间间隔采样吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正是这个看似合理的假设，让我走入了一个误区。&lt;/strong&gt; 事实是，CPU 远比我们想象的要“聪明”和“懒惰”。&lt;/p&gt;
&lt;h2 id=&#34;墙上时钟采样wall-clock-sampling&#34;&gt;
    &lt;a href=&#34;#%e5%a2%99%e4%b8%8a%e6%97%b6%e9%92%9f%e9%87%87%e6%a0%b7wall-clock-sampling&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    墙上时钟采样（Wall-Clock Sampling）
&lt;/h2&gt;&lt;p&gt;为了理解 &lt;code&gt;cpu-cycles&lt;/code&gt; 采样的精妙之处，我们首先要看它的参照物：&lt;strong&gt;墙上时钟采样（Wall-Clock Sampling）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;你可以把墙上时钟采样想象成一个厨房定时器。你设定它每 1 分钟响一次，它就会忠实地每分钟提醒你一次，&lt;strong&gt;完全不管你是在切菜、炒菜，还是在刷手机，等水烧开&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这种采样方式依赖一个全局的、按真实时间流逝的计时器。比如，你设定每 10 毫秒采样一次，操作系统就会每隔 10 毫秒触发一次中断，然后去看：“嘿，CPU 核心此刻正在忙什么？”&lt;/p&gt;
&lt;p&gt;这种方式的核心是&lt;strong&gt;对时间点的快照&lt;/strong&gt;，它并不关心两次快照之间发生了什么。让我们从 CPU 的视角来看一个场景：&lt;/p&gt;
&lt;p&gt;假设在 100 毫秒的总时间内，一个 CPU 核心的活动如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;0-20ms&lt;/strong&gt;: 运行高强度的计算任务（进程 A）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;20-80ms&lt;/strong&gt;: 系统无事可做，CPU 进入&lt;strong&gt;空闲（Idle）状态&lt;/strong&gt;。进程 A 正在等待网络数据，而系统中没有其他需要计算的任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;80-100ms&lt;/strong&gt;: 计算任务（进程 A）被唤醒，继续在 CPU 上运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，我们用一个每 10 毫秒一次的墙上时钟采样器来观察这个 CPU 核心。它总共会进行 10 次采样，采样点大约会落在 10ms, 20ms, 30ms, &amp;hellip;, 100ms 的时刻。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;strong&gt;10ms&lt;/strong&gt; 和 &lt;strong&gt;20ms&lt;/strong&gt; 时刻，采样器会看到 CPU 正在执行&lt;strong&gt;进程 A&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在 &lt;strong&gt;30ms, 40ms, 50ms, 60ms, 70ms&lt;/strong&gt; 时刻，采样器会看到 CPU 正在执行一个特殊的&lt;strong&gt;空闲任务（Idle Task）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在 &lt;strong&gt;80ms, 90ms, 100ms&lt;/strong&gt; 时刻，采样器又会看到 CPU 在执行&lt;strong&gt;进程 A&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终的分析报告会告诉你，在大约 50% 的采样点上，CPU 在执行进程 A，而在另外 50% 的采样点上，CPU 处于空闲状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202506171603341.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Wall-Clock Sampling&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这个结果本身是准确的，它忠实地反映了 CPU 在&lt;strong&gt;总时间&lt;/strong&gt;内的状态分布。但 Wall-Clock 采样方式，将“计算”和“等待导致的空闲”混在了一起。如果你想找出是什么消耗了最多的 &lt;strong&gt;CPU 计算资源&lt;/strong&gt;，这种采样方式可能会给你带来困惑，因为它花费了大量的样本去记录“什么都没在发生”的空闲时刻。&lt;/p&gt;
&lt;p&gt;想起一个流传已久的性能分析领域的笑话：一位程序员使用性能分析器后发现，有一个进程占用了大量的 CPU 时间。于是他花了很大力气进行优化，但程序的运行速度并没有变快。原来被他优化这个进程，其实是“idle loop”，也就是没有其他工作可做时才会运行的部分。&lt;/p&gt;
&lt;h2 id=&#34;cpu-cycles-采样只关心干活的计步器&#34;&gt;
    &lt;a href=&#34;#cpu-cycles-%e9%87%87%e6%a0%b7%e5%8f%aa%e5%85%b3%e5%bf%83%e5%b9%b2%e6%b4%bb%e7%9a%84%e8%ae%a1%e6%ad%a5%e5%99%a8&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CPU-Cycles 采样：只关心“干活”的计步器
&lt;/h2&gt;&lt;p&gt;现在，让我们揭开 &lt;code&gt;cpu-cycles&lt;/code&gt; 采样的真正面纱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“一个 4 GHz 的 CPU，每秒产生 40 亿个 cycles”这个描述是不准确的。&lt;/strong&gt; 它描述的是 CPU 的&lt;strong&gt;最高性能&lt;/strong&gt;，而不是&lt;strong&gt;恒定状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;正确的理解是：现代 CPU 为了节能和控制温度，会动态地调整自己的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当无事可做时（Idle）&lt;/strong&gt;：CPU 会进入深度睡眠（C-states），此时它的时钟频率极低，甚至可能完全停摆。在这期间，它&lt;strong&gt;几乎不产生任何 &lt;code&gt;cpu-cycles&lt;/code&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当任务清闲时（Light Load）&lt;/strong&gt;：它会降低自己的工作频率（比如从 4 GHz 降到 1 GHz）来省电。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当任务繁重时（Heavy Load）&lt;/strong&gt;：它才会火力全开，提升到标称频率甚至超频来快速完成工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，&lt;code&gt;cpu-cycles&lt;/code&gt; 的真正含义就清晰了：它不是时间的度量，而是 &lt;strong&gt;CPU 完成工作的度量单位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpu-cycles&lt;/code&gt; 采样就像一个只在你跑步时才计数的计步器。当你坐下休息时，计步器是完全静止的。同理，当 CPU 进入空闲状态时，为它计数的 &lt;code&gt;cpu-cycles&lt;/code&gt; 计数器也&lt;strong&gt;随之暂停&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;操作系统会与 CPU 的性能监控单元（PMU）协作，设定一个阈值，&lt;strong&gt;当累计消耗的 CPU Cycles 达到了预设值（比如 3000 万个周期）时，才会触发一次采样中断&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202506171641726.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;CPU-Cycles&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这种采样方式保证了&lt;strong&gt;每一次采样，都必然命中了一个真正在消耗 CPU 资源、在“干活”的线程&lt;/strong&gt;。一个线程被采样的次数，与它消耗的 CPU 总量成正比。&lt;/p&gt;
&lt;h2 id=&#34;cpu-cycles-vs-wall-clock&#34;&gt;
    &lt;a href=&#34;#cpu-cycles-vs-wall-clock&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CPU-Cycles vs. Wall-Clock
&lt;/h2&gt;&lt;p&gt;在分别了解了 Wall-Clock 和 CPU-Cycles 采样之后，我们可能会有一个疑问：它们到底哪个更好？其实，这是一个关乎视角的问题，而非优劣之分。&lt;/p&gt;
&lt;p&gt;当 CPU 被 100% 占满、满负荷运转时，无论是 Wall-Clock 采样还是 cpu-cycles 采样，它们看到的结果会非常相似，都是 CPU 在忙于执行代码的快照。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202506171723000.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;CPU-Cycles vs. Wall-Clock&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然而，真正的区分出现在 CPU 并非 100% 繁忙的时候。这两种方法最根本的区别，在于它们如何看待 CPU 的&lt;strong&gt;空闲（Idle）时间&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Wall-Clock 采样&lt;/strong&gt;，作为一个时间的忠实记录者，它会一视同仁地记录下所有状态，无论是繁忙的计算，还是无所事事的等待。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU-Cycles 采样&lt;/strong&gt;，则像一个只关心产出的质检员。如果生产线（CPU）停了，它也跟着停下休息，完全不关心停了多久。它只在指令执行时才进行工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种看待问题的不同视角，在性能分析领域有着专门的术语：&lt;strong&gt;On-CPU 分析&lt;/strong&gt;和 &lt;strong&gt;Off-CPU 分析&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;On-CPU 分析&lt;/strong&gt;关注的是：“&lt;strong&gt;是什么让我的 CPU 如此忙碌？&lt;/strong&gt;”它的目标是找到消耗计算资源最多的代码热点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Off-CPU 分析&lt;/strong&gt;关注的是：“&lt;strong&gt;我的程序为什么在等待，而不是在运行？&lt;/strong&gt;”它的目标是找到那些导致程序停滞的瓶颈，如 I/O 等待、锁竞争、或者休眠。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种分析方法，也对应着我们最关心的两个核心性能指标：吞吐量（Throughput）和延迟（Latency）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU-Cycles 采样&lt;/strong&gt;，通过聚焦 On-CPU 时间，帮助我们提升程序的计算效率。这直接关系到&lt;strong&gt;吞吐量&lt;/strong&gt;，即单位时间内能处理多少工作。优化掉一个 CPU 热点，意味着每个任务消耗的 CPU 时间更少，服务器自然能承载更多的请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Wall-Clock 采样&lt;/strong&gt;，通过完整地展现包括 Off-CPU 在内的全部时间，帮助我们理解和优化程序的响应速度。这直接关系到&lt;strong&gt;延迟&lt;/strong&gt;，即完成单个任务需要多长时间。如果一个请求 99% 的时间都在等待数据库返回结果，那么优化计算逻辑对降低延迟几乎没有帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们应该如何选择呢？答案是：&lt;strong&gt;取决于你想要解决的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你想优化一个&lt;strong&gt;计算密集型&lt;/strong&gt;服务，降低服务器成本，或者想找出算法中的性能瓶颈，那么 &lt;strong&gt;CPU-Cycles 采样&lt;/strong&gt;是你的不二之选。它是性能优化的“手术刀”，精准且致命。&lt;/p&gt;
&lt;p&gt;但如果你遇到的问题是“&lt;strong&gt;我的程序启动为什么这么慢？&lt;/strong&gt;”，情况就完全不同了。应用程序的启动过程，是一个混合了大量磁盘 I/O（读取配置文件和库）、网络 I/O（连接数据库或服务）以及 CPU 计算的复杂过程。在这种场景下，&lt;strong&gt;Wall-Clock 采样&lt;/strong&gt;会非常有用。它能为你绘制一幅完整的启动时间线，清晰地标出那些漫长的“等待”鸿沟，让你知道时间到底被浪费在了哪里。同理，在调试锁竞争或分析外部服务调用延迟时，它也是一把利器。&lt;/p&gt;
&lt;p&gt;总而言之，这两种采样方式没有绝对的优劣，它们像是性能分析工具箱里两种不同用途的工具，为我们提供了观察系统的不同维度。&lt;/p&gt;
&lt;h2 id=&#34;perf-record--f-99-的真正魔法&#34;&gt;
    &lt;a href=&#34;#perf-record--f-99-%e7%9a%84%e7%9c%9f%e6%ad%a3%e9%ad%94%e6%b3%95&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    &lt;code&gt;perf record -F 99&lt;/code&gt; 的真正魔法
&lt;/h2&gt;&lt;p&gt;理解了上述区别，我们才能真正领会 &lt;code&gt;perf record -F 99&lt;/code&gt; 命令背后的原理。&lt;/p&gt;
&lt;p&gt;它并不是简单地“每秒采样 99 次”，背后是内核与硬件精巧的协作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;目标驱动&lt;/strong&gt;：&lt;code&gt;-F 99&lt;/code&gt; 告诉内核：“我的目标是在&lt;strong&gt;每个 CPU 核心&lt;/strong&gt;上，都达到&lt;strong&gt;平均每秒 99 次&lt;/strong&gt;的采样频率。”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态计算&lt;/strong&gt;：内核不是设定一个固定的 &lt;code&gt;cpu-cycles&lt;/code&gt; 间隔。相反，它会通过 &lt;code&gt;cpufreq&lt;/code&gt; 子系统或 MSR 寄存器，&lt;strong&gt;实时地查询到 CPU 当前的工作频率&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;智能调整&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;如果 CPU 正以 4 GHz 的高频率运行，内核会计算出一个较大的 &lt;code&gt;cpu-cycles&lt;/code&gt; 间隔（比如 &lt;code&gt;4,000,000,000 / 99&lt;/code&gt;），然后设置硬件计数器。&lt;/li&gt;
&lt;li&gt;如果 CPU 因为负载低而降频到 1 GHz，内核会立刻感知到，并自动将采样间隔调整为一个较小的 &lt;code&gt;cpu-cycles&lt;/code&gt; 数值（比如 &lt;code&gt;1,000,000,000 / 99&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;cpu-cycles&lt;/code&gt; 的采样周期是动态变化的，但最终达成“每秒采样 99 次”这个目标。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种机制带来了巨大的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;它只在 CPU 忙碌时采样&lt;/strong&gt;，天然地过滤掉了所有 I/O 等待和空闲时间造成的噪音。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;它自适应 CPU 的频率变化&lt;/strong&gt;，确保了分析结果在不同负载下的一致性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;它在不同硬件上表现一致&lt;/strong&gt;，你在笔记本和在服务器上使用 &lt;code&gt;-F 99&lt;/code&gt;，得到的都是相似密度的有效数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;
    &lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    总结
&lt;/h2&gt;&lt;p&gt;这次对性能分析的重新探索，始于一个看似简单的问题：“&lt;strong&gt;为何采样 cycles 事件能分析 CPU 的性能？&lt;/strong&gt;”我们最初的假设是，cycles 在时间上是均匀的，采样它就如同按时间采样。&lt;/p&gt;
&lt;p&gt;而经过这趟深入的旅程，我们发现：&lt;strong&gt;CPU-Cycles 采样&lt;/strong&gt;并非时间的度量，而是&lt;strong&gt;CPU 完成工作量的度量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当 CPU 因为等待 I/O 或无事可做而进入休眠时，它的 &lt;code&gt;cpu-cycles&lt;/code&gt; 计数器也随之暂停。只有当代码真正在 CPU 上执行指令时，cycles 才会产生。这意味着，一个函数被 cycles 采样命中的次数，与它流逝了多少时间无关，而是与其&lt;strong&gt;消耗了多少实际的 CPU 计算资源&lt;/strong&gt;成正比。&lt;strong&gt;CPU-Cycles 采样&lt;/strong&gt;的结果反映了程序在 CPU 繁忙时间（Busy Time）中的资源消耗分布，是分析 &lt;strong&gt;On-CPU&lt;/strong&gt; 问题、优化&lt;strong&gt;吞吐量（Throughput）&lt;/strong&gt; 的“手术刀”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wall-Clock 采样&lt;/strong&gt;以&lt;strong&gt;恒定的时间间隔&lt;/strong&gt;为基准，它捕获的是在特定时间点上 CPU 的状态。其结果反映了程序在&lt;strong&gt;总流逝时间（Total Time）&lt;/strong&gt; 中的状态分布，天然地包含了 &lt;strong&gt;On-CPU&lt;/strong&gt; 和 &lt;strong&gt;Off-CPU&lt;/strong&gt;（如 Idle, I/O Wait）两个维度，是分析&lt;strong&gt;延迟（Latency）&lt;/strong&gt; 问题的利器。&lt;/p&gt;
&lt;p&gt;这次“勘误”，不仅修正了我之前的文章，也使我对性能分析的底层原理有了一个更清晰的理解，希望对你也有帮助。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>理解 CRaC 背后的 Linux 系统编程</title>
        <link>https://mazhen.tech/p/%E7%90%86%E8%A7%A3-crac-%E8%83%8C%E5%90%8E%E7%9A%84-linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</link>
        <pubDate>Wed, 30 Apr 2025 10:18:47 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E7%90%86%E8%A7%A3-crac-%E8%83%8C%E5%90%8E%E7%9A%84-linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</guid>
        <description>&lt;h2 id=&#34;crac-的性能飞跃与-linux-内核的基石&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e6%80%a7%e8%83%bd%e9%a3%9e%e8%b7%83%e4%b8%8e-linux-%e5%86%85%e6%a0%b8%e7%9a%84%e5%9f%ba%e7%9f%b3&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的性能飞跃与 Linux 内核的基石
&lt;/h2&gt;&lt;p&gt;Java 应用的启动速度，尤其是在微服务和 Serverless 场景下的“冷启动”，一直是其性能优化的重点。传统的启动过程涉及 JVM 初始化、类加载和 JIT 预热，耗时较长。&lt;strong&gt;CRaC (Coordinated Restore at Checkpoint)&lt;/strong&gt; 技术为此提供了一种创新方案：它在应用达到理想状态时捕获其完整运行时快照（Checkpoint），并在需要时快速恢复（Restore），从而实现毫秒级启动和即时峰值性能。&lt;/p&gt;
&lt;p&gt;这种强大的进程“冻结”与“复苏”能力并非凭空而来，它深度依赖于 Linux 操作系统提供的底层机制，并通过 &lt;strong&gt;CRIU (Checkpoint/Restore In Userspace)&lt;/strong&gt; 这个工具集得以实现。因此，要真正理解 CRaC 的工作原理，探究其背后的 Linux 系统编程知识至关重要。本文将为熟悉编程但可能不熟悉 Linux 底层的开发者，解析 CRaC 实现所依赖的关键 Linux 概念（如进程/线程、/proc 文件系统、ptrace 系统调用等），揭示 CRaC 性能飞跃背后的 Linux“魔法”。&lt;/p&gt;
&lt;h2 id=&#34;进程与线程及其生命周期&#34;&gt;
    &lt;a href=&#34;#%e8%bf%9b%e7%a8%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b%e5%8f%8a%e5%85%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    进程与线程及其生命周期
&lt;/h2&gt;&lt;p&gt;要理解 CRaC 如何操作运行中的 Java 应用，我们首先需要了解 Linux 是如何组织和管理程序执行的。其核心概念是&lt;strong&gt;进程 (Process)&lt;/strong&gt;。你可以将进程看作是一个&lt;strong&gt;正在运行的程序的实例&lt;/strong&gt;，它是操作系统分配资源（如内存、文件句柄）和进行调度的基本单位。每个进程都仿佛生活在自己的独立世界里，拥有独立的地址空间，这保证了进程间的隔离性。&lt;/p&gt;
&lt;p&gt;然而，在一个进程内部，往往需要同时执行多个任务流。这时&lt;strong&gt;线程 (Thread)&lt;/strong&gt; 就登场了。线程是进程内部的实际执行单元，有时也被称为轻量级进程（LWP）。与进程不同，同一进程内的所有线程&lt;strong&gt;共享&lt;/strong&gt;该进程的地址空间和大部分资源，这使得线程间的通信和切换更为高效。但每个线程仍然保有自己独立的执行上下文，如程序计数器、寄存器和栈。&lt;/p&gt;
&lt;p&gt;有趣的是，从 Linux 内核的视角来看，它并不严格区分进程和线程。两者都被视为可调度的“&lt;strong&gt;任务 (Task)&lt;/strong&gt;”，并由统一的数据结构 task_struct 来描述。线程仅仅是与其他任务共享了更多资源（特别是内存地址空间）的任务而已。因此，内核调度器可以对它们一视同仁。为了管理这些任务，系统为它们分配了唯一的身份标识：&lt;strong&gt;PID (Process ID)&lt;/strong&gt; 用于标识整个进程（一组共享资源的线程），而 &lt;strong&gt;TID (Thread ID)&lt;/strong&gt; 则用于标识每一个单独的线程（任务）。对于单线程进程，PID 和 TID 是相同的。&lt;/p&gt;
&lt;p&gt;新进程的诞生，最经典的方式是通过 fork() 系统调用。当一个进程调用 fork()，内核会创建出它的一个几乎完全相同的副本——子进程。子进程继承了父进程大部分状态，包括内存内容的副本（通过写时复制优化）、文件描述符等。fork() 的奇妙之处在于它在父进程中返回子进程的 PID，而在子进程中返回 0，使得程序可以根据返回值区分父子，执行不同的逻辑。CRIU 在恢复进程状态时，正是利用 fork() 来重建 Checkpoint 时刻的进程树结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fork() 示例代码 (fork_example.c)&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 创建子进程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// fork 失败  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;fork failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 子进程执行的代码  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;I am the child process, PID: %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 模拟工作  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child process exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_SUCCESS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 子进程正常退出  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 父进程执行的代码  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;I am the parent process, PID: %d, Child PID: %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent waiting for child...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 简单等待任意子进程  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent process: Child finished.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Process %d exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 编译运行：gcc fork_example.c -o fork_example &amp;amp;&amp;amp; ./fork_example
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;除了 fork()，还有一个更底层的系统调用 clone()，它提供了更细粒度的控制，允许指定新创建的任务与父任务共享哪些资源，因此 clone() 既可以用来创建进程，也可以用来创建线程。&lt;/p&gt;
&lt;p&gt;fork() 创建的子进程默认执行的是和父进程相同的代码。如果希望子进程去执行一个&lt;strong&gt;全新的程序&lt;/strong&gt;，就需要 exec 系列系统调用（如 execv(), execlp() 等）的帮助。exec 调用会用新程序的映像&lt;strong&gt;完全替换&lt;/strong&gt;当前进程的内存空间（代码、数据、堆栈），然后从新程序的入口点开始执行。一旦 exec 成功，原来的程序就不复存在了，这个调用本身也不会返回。CRaC 在恢复过程中，criuengine 这个辅助程序就利用了一连串的 execv 调用，不断“变身”，最终成为负责等待恢复后 JVM 退出的 restorewait 进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;execv() 示例代码 (exec_example.c)&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;fork failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 子进程  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child process (PID: %d) will execute &amp;#39;ls -l&amp;#39;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/bin/ls&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;-l&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 准备参数列表  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;execv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 执行新程序  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 如果 execv 返回，说明出错了  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;execv failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 父进程  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent process (PID: %d) waiting for child (PID: %d)...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 等待子进程结束  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent process: Child finished executing &amp;#39;ls -l&amp;#39;.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 编译运行：gcc exec_example.c -o exec_example &amp;amp;&amp;amp; ./exec_example
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;进程有生就有灭。当子进程结束时，它并不会立即消失。内核会保留它的退出状态等信息，等待父进程来“认领”。父进程通过调用 wait() 或 waitpid() 系统调用来获取子进程的终止信息，并告知内核可以彻底清理该子进程了。waitpid() 提供了更多控制，比如可以等待指定的子进程，或者以非阻塞的方式检查子进程状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;waitpid() 示例代码 (waitpid_example.c)&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 创建第一个子进程  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Child 1 */&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child 1 (PID: %d) running...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child 1 exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 创建第二个子进程  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Child 2 */&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child 2 (PID: %d) running...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Child 2 exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 父进程等待特定的子进程 pid1  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent waiting for Child 1 (PID: %d)...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;terminated_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;waitpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 阻塞等待 pid1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;terminated_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WIFEXITED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent: Child 1 terminated normally with status: %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WEXITSTATUS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Handle error or abnormal termination */&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 父进程等待另一个子进程 pid2  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent waiting for Child 2 (PID: %d)...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;terminated_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;waitpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 阻塞等待 pid2  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;     &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;terminated_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WIFEXITED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent: Child 2 terminated normally with status: %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WEXITSTATUS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Handle error or abnormal termination */&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Parent exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 编译运行：gcc waitpid_example.c -o waitpid_example &amp;amp;&amp;amp; ./waitpid_example
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果在子进程终止后，父进程没有及时调用 wait() 或 waitpid()，那么这个子进程就会变成&lt;strong&gt;僵尸进程 (Zombie Process)&lt;/strong&gt;。它虽然不再运行，但仍在进程表中占据一个位置，等待父进程回收。如果父进程先于子进程退出，子进程就成了&lt;strong&gt;孤儿进程 (Orphan Process)&lt;/strong&gt;。为了避免孤儿进程变成无人认领的僵尸，Linux 会自动将它们的父进程设置为 init 进程（PID 1），由 init 进程负责回收它们。&lt;/p&gt;
&lt;p&gt;理解了孤儿进程和父进程回收机制后，就能明白一种常见的编程技巧——&lt;strong&gt;Double Fork&lt;/strong&gt;。它的目的是创建一个与原始父进程完全脱离关系的后台进程（守护进程）。其步骤是：进程 A fork 出子进程 B，然后进程 A 立刻 waitpid() 等待 B 结束并退出；子进程 B 再次 fork 出孙子进程 C，然后 B 自己立刻退出；此时，孙子进程 C 成为孤儿，被 init 进程接管，从而与 A 彻底解耦。CRIU 在执行 Checkpoint 时，就运用了类似 double fork 的方法，让执行 criu dump 命令的进程脱离被操作的 JVM 进程树，避免了“自己冻结自己”的尴尬局面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;double_fork 示例代码 (double_fork_example.c)&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;  &lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第一次 fork
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;First fork failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第一个子进程 (进程 B)  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第二次 fork  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Second fork failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 孙子进程 (进程 C)  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Grandchild process (PID: %d, Parent PID: %d) starting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getppid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 通常在这里执行 setsid() 等守护进程化操作  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nf&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 模拟后台任务  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Grandchild process finished.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第一个子进程 (进程 B) 立即退出  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;First child process (PID: %d) exiting immediately.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 原始父进程 (进程 A)  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Original parent process (PID: %d) waiting for first child (PID: %d).&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;waitpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 等待第一个子进程退出  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Original parent exiting.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 孙子进程已成为孤儿并由 init 接管  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 编译运行：gcc double_fork_example.c -o double_fork_example &amp;amp;&amp;amp; ./double_fork_example
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;掌握了 Linux 进程和线程的生命周期管理，我们就能更好地理解 CRaC 是如何在这些基础上进行精确的状态捕获与恢复。接下来，我们将目光投向 Linux 提供的一个强大工具——/proc 文件系统，看看它如何帮助我们“透视”运行中进程的内部状态。&lt;/p&gt;
&lt;h2 id=&#34;proc-文件系统内核状态的透视镜&#34;&gt;
    &lt;a href=&#34;#proc-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e5%86%85%e6%a0%b8%e7%8a%b6%e6%80%81%e7%9a%84%e9%80%8f%e8%a7%86%e9%95%9c&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    /proc 文件系统：内核状态的“透视镜”
&lt;/h2&gt;&lt;p&gt;我们已经了解了 Linux 如何创建和管理进程，但要实现像 CRaC 那样的“冻结”与“复苏”，就必须有办法&lt;strong&gt;深入探查&lt;/strong&gt;一个正在运行的进程内部的详细状态。Linux 提供了一个非常强大的机制来做到这一点，那就是 /proc 文件系统。&lt;/p&gt;
&lt;p&gt;初看起来，/proc 像是一个普通的目录，你可以用 cd 进入，用 ls 查看。但它实际上是一个&lt;strong&gt;虚拟文件系统&lt;/strong&gt;。这意味着它里面的文件和目录并不真正存储在磁盘上，而是由 Linux 内核在&lt;strong&gt;运行时动态生成&lt;/strong&gt;的。/proc 是内核向用户空间（运行中的程序和用户）暴露其内部数据结构和系统信息的主要接口之一。你可以把它想象成一扇窗户，透过它，我们可以直接观察到内核管理下的系统状态，特别是&lt;strong&gt;运行中进程的实时信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这对于 CRIU 和 CRaC 来说简直是无价之宝。当 CRIU 需要对一个进程执行 Checkpoint 时，它的大部分信息来源就是 /proc 文件系统。通过读取 /proc 下的特定文件，CRIU 能够获取到目标进程几乎所有的关键状态数据，从而构建出完整的进程快照。&lt;/p&gt;
&lt;p&gt;让我们来看看 /proc 下与进程相关的几个关键“情报站”，它们通常位于以进程 PID 命名的目录下，即 /proc/&amp;lt;pid&amp;gt;/：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存布局图 (/proc/&amp;lt;pid&amp;gt;/maps 和 smaps)&lt;/strong&gt;: 这两个文件揭示了进程的虚拟内存是如何组织的。maps 文件列出了进程的所有内存区域（称为 VMA，Virtual Memory Area），包括代码段、数据段、堆、栈以及内存映射的文件和共享库，标明了每个区域的起止地址和权限。smaps 文件则提供了更详细的信息，包括每个 VMA 实际占用的物理内存（RSS - Resident Set Size）、共享/私有内存量、脏页（Dirty pages）数量等。CRIU 通过解析它们来精确了解进程的内存结构，这是 Checkpoint 和 Restore 内存状态的基础。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;打开的文件和连接 (/proc/&amp;lt;pid&amp;gt;/fd/ 和 fdinfo/)&lt;/strong&gt;: fd 是一个目录，里面包含了指向该进程当前打开的所有文件描述符的符号链接。链接的名称就是文件描述符的数字（如 0, 1, 2 分别代表标准输入、输出、错误），链接的目标则指明了它实际代表的文件、管道或套接字。而 fdinfo 目录下则包含了与 fd 中每个描述符对应的文件，记录了更详细的状态信息，比如文件的当前读写位置（offset）、打开时的标志位（flags）等。CRIU 需要读取这些信息来保存和恢复进程打开的文件状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程状态报告 (/proc/&amp;lt;pid&amp;gt;/stat)&lt;/strong&gt;: 这个文件以一行文本的形式，提供了关于进程的大量状态信息，由空格分隔。包括进程名、状态（运行、睡眠、僵尸等）、父进程 PID、进程组 ID、使用的内存量、CPU 时间统计等等。CRIU 用它来获取进程的基本属性和运行统计。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程成员列表 (/proc/&amp;lt;pid&amp;gt;/task/)&lt;/strong&gt;: 对于多线程进程，这个目录非常重要。它下面包含了以该进程下&lt;strong&gt;所有线程的 TID&lt;/strong&gt; 命名的子目录。通过遍历这个目录，CRIU 可以识别出一个进程包含的所有线程（任务），并对每个线程进行单独的状态捕获。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子进程记录 (/proc/&amp;lt;pid&amp;gt;/task/&amp;lt;tid&amp;gt;/children)&lt;/strong&gt;: 这个文件（位于特定线程目录下）记录了由该线程直接创建的所有子进程的 PID 列表。通过递归地读取这个文件，CRIU 能够准确地构建出完整的进程树或进程家族。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存映射文件访问 (/proc/&amp;lt;pid&amp;gt;/map_files/)&lt;/strong&gt;: 这个目录包含了指向进程内存中通过文件映射（mmap）方式加载的实际文件的符号链接。链接的名称对应 maps 文件中的地址范围。这为 CRIU 提供了一种可靠的方式来访问和读取这些映射文件的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过组合利用 /proc 文件系统提供的这些（以及其他未列出的）信息源，CRIU 能够像侦探一样，细致入微地收集目标进程及其所有线程、子进程在 Checkpoint 时刻的完整状态。没有 /proc 这个强大的“透视镜”，实现用户空间的 Checkpoint/Restore 将会困难得多。&lt;/p&gt;
&lt;p&gt;了解了如何通过 /proc 获取进程状态后，我们接下来将关注进程运行的“舞台”——内存管理，以及进程如何与外部世界交互的“管道”——文件描述符。&lt;/p&gt;
&lt;h2 id=&#34;ptrace-系统调用掌控进程的遥控器&#34;&gt;
    &lt;a href=&#34;#ptrace-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e6%8e%8c%e6%8e%a7%e8%bf%9b%e7%a8%8b%e7%9a%84%e9%81%a5%e6%8e%a7%e5%99%a8&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    ptrace 系统调用：掌控进程的“遥控器”
&lt;/h2&gt;&lt;p&gt;通过 /proc 文件系统，我们获得了观察运行中进程内部状态的强大能力，就像有了一副“透视镜”。但这还不够，要实现像 CRaC/CRIU 的 Checkpoint/Restore，我们不仅需要&lt;strong&gt;观察&lt;/strong&gt;，还需要能够&lt;strong&gt;控制&lt;/strong&gt;和&lt;strong&gt;操纵&lt;/strong&gt;目标进程——在合适的时机让它暂停，读取甚至修改它的内存和寄存器状态，甚至强制它执行某些操作。这时，Linux 提供了一个终极武器，也是一个颇具争议但极其强大的系统调用：ptrace (process trace)。&lt;/p&gt;
&lt;p&gt;ptrace 提供了一种机制，允许一个进程（称为 &lt;strong&gt;tracer&lt;/strong&gt;，追踪者）去&lt;strong&gt;观察和控制&lt;/strong&gt;另一个进程（称为 &lt;strong&gt;tracee&lt;/strong&gt;，被追踪者）的执行，检查和改变 tracee 的内存和寄存器。你可以把它想象成一个赋予 tracer 进程的“远程控制器”，可以用来遥控 tracee 进程的一举一动。&lt;/p&gt;
&lt;p&gt;这个系统调用是许多底层工具的基石：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;调试器 (Debuggers)&lt;/strong&gt;：像 GDB 这样的调试器，其核心功能（设置断点、单步执行、检查变量值、查看调用栈等）几乎完全依赖于 ptrace。调试器就是一个 tracer 进程，而被调试的程序就是 tracee。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统调用追踪工具 (System Call Tracers)&lt;/strong&gt;：strace 命令能够显示一个进程执行的所有系统调用及其参数和返回值，这也是通过 ptrace 实现的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRIU (Checkpoint/Restore In Userspace)&lt;/strong&gt;：正如我们之前提到的，CRIU 大量使用 ptrace 来完成那些仅靠 /proc 无法完成的任务，比如精确地暂停进程、获取和恢复寄存器状态、注入“寄生代码”等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ptrace 本身是一个非常复杂的系统调用，它的行为由传递给它的第一个参数 request 决定。下面我们介绍一些它提供的关键能力，这些能力对于理解 CRIU 的工作至关重要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;建立追踪关系 (Attaching)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;PTRACE_ATTACH 或 PTRACE_SEIZE：这是 tracer 控制 tracee 的第一步。Tracer 使用这两个请求之一来“附着”到目标 tracee 进程上。一旦附着成功，tracee 就会暂停下来，并且其状态变化（如收到信号、执行系统调用）都会通知 tracer。PTRACE_SEIZE 是一个较新的、更推荐的方式，它避免了 PTRACE_ATTACH 中使用 SIGSTOP 信号可能带来的副作用，控制更为精确。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读写寄存器 (Reading/Writing Registers)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;PTRACE_GETREGS, PTRACE_GETFPREGS 等：允许 tracer 读取 tracee 当前的通用寄存器（如指令指针 EIP/RIP、栈指针 ESP/RSP 等）、浮点寄存器等 CPU 状态。&lt;/li&gt;
&lt;li&gt;PTRACE_SETREGS, PTRACE_SETFPREGS 等：允许 tracer 修改 tracee 的寄存器状态。这对于恢复进程到某个精确的执行点至关重要，CRIU 在 Restore 阶段就需要用它来设置好恢复后进程的 CPU 上下文。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读写内存 (Reading/Writing Memory)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;PTRACE_PEEKDATA, PTRACE_PEEKTEXT：允许 tracer 读取 tracee 进程地址空间中任意位置的数据（通常以字长为单位）。&lt;/li&gt;
&lt;li&gt;PTRACE_POKEDATA, PTRACE_POKETEXT：允许 tracer 向 tracee 进程地址空间中任意位置写入数据。CRIU 正是利用这个能力，在 Checkpoint 阶段向目标进程注入“寄生代码”（一段帮助收集内部信息的二进制代码），并在 Restore 阶段将快照中的内存数据写回进程空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制执行 (Controlling Execution)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;PTRACE_CONT：让暂停的 tracee 继续执行。可以选择是否传递一个信号给 tracee。&lt;/li&gt;
&lt;li&gt;PTRACE_SYSCALL：让 tracee 继续执行，直到它进入或退出下一个系统调用时再次暂停，并通知 tracer。strace 就是基于此工作的。CRIU 也用它来精确控制目标进程执行特定的系统调用（如 mmap, munmap）来辅助内存的 Checkpoint 和 Restore。&lt;/li&gt;
&lt;li&gt;PTRACE_SINGLESTEP：让 tracee 执行&lt;strong&gt;一条&lt;/strong&gt;机器指令，然后再次暂停。这是调试器实现单步执行的基础。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解除追踪关系 (Detaching)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;PTRACE_DETACH：Tracer 结束对 tracee 的追踪。Tracee 会恢复正常执行，就像从未被追踪过一样（除非 tracer 修改了它的状态）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这些强大的（甚至可以说是危险的）能力，ptrace 赋予了 CRIU 超越普通进程权限的操作能力。它不仅能通过 /proc 看到进程的状态，更能像外科医生一样，精确地暂停进程、检查和修改其内部状态（内存和寄存器），甚至“借用”目标进程的上下文来执行特定操作（如注入代码、强制执行系统调用）。正是 ptrace 的存在，使得在用户空间实现复杂且精确的进程 Checkpoint/Restore 成为可能，也间接支撑了 CRaC 技术的实现。&lt;/p&gt;
&lt;p&gt;当然，ptrace 的强大也意味着潜在的风险，操作系统通常会对其使用施加一些安全限制（例如，一个普通用户进程不能随意 ptrace 其他用户的进程或特权进程）。&lt;/p&gt;
&lt;p&gt;理解了 ptrace 的核心能力后，我们对 CRIU 如何完成那些看似不可能的任务，应该有了更深的体会。接下来，我们将把前面介绍的知识点串联起来，看看 CRIU 具体是如何一步步实现 Checkpoint 和 Restore 的。&lt;/p&gt;
&lt;h2 id=&#34;criu-如何实现-checkpoint-和-restore&#34;&gt;
    &lt;a href=&#34;#criu-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0-checkpoint-%e5%92%8c-restore&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRIU 如何实现 Checkpoint 和 Restore？
&lt;/h2&gt;&lt;p&gt;现在，我们已经了解了 Linux 的进程线程模型、强大的 /proc 文件系统以及拥有“遥控”能力的 ptrace 系统调用。是时候将这些知识点串联起来，看看 CRIU (Checkpoint/Restore In Userspace) 是如何利用它们来施展“冻结” (Checkpoint) 和“复苏” (Restore) 进程的魔法了。&lt;/p&gt;
&lt;h3 id=&#34;checkpoint-冻结过程为进程拍下精确快照&#34;&gt;
    &lt;a href=&#34;#checkpoint-%e5%86%bb%e7%bb%93%e8%bf%87%e7%a8%8b%e4%b8%ba%e8%bf%9b%e7%a8%8b%e6%8b%8d%e4%b8%8b%e7%b2%be%e7%a1%ae%e5%bf%ab%e7%85%a7&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Checkpoint (冻结过程)：为进程拍下精确快照
&lt;/h3&gt;&lt;p&gt;当 CRIU 被要求对一个进程（及其后代）进行 Checkpoint 时，它会执行一系列精心设计的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;识别目标家族&lt;/strong&gt;: 首先，CRIU 需要确定要冻结的完整目标。它从用户指定的根进程 PID 开始，通过递归地读取 /proc/&amp;lt;pid&amp;gt;/task/&amp;lt;tid&amp;gt;/children 文件，像剥洋葱一样，找出所有相关的子进程和线程，构建出完整的&lt;strong&gt;进程树&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全体“立正”&lt;/strong&gt;: 接下来，CRIU 需要让这个庞大家族的所有成员都暂停下来。它使用 ptrace(PTRACE_SEIZE, &amp;hellip;) 附着到进程树中的&lt;strong&gt;每一个任务&lt;/strong&gt;（进程/线程）上。PTRACE_SEIZE 会让这些任务在下一次内核有机会介入时（比如系统调用或中断）进入暂停状态，并且这种暂停方式比老的 PTRACE_ATTACH 更为干净，不依赖 SIGSTOP 信号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信息大搜集&lt;/strong&gt;: 进程树被冻结后，CRIU 开始扮演“情报员”的角色，通过 /proc 文件系统和 ptrace 收集每个任务的详细状态：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存布局&lt;/strong&gt;: 解析 /proc/&amp;lt;pid&amp;gt;/maps 和 smaps 获取虚拟内存区域（VMA）的地址、大小、权限、映射来源（文件或匿名）等信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件描述符&lt;/strong&gt;: 读取 /proc/&amp;lt;pid&amp;gt;/fd/ 和 fdinfo/ 目录，记录下所有打开的文件、管道、套接字及其类型、路径、当前读写位置、标志位等状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程/线程核心状态&lt;/strong&gt;: 通过 /proc/&amp;lt;pid&amp;gt;/stat 获取进程的基本属性，更重要的是，使用 ptrace(PTRACE_GETREGS, &amp;hellip;) 和 PTRACE_GETFPREGS 等命令，直接读取每个任务暂停时的&lt;strong&gt;CPU 寄存器&lt;/strong&gt;内容（包括指令指针、栈指针、通用寄存器等）。这是确保恢复后能从正确位置继续执行的关键。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他资源&lt;/strong&gt;: 收集如信号处理器设置、定时器、凭证（UID/GID）、命名空间隶属关系等信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存内容转储 (可能需要“寄生虫”帮忙)&lt;/strong&gt;: 获取内存布局只是第一步，还需要把这些内存区域里的&lt;strong&gt;实际数据&lt;/strong&gt;保存下来。对于大部分内存区域，CRIU 可以通过 /proc/&amp;lt;pid&amp;gt;/mem 文件或者 process_vm_readv 系统调用来读取。但对于某些特殊或私有的内存区域，或者为了获取某些无法从外部探测的内部状态（如精确的文件描述符状态），直接读取可能受限或效率不高。这时，CRIU 会祭出它的“杀手锏”——&lt;strong&gt;寄生代码 (Parasite Code)&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;CRIU 使用 ptrace 在目标进程的地址空间中分配一小块内存（通过强制目标进程执行 mmap 系统调用）。&lt;/li&gt;
&lt;li&gt;然后，使用 ptrace(PTRACE_POKEDATA, &amp;hellip;) 将一段预先编译好的、与位置无关的（PIE）二进制代码（寄生代码）写入这块内存。&lt;/li&gt;
&lt;li&gt;最后，通过 ptrace 修改目标进程的指令指针，让它跳转执行这段寄生代码。&lt;/li&gt;
&lt;li&gt;寄生代码运行在目标进程的上下文中，拥有访问其所有资源的权限，可以高效地完成内存转储、收集内部信息等任务，并将结果传递给 CRIU。任务完成后，寄生代码通过 rt_sigreturn 系统调用恢复目标进程之前的寄存器状态，CRIU 再强制目标进程执行 munmap 清理掉寄生代码占用的内存，最后 ptrace(PTRACE_DETACH, &amp;hellip;) 脱离，整个过程对目标进程来说几乎是“无痕”的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写入镜像文件&lt;/strong&gt;: CRIU 将收集到的所有状态信息（内存布局、寄存器、文件描述符状态、内存数据等）组织起来，写入到磁盘上的一系列镜像文件中。这些文件共同构成了进程在 Checkpoint 时刻的完整快照。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(可选) 终止原进程&lt;/strong&gt;: 在某些场景下（比如 CRaC 的默认行为），Checkpoint 完成后，原始的 JVM 进程会被 CRIU 终止。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;restore-复苏过程从快照重建鲜活进程&#34;&gt;
    &lt;a href=&#34;#restore-%e5%a4%8d%e8%8b%8f%e8%bf%87%e7%a8%8b%e4%bb%8e%e5%bf%ab%e7%85%a7%e9%87%8d%e5%bb%ba%e9%b2%9c%e6%b4%bb%e8%bf%9b%e7%a8%8b&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Restore (复苏过程)：从快照重建鲜活进程
&lt;/h3&gt;&lt;p&gt;Restore 过程可以看作是 Checkpoint 的逆操作，它更加复杂，需要精确地重建进程状态：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;解析镜像，规划蓝图&lt;/strong&gt;: CRIU 首先读取 Checkpoint 生成的镜像文件，分析进程间的关系（父子、共享资源等），制定恢复计划。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;搭建骨架&lt;/strong&gt;: CRIU 严格按照镜像中记录的进程树结构，通过多次调用 fork() 来创建新的进程。在这个阶段，通常只创建进程的主线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复基本资源&lt;/strong&gt;: 对于每个新创建的进程，CRIU 开始恢复大部分状态：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件描述符&lt;/strong&gt;: 根据镜像信息重新打开文件（可能需要验证路径有效性）、创建管道和套接字，并设置好它们的状态（如文件偏移量）。对于共享的文件描述符，需要确保它们指向同一个内核对象（可能用到 SCM_RIGHTS 等技术）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存映射 (初步)&lt;/strong&gt;: 使用 mmap() 根据镜像中的 VMA 信息创建内存区域。对于私有内存，会先映射匿名内存，稍后再填充数据；对于文件映射，会重新映射相应的文件。此时映射的虚拟地址可能还不是最终的目标地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命名空间&lt;/strong&gt;: 如果进程使用了非默认的命名空间，CRIU 会负责创建或加入这些命名空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他&lt;/strong&gt;: 恢复工作目录、根目录、信号处理器等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键步骤：切换上下文与精细恢复&lt;/strong&gt;: 这是 Restore 中最精妙也最困难的部分。因为执行 Restore 操作的 CRIU 代码本身可能就位于需要被恢复内容覆盖的内存区域。为了解决这个问题：
&lt;ul&gt;
&lt;li&gt;CRIU 会找到一块临时的、安全的内存“空地”，加载一小段自包含的、位置无关的&lt;strong&gt;恢复器代码 (Restorer Context)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;然后，通过一次跳转，将 CPU 的控制权交给这段恢复器代码。&lt;/li&gt;
&lt;li&gt;在恢复器代码的控制下，进行最后也是最关键的恢复步骤：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;精确内存布局&lt;/strong&gt;: 使用 mremap() 将之前映射在临时地址的内存移动到镜像中记录的&lt;strong&gt;最终虚拟地址&lt;/strong&gt;。使用 mmap() 在正确的位置创建文件映射和共享内存映射。至此，进程的内存布局与 Checkpoint 时完全一致。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;填充内存数据&lt;/strong&gt;: 将镜像文件中保存的内存页数据，通过 read() 或类似方式写回到相应的内存区域。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复线程&lt;/strong&gt;: 在最终的内存布局中，根据保存的状态创建并恢复进程的所有其他线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复寄存器&lt;/strong&gt;: 使用 ptrace(PTRACE_SETREGS, &amp;hellip;)（或者在恢复器代码内部通过特定机制）将每个线程的 CPU 寄存器（特别是指令指针 IP/PC 和栈指针 SP）&lt;strong&gt;精确地设置&lt;/strong&gt;为 Checkpoint 时保存的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复其他细节&lt;/strong&gt;: 恢复定时器、凭证等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;“点火”启动&lt;/strong&gt;: 当所有状态都恢复完毕，恢复器代码会执行最后一步——通常是一个特殊的返回或跳转指令，将 CPU 的控制权彻底交还给恢复后的进程（主线程）。由于指令指针已经被精确设置，进程会从 Checkpoint 时被中断的那条指令&lt;strong&gt;无缝地继续执行&lt;/strong&gt;，仿佛从未被打断过。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管理 Restore 流程 (execv 链)&lt;/strong&gt;: 前面提到，CRaC 的 java -XX:CRaCRestoreFrom=&amp;hellip; 命令启动后，会通过 criuengine 这个辅助程序来协调 Restore。这个过程涉及多次 execv 调用：初始 Java 命令 execv 变成 criuengine restore，后者再 execv 变成 criu restore 来执行真正的恢复操作。当 criu restore 成功恢复目标 JVM 进程后，它会再次 execv 变成 criuengine restorewait，这个最终的进程负责等待恢复后的 JVM 进程结束，并将 JVM 的退出状态传递回去。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这一系列复杂而精密的步骤，结合对 /proc 的读取和对 ptrace 的深度运用，CRIU 实现了在用户空间对运行中进程进行快照和恢复的强大能力，为 CRaC 技术的实现奠定了坚实的基础。&lt;/p&gt;
&lt;p&gt;理解了 CRIU 的基本工作原理后，我们就能更好地理解 CRaC 为何还需要一个“协调”层。接下来，我们将探讨 CRaC 的 Resource API 存在的意义。&lt;/p&gt;
&lt;h2 id=&#34;crac-如何指挥-criu&#34;&gt;
    &lt;a href=&#34;#crac-%e5%a6%82%e4%bd%95%e6%8c%87%e6%8c%a5-criu&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 如何指挥 CRIU
&lt;/h2&gt;&lt;p&gt;我们已经了解了 CRIU 如何利用 Linux 的底层机制来实现进程的 Checkpoint 和 Restore。但 CRaC (Coordinated Restore at Checkpoint) 本身并不直接执行这些复杂的底层操作。相反，CRaC 更像是一个&lt;strong&gt;指挥官&lt;/strong&gt;，它通过协调 JVM 内部状态和外部资源，并在恰当的时机&lt;strong&gt;调用&lt;/strong&gt; CRIU 来完成实际的“冻结”与“复苏”工作。这种调用通常是通过一个辅助程序（在 OpenJDK CRaC 实现中称为 criuengine）来间接完成的。这个过程中，Linux 的进程创建、替换和管理技术，特别是 fork、execv 和 double fork，扮演了至关重要的角色。&lt;/p&gt;
&lt;h3 id=&#34;checkpoint-流程中的进程之舞-double-fork&#34;&gt;
    &lt;a href=&#34;#checkpoint-%e6%b5%81%e7%a8%8b%e4%b8%ad%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%b9%8b%e8%88%9e-double-fork&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Checkpoint 流程中的进程之舞 (double fork)
&lt;/h3&gt;&lt;p&gt;当用户通过 jcmd &amp;lt;pid&amp;gt; JDK.checkpoint 命令触发 CRaC 的 Checkpoint 时，一场精心编排的进程交互就开始了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;JVM 内部准备&lt;/strong&gt;: JVM 接收到命令后，会执行一些准备工作，比如触发一次 Full GC 来减小镜像体积，然后进入一个全局安全点（Safepoint），暂停所有 Java 线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动外部引擎&lt;/strong&gt;: JVM 调用 fork() 创建一个子进程 (我们称之为 P1)，这个子进程 P1 的任务是执行 criuengine checkpoint 命令。JVM 主进程则会暂停，等待 P1 的某种形式的完成信号或退出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;double fork 登场&lt;/strong&gt;: 这里的关键在于 criuengine (P1) 如何调用 criu dump 来冻结原始的 JVM 进程。如果 P1 直接调用 criu dump，那么 criu 进程就会是 JVM 的孙子进程，仍然属于同一个进程组，这在某些情况下可能导致问题（比如尝试冻结自己所在的进程组）。为了彻底解耦，criuengine 使用了 double fork 技巧：
&lt;ul&gt;
&lt;li&gt;P1 (criuengine checkpoint) 调用 fork() 创建子进程 P2。然后 P1 会等待 P2 退出。&lt;/li&gt;
&lt;li&gt;P2 &lt;strong&gt;再次&lt;/strong&gt;调用 fork() 创建孙子进程 P3。&lt;/li&gt;
&lt;li&gt;P2 &lt;strong&gt;立即退出&lt;/strong&gt; (exit())。&lt;/li&gt;
&lt;li&gt;P1 检测到 P2 退出后，P1 也退出。&lt;/li&gt;
&lt;li&gt;此时，P3 成为了&lt;strong&gt;孤儿进程&lt;/strong&gt;，其父进程被系统 init 进程（PID 1）接管。P3 现在与原始的 JVM 进程（它的“曾祖父”）在进程树上已经没有直接关系了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行冻结&lt;/strong&gt;: 成为孤儿的 P3 进程现在可以安全地执行 criu dump -t &amp;lt;jvm_pid&amp;gt; &amp;hellip; 命令，目标直指原始的、正在等待的 JVM 进程。criu 利用我们之前讨论的 /proc 和 ptrace 技术，将 JVM 的完整状态保存到镜像文件中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终结与等待&lt;/strong&gt;: criu dump 在成功创建镜像后，通常会&lt;strong&gt;杀死&lt;/strong&gt; (kill) 被冻结的原始 JVM 进程。而原始 JVM 进程在 fork 出 P1 后，实际上并没有完全阻塞，它会继续执行一小段代码，通常是进入一个 sigwaitinfo() 调用，等待一个特定的信号（RESTORE_SIGNAL），这个信号只有在未来的 Restore 过程中才会被发送。但在此之前，它就被 criu dump 结束了生命。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过 double fork，CRaC 巧妙地确保了执行冻结操作的 criu 进程独立于被冻结的 JVM 进程树之外，保证了 Checkpoint 操作的干净和可靠。&lt;/p&gt;
&lt;h3 id=&#34;restore-流程中的进程变身-execv-链&#34;&gt;
    &lt;a href=&#34;#restore-%e6%b5%81%e7%a8%8b%e4%b8%ad%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%8f%98%e8%ba%ab-execv-%e9%93%be&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Restore 流程中的进程“变身” (execv 链)
&lt;/h3&gt;&lt;p&gt;Restore 过程则展示了 execv 系统调用的威力，它允许一个进程用一个全新的程序映像替换自己，实现“原地变身”：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;启动 Restore 命令&lt;/strong&gt;: 用户执行 java -XX:CRaCRestoreFrom=&amp;lt;checkpoint_dir&amp;gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JVM 的“改道”&lt;/strong&gt;: 这个 Java 命令启动的 JVM 进程（我们称之为 P1）在非常早期的初始化阶段，就会检测到 -XX:CRaCRestoreFrom 参数。它&lt;strong&gt;不会&lt;/strong&gt;继续执行标准的 JVM 启动流程，而是立即“改道”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第一次变身 (execv)&lt;/strong&gt;: P1 调用 execv()，将其自身替换为 criuengine restore 程序。此时，原来的 java 进程 P1 不复存在，取而代之的是运行着 criuengine restore 代码的进程（我们称之为 P2，尽管 PID 可能与 P1 相同）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二次变身 (execv)&lt;/strong&gt;: P2 (criuengine restore) 负责解析参数，准备好调用 criu 所需的环境，然后再次调用 execv()，将自身替换为 criu restore 程序（我们称之为 P3）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRIU 执行恢复&lt;/strong&gt;: P3 (criu restore) 读取镜像文件，利用 fork、mmap、ptrace 等技术，在内存中逐步重建 JVM 进程的状态。这个恢复过程可能相当复杂，涉及创建新的进程（恢复后的 JVM），设置内存，恢复文件描述符，恢复线程等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唤醒与交接&lt;/strong&gt;: 在恢复的目标 JVM 进程状态基本就绪，但尚未开始执行用户代码时，P3 (criu restore) 会通过其配置的动作脚本（通常是 criuengine 自身）向恢复后的 JVM 进程发送一个特定的信号（如 RESTORE_SIGNAL），这个信号会唤醒 JVM 内部等待的代码（还记得 Checkpoint 最后 JVM 等待的 sigwaitinfo 吗？恢复后的 JVM 就从这里“醒来”）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三次变身 (execv)&lt;/strong&gt;: 在成功恢复 JVM 并发送唤醒信号后，P3 (criu restore) 进程的任务也即将结束。根据启动时通过 --exec-cmd 参数的指示，它会执行最后一次 execv()，将自身替换为 criuengine restorewait 程序（我们称之为 P4）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;守望者 (waitpid)&lt;/strong&gt;: P4 (criuengine restorewait) 的唯一使命就是扮演一个“守望者”。它知道刚刚恢复的 JVM 进程的 PID，然后调用 waitpid() 等待这个 JVM 进程结束。当 JVM 最终退出时，P4 会获取其退出状态，并以相同的状态退出。这样，最初启动 java -XX:CRaCRestoreFrom=&amp;hellip; 命令的用户就能得到恢复后 JVM 的最终执行结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这个 execv 调用链中，控制权被平滑地从初始的 Java 命令传递给 criuengine，再到 criu 本身，最后交接给负责等待的 criuengine restorewait。整个过程中，进程的身份（执行的程序）不断变化，但通常是在同一个进程 ID 下完成（除了 criu restore 内部重建 JVM 时会创建新进程），高效地利用了现有的进程上下文来执行不同的任务阶段。&lt;/p&gt;
&lt;p&gt;总结来说，CRaC 并非魔法，而是建立在对 Linux 进程生命周期管理的深刻理解和巧妙运用之上。它通过辅助程序，精确地编排 fork、execv、waitpid 等系统调用，指挥 CRIU 这位“底层大师”完成复杂的 Checkpoint 和 Restore 操作，最终实现了 Java 应用启动性能的巨大飞跃。&lt;/p&gt;
&lt;h2 id=&#34;总结linux-系统编程是-crac-的基石&#34;&gt;
    &lt;a href=&#34;#%e6%80%bb%e7%bb%93linux-%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e6%98%af-crac-%e7%9a%84%e5%9f%ba%e7%9f%b3&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    总结：Linux 系统编程是 CRaC 的基石
&lt;/h2&gt;&lt;p&gt;回顾全文，我们一起探索了 CRaC 技术背后所依赖的关键 Linux 系统编程概念。从基本的进程与线程模型、生命周期管理（fork, execv, waitpid, double fork），到强大的进程状态“透视镜” /proc 文件系统，再到能够精细控制进程的“遥控器”ptrace 系统调用，这些都是 Linux 提供的底层能力。&lt;/p&gt;
&lt;p&gt;我们看到，CRIU 正是巧妙地组合运用了这些机制，才得以在用户空间实现对运行中进程进行精确 Checkpoint 和 Restore 的复杂操作。而 CRaC 则更进一步，通过协调 JVM 内部状态和外部资源，并指挥 CRIU 完成核心的冻结与复苏任务，最终达成了大幅优化 Java 应用启动性能的目标。&lt;/p&gt;
&lt;p&gt;因此，理解这些 Linux 系统编程的知识，不仅能帮助我们揭开 CRaC 实现原理的神秘面纱，更能让我们体会到现代软件技术创新往往是建立在对底层系统深刻理解和创造性应用的基础之上。希望本文能为您打开一扇通往 Linux 系统编程世界的小窗，激发您进一步探索的兴趣。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CRaC 技术深度解析</title>
        <link>https://mazhen.tech/p/crac-%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
        <pubDate>Mon, 28 Apr 2025 16:56:24 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/crac-%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
        <description>&lt;h2 id=&#34;引言&#34;&gt;
    &lt;a href=&#34;#%e5%bc%95%e8%a8%80&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    引言
&lt;/h2&gt;&lt;p&gt;在现代软件架构中，尤其是在微服务和 &lt;code&gt;Serverless&lt;/code&gt; 计算领域，应用的快速启动和高效资源利用变得至关重要。Java 作为企业级应用开发的首选语言，尽管拥有庞大的生态和丰富的开发工具，但在启动速度方面始终面临挑战。与原生编译语言和部分脚本语言相比，Java 应用在启动过程中存在明显的性能差距。“冷启动”，即应用实例首次启动，或是从休眠状态唤醒时，系统需要经历复杂的初始化过程，这不仅会导致显著的时间延迟，还会引发资源消耗的峰值。&lt;/p&gt;
&lt;p&gt;那么，为什么 Java 应用的冷启动会比较慢呢？这并不仅仅是一个单一的步骤，而是涉及多个阶段，通常可以分为“&lt;strong&gt;JVM 启动&lt;/strong&gt;”、“&lt;strong&gt;应用启动&lt;/strong&gt;”和“&lt;strong&gt;应用预热&lt;/strong&gt;”三个主要过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;JVM 启动 (JVM Start - 相对较快):&lt;/strong&gt; 这个阶段主要是 Java 虚拟机（JVM）自身的初始化，包括加载核心库、初始化内存管理（如堆、垃圾收集器）、设置内部数据结构以及进行一些早期的基础优化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用启动 (Application Start - 需要一些时间):&lt;/strong&gt; 在 JVM 准备好之后，开始加载应用程序自身的类和所有依赖库。这是一个密集的过程，涉及查找、验证和解析大量的类。紧接着，应用框架（如 Spring Boot）会执行其初始化逻辑：扫描组件、解析配置、构建依赖注入容器、初始化线程池、建立数据库连接等。这个阶段完成后，应用通常可以处理第一个请求，因此这个阶段的耗时常被称为“&lt;strong&gt;首次响应时间（Time to first response）&lt;/strong&gt;”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用预热 (Application Warmup - 需要较长时间):&lt;/strong&gt; 即使应用能够响应第一个请求，它通常还远未达到最佳性能。Java 的高性能依赖于即时编译器 &lt;strong&gt;JIT&lt;/strong&gt;（Just-In-Time Compiler）。&lt;code&gt;JIT&lt;/code&gt; 会在运行时监控代码执行情况，识别“热点（hotspot）”代码（频繁执行的方法），并将其编译成本地机器码以提升效率。这个编译过程是分层的（例如，从解释执行到 C1 编译，再到更深层次优化的 C2 编译），需要时间和实际的业务负载来触发和完成。此外，还可能涉及缓存的填充、连接池的预热等。只有在 &lt;code&gt;JIT&lt;/code&gt; 完成了关键代码的编译优化，并且应用处理了一定量的请求后，才能达到其峰值性能。这个过程被称为“&lt;strong&gt;应用预热&lt;/strong&gt;”。期间还可能伴随着编译/反优化（Deoptimisations）和垃圾回收暂停（Garbage Collector pauses）带来的性能波动。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504241446155.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM PERFORMANCE GRAPH&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这三个阶段叠加起来，特别是“应用启动”和“应用预热”阶段的耗时，导致了 Java 应用的冷启动时间较长，并且需要一段时间才能达到理想的处理能力。对于需要快速响应和弹性伸缩的微服务和 Serverless 场景，这种延迟是亟待解决的痛点。缓慢的启动影响扩容效率，而漫长的预热则意味着在达到峰值性能前，应用的处理能力受限且响应时间不稳定。&lt;/p&gt;
&lt;p&gt;正是为了解决这一痛点，&lt;strong&gt;CRaC (Coordinated Restore at Checkpoint)&lt;/strong&gt; 技术应运而生。它并非逐一优化上述启动和预热的各个环节，而是另辟蹊径：&lt;strong&gt;通过在应用程序完成初始化并充分“预热”达到接近峰值性能状态后，创建一个包含整个 JVM 进程状态的“快照”（Checkpoint），并在需要新实例时直接从这个快照快速“恢复”（Restore）&lt;/strong&gt;。这种方式几乎完全绕过了耗时的“应用启动”和“应用预热”过程，有望将启动并达到高性能状态的时间缩短到毫秒级别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504241459599.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;MICROSERVICE ENVIRONMENT&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;本文旨在深入探讨 CRaC 技术，从其核心原理、与 AOT 等技术的对比、具体实现机制、实际使用方法，到其在不同场景下的应用和生态发展，全面解析这一旨在革新 Java 启动与预热性能的前沿技术。&lt;/p&gt;
&lt;h2 id=&#34;一crac-概述告别漫长等待&#34;&gt;
    &lt;a href=&#34;#%e4%b8%80crac-%e6%a6%82%e8%bf%b0%e5%91%8a%e5%88%ab%e6%bc%ab%e9%95%bf%e7%ad%89%e5%be%85&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    一、CRaC 概述：告别漫长等待
&lt;/h2&gt;&lt;h3 id=&#34;什么是-crac&#34;&gt;
    &lt;a href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af-crac&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    什么是 CRaC？
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://openjdk.org/projects/crac/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CRaC（Coordinated Restore at Checkpoint）&lt;/a&gt;是 OpenJDK 的一个项目，旨在通过创新的方式显著缩短 Java 应用的启动时间。CRaC  的核心思想是：在应用程序运行到某个理想状态（通常是初始化完成并经过预热后）时，创建一个包含整个 JVM 进程内存状态（包括堆内存、已加载类、已编译代码、线程状态等）的快照，即“检查点”（&lt;strong&gt;Checkpoint&lt;/strong&gt;），并将其持久化。当需要启动新实例时，不再执行传统的启动流程，而是直接从该快照“恢复”（&lt;strong&gt;Restore&lt;/strong&gt;）JVM 状态。这个恢复过程跳过了大部分 JVM 初始化、类加载和应用初始化步骤，从而极大地加快了启动速度。其中，“协调”（&lt;strong&gt;Coordinated&lt;/strong&gt;）是关键，意味着 JVM 需要与应用程序通过特定 API 进行交互，以确保在创建检查点和恢复时，外部资源（如文件句柄、网络连接）能够被妥善地关闭和重新建立。&lt;/p&gt;
&lt;h3 id=&#34;crac-的核心优势&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e6%a0%b8%e5%bf%83%e4%bc%98%e5%8a%bf&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的核心优势
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;极速启动：&lt;/strong&gt; 这是 CRaC 最显著的优势。传统 Java 应用启动可能需要数秒甚至数十秒，而使用 CRaC 从快照恢复，可以将启动时间缩短到数百毫秒甚至更短，接近原生应用的启动速度。因为它直接跳过了 JVM 初始化、类加载、应用初始化和大部分 JIT 预热等耗时环节。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;即时峰值性能：&lt;/strong&gt; 由于 &lt;strong&gt;Checkpoint&lt;/strong&gt; 通常是在应用已经完成 JIT 编译优化和预热后创建的，因此恢复后的实例几乎可以立即达到其最佳性能状态，避免了传统启动后漫长的“预热”等待期。这对于需要快速响应请求的场景（如 Serverless）尤其重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;潜在的资源节约：&lt;/strong&gt; 传统的启动和预热过程通常是 CPU 密集型的。通过 CRaC，这些密集的计算被转移到了 &lt;strong&gt;Checkpoint&lt;/strong&gt; 创建阶段（通常在非高峰时段或构建过程中完成），而在实际需要启动新实例时（如服务扩容或函数调用时），资源消耗显著降低，有助于提高资源利用率和降低成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;crac-的关键概念&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e5%85%b3%e9%94%ae%e6%a6%82%e5%bf%b5&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的关键概念
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Checkpoint (检查点):&lt;/strong&gt; 指创建 JVM 进程状态快照的操作，以及生成的包含该状态的持久化文件或镜像。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Restore (恢复):&lt;/strong&gt; 指从一个已存在的 &lt;strong&gt;Checkpoint&lt;/strong&gt; 快速加载 JVM 状态，启动一个新 JVM 实例的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Coordination (协调):&lt;/strong&gt; 指 JVM 与应用程序之间通过特定 API（&lt;code&gt;jdk.crac&lt;/code&gt; 包）进行的交互。应用程序需要实现接口来管理其资源（如关闭网络连接、文件句柄等）以确保 &lt;strong&gt;Checkpoint&lt;/strong&gt; 的一致性，并在 &lt;strong&gt;Restore&lt;/strong&gt; 后重新建立这些资源。这是保证恢复后的应用能正常工作的关键。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二crac-vs-aot启动优化的两条路径&#34;&gt;
    &lt;a href=&#34;#%e4%ba%8ccrac-vs-aot%e5%90%af%e5%8a%a8%e4%bc%98%e5%8c%96%e7%9a%84%e4%b8%a4%e6%9d%a1%e8%b7%af%e5%be%84&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    二、CRaC vs. AOT：启动优化的两条路径
&lt;/h2&gt;&lt;p&gt;为了解决 Java 启动慢和预热长的问题，业界探索了不同的优化路径。除了 &lt;strong&gt;CRaC&lt;/strong&gt;，另一种广受关注的技术是 &lt;strong&gt;AOT&lt;/strong&gt;（Ahead-of-Time）编译，特别是以 &lt;strong&gt;GraalVM Native Image&lt;/strong&gt; 为代表的实现。两者都旨在缩短启动时间，但它们的原理和特性却大相径庭。&lt;/p&gt;
&lt;h3 id=&#34;aot-技术简介&#34;&gt;
    &lt;a href=&#34;#aot-%e6%8a%80%e6%9c%af%e7%ae%80%e4%bb%8b&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    AOT 技术简介
&lt;/h3&gt;&lt;p&gt;AOT 编译的核心思想是，在应用程序运行之前，就将其 Java 字节码直接编译成本地机器码，生成一个独立的可执行文件（例如 GraalVM Native Image）。这样做带来的主要优势是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无需解释字节码 (No interpreting bytecodes):&lt;/strong&gt; 启动时直接执行本地代码，跳过了 JVM 解释执行字节码的阶段。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无需运行时编译 (No runtime compilation of code):&lt;/strong&gt; 消除了 JIT 在运行时编译代码带来的 CPU 开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动即全速 (Start at &amp;lsquo;full speed&amp;rsquo;, straight away):&lt;/strong&gt; 应用启动后几乎立刻就能达到其稳定性能状态（尽管这个稳定状态可能不是最高峰值），大大缩短了“首次响应时间”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更小的内存占用：&lt;/strong&gt; 生成的本地可执行文件不包含 JVM 和 JIT 编译器，运行时内存占用通常显著低于标准 JVM。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aot-的挑战与局限&#34;&gt;
    &lt;a href=&#34;#aot-%e7%9a%84%e6%8c%91%e6%88%98%e4%b8%8e%e5%b1%80%e9%99%90&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    AOT 的挑战与局限
&lt;/h3&gt;&lt;p&gt;然而，AOT 并非完美无缺，它也面临一些固有的挑战：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态编译的本质 (AOT is, by definition, static)&lt;/strong&gt;
&lt;strong&gt;AOT&lt;/strong&gt; 的本质是代码在运行&lt;strong&gt;之前&lt;/strong&gt;就被编译。这意味着编译器&lt;strong&gt;无法获知代码在运行时的实际行为&lt;/strong&gt; 。&lt;strong&gt;AOT&lt;/strong&gt; 不能像 &lt;strong&gt;JIT&lt;/strong&gt; 那样根据运行时的真实负载和代码路径进行深度优化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Profile Guided Optimization (PGO) 的引入与局限&lt;/strong&gt;
为了缓解静态编译缺乏运行时信息的缺点，&lt;strong&gt;AOT&lt;/strong&gt; 可以结合 &lt;strong&gt;Profile Guided Optimization (PGO)&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;PGO&lt;/strong&gt; 的基本思路是：先通过插桩（Instrumentation）或者采样的方式运行一次程序，收集代码执行频率、分支跳转等信息，生成 Profile 数据（例如 GCC 中使用 &lt;code&gt;-fprofile-generate&lt;/code&gt; 编译运行以生成 profile 文件）；然后，在最终编译时将这些 Profile 数据提供给编译器（例如 GCC 使用 &lt;code&gt;-fprofile-use&lt;/code&gt;），让编译器根据这些“先验知识”进行更针对性的优化，比如更好地安排代码布局、更准确地进行分支预测、更有效地进行函数内联等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而，对于 AOT 编译来说，PGO 只能部分缓解问题 (can partially help)&lt;/strong&gt;。因为收集到的 Profile 数据可能只代表了某一次或某几次运行的特征，无法完全覆盖所有可能的运行时场景和输入数据。因此，基于 &lt;strong&gt;PGO&lt;/strong&gt; 的 &lt;strong&gt;AOT&lt;/strong&gt; 优化效果通常仍&lt;strong&gt;难以媲美 JIT&lt;/strong&gt; 的动态优化能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504241551875.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM PERFORMANCE GRAPH&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;兼容性问题&lt;/strong&gt;
&lt;strong&gt;AOT&lt;/strong&gt; 对 Java 的动态特性（如反射、动态代理、运行时字节码生成）支持有限，通常需要额外的配置或代码调整，并非所有 Java 库都能直接兼容。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;jit-的优势运行时动态优化的威力&#34;&gt;
    &lt;a href=&#34;#jit-%e7%9a%84%e4%bc%98%e5%8a%bf%e8%bf%90%e8%a1%8c%e6%97%b6%e5%8a%a8%e6%80%81%e4%bc%98%e5%8c%96%e7%9a%84%e5%a8%81%e5%8a%9b&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    JIT 的优势：运行时动态优化的威力
&lt;/h3&gt;&lt;p&gt;与 &lt;strong&gt;AOT&lt;/strong&gt; 的静态编译不同，&lt;strong&gt;JIT&lt;/strong&gt; 编译是在程序运行期间进行的。这赋予了 &lt;strong&gt;JIT&lt;/strong&gt; 编译器独特的优势，使其能够进行比 &lt;strong&gt;AOT&lt;/strong&gt; 更深层次、更精准的优化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基于真实运行情况的优化：&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 编译器可以观察到代码&lt;strong&gt;实际&lt;/strong&gt;的运行路径、热点方法、分支跳转频率、数据类型分布等信息。基于这些&lt;strong&gt;动态收集&lt;/strong&gt;的信息，&lt;strong&gt;JIT&lt;/strong&gt; 可以做出更明智的优化决策。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;激进的优化策略：&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 可以采用更激进的优化手段，例如：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法内联 (Method Inlining):&lt;/strong&gt; 将调用频繁的小方法直接嵌入到调用处，消除方法调用的开销。JIT 可以根据实际调用情况决定是否内联以及内联的深度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逃逸分析 (Escape Analysis):&lt;/strong&gt; 分析对象的作用域，如果一个对象只在方法内部使用，不会“逃逸”出去，JIT 可以将其分配在栈上而不是堆上，减轻 GC 压力，甚至进行锁消除。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;投机性优化 (Speculative Optimizations):&lt;/strong&gt; JIT 可以根据观察到的高概率事件进行优化（例如，假设某个类型检查总是成功），并准备好在假设失败时回退到较慢的代码路径（Deoptimization）。&lt;strong&gt;AOT&lt;/strong&gt; 通常无法承担这种风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;针对特定环境的优化：&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 编译器知道程序&lt;strong&gt;当前运行&lt;/strong&gt;的 CPU 架构（例如 Haswell, Skylake, Ice Lake 等），可以生成针对该特定 CPU 指令集优化的机器码，最大化硬件性能。&lt;strong&gt;AOT&lt;/strong&gt; 为了通用性，通常只能编译为“最小公分母”的指令集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持 Java 动态特性：&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 天然与 Java 的动态特性（如反射、运行时字节码生成）协同工作，这些特性对于 &lt;strong&gt;AOT&lt;/strong&gt; 来说往往是难点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正是由于这些基于运行时信息的动态优化能力，经过充分预热的 &lt;strong&gt;JIT&lt;/strong&gt; 代码通常能够达到比 &lt;strong&gt;AOT&lt;/strong&gt; 代码&lt;strong&gt;更高的峰值性能&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;jit-的主要缺点&#34;&gt;
    &lt;a href=&#34;#jit-%e7%9a%84%e4%b8%bb%e8%a6%81%e7%bc%ba%e7%82%b9&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    JIT 的主要缺点
&lt;/h3&gt;&lt;p&gt;尽管 &lt;strong&gt;JIT&lt;/strong&gt; 在峰值性能上有优势，但其缺点也显而易见，这正是 &lt;strong&gt;AOT&lt;/strong&gt; 试图解决的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;启动时间长 (Requires more time to start up):&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 需要经历 JVM 启动、类加载、解释执行、热点分析、代码编译等多个慢速操作后，才能达到较快的执行速度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行时编译开销 (CPU overhead to compile code at runtime):&lt;/strong&gt; &lt;strong&gt;JIT&lt;/strong&gt; 编译本身需要消耗 CPU 资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存占用大 (Larger memory footprint):&lt;/strong&gt; JVM、JIT 编译器、性能分析数据等都需要占用额外的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aot-vs-jit-对比总结&#34;&gt;
    &lt;a href=&#34;#aot-vs-jit-%e5%af%b9%e6%af%94%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    AOT vs. JIT 对比总结
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;特性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;AOT (Ahead-of-Time)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;JIT (Just-In-Time)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;编译时机&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;运行前 (静态)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;运行时 (动态)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;启动速度&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;快 (Time to first response 短)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;慢 (需要 JVM 初始化、类加载、解释执行)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;预热时间&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;短 (几乎无预热)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;长 (需要识别热点、分层编译优化)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;峰值性能&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;通常较低 (缺乏运行时信息和动态优化)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;通常较高 (可进行激进优化、针对性优化)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;内存占用&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;小&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;大 (包含 JVM、JIT 编译器、分析数据等)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;动态特性支持&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有限 (需配置或改造)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;良好 (Java 核心优势之一)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;运行时开销&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;低 (无编译开销)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有 (编译 CPU 开销)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;兼容性&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;挑战较大&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;好&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;优化依据&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;静态分析 (+ 有限的 PGO)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;运行时真实行为&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;crac-的切入点&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e5%88%87%e5%85%a5%e7%82%b9&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的切入点
&lt;/h3&gt;&lt;p&gt;理解了 &lt;strong&gt;AOT&lt;/strong&gt; 和 &lt;strong&gt;JIT&lt;/strong&gt; 各自的优劣后，&lt;strong&gt;CRaC&lt;/strong&gt; 的价值就更加清晰了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CRaC&lt;/strong&gt; 试图结合两者的优点，规避其缺点：它保留了 &lt;strong&gt;JIT&lt;/strong&gt; 带来的峰值性能优势（因为 &lt;strong&gt;Checkpoint&lt;/strong&gt; 是在 &lt;strong&gt;JIT&lt;/strong&gt; 充分预热后创建的），同时通过状态恢复的方式，避免了 &lt;strong&gt;JIT&lt;/strong&gt; 漫长的启动和预热过程，实现了类似 &lt;strong&gt;AOT&lt;/strong&gt; 的快速启动（特别是达到峰值性能的速度）。与 &lt;strong&gt;AOT&lt;/strong&gt; 相比，&lt;strong&gt;CRaC&lt;/strong&gt; 对 Java 动态特性的兼容性更好。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;CRaC&lt;/strong&gt;、&lt;strong&gt;AOT&lt;/strong&gt; 和传统的 &lt;strong&gt;JIT&lt;/strong&gt; 代表了 Java 性能优化的不同策略，适用于不同的场景和需求。&lt;/p&gt;
&lt;h2 id=&#34;三实现原理深入-crac-的心脏&#34;&gt;
    &lt;a href=&#34;#%e4%b8%89%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e6%b7%b1%e5%85%a5-crac-%e7%9a%84%e5%bf%83%e8%84%8f&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    三、实现原理：深入 CRaC 的心脏
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;CRaC&lt;/strong&gt; 技术并非空中楼阁，它的实现依赖于一个强大的 Linux 工具：&lt;a class=&#34;link&#34; href=&#34;https://criu.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CRIU&lt;/a&gt;。虽然 CRIU 是一个运行在用户空间的程序，但它的核心能力建立在 Linux 内核提供的丰富特性和接口之上。理解 &lt;strong&gt;CRIU&lt;/strong&gt; 的工作原理对于深入掌握 &lt;strong&gt;CRaC&lt;/strong&gt; 至关重要。&lt;/p&gt;
&lt;h3 id=&#34;基石criu&#34;&gt;
    &lt;a href=&#34;#%e5%9f%ba%e7%9f%b3criu&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    基石：CRIU
&lt;/h3&gt;&lt;p&gt;CRIU  (Checkpoint/Restore In Userspace) 是一个 Linux 用户空间的工具，它允许你“冻结”（&lt;strong&gt;Checkpoint&lt;/strong&gt;）一个正在运行的应用程序（或一组应用程序），将其状态保存到磁盘文件中，然后在未来的某个时刻从这些文件中“解冻”（&lt;strong&gt;Restore&lt;/strong&gt;）它。被恢复的应用程序将从被冻结的那个精确时刻继续运行，仿佛什么都没有发生过一样。&lt;strong&gt;CRIU&lt;/strong&gt; 的核心能力是保存和恢复进程的各种资源状态。&lt;/p&gt;
&lt;h4 id=&#34;checkpoint-过程详解&#34;&gt;
    &lt;a href=&#34;#checkpoint-%e8%bf%87%e7%a8%8b%e8%af%a6%e8%a7%a3&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Checkpoint 过程详解
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504251743057.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Checkpoint&#34;
	
	
&gt;
&lt;strong&gt;Checkpoint&lt;/strong&gt; 阶段会执行以下步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;收集进程树并冻结&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CRIU 首先需要确定要 &lt;strong&gt;Checkpoint&lt;/strong&gt; 的目标进程及其所有子进程和线程，构成一个完整的进程树。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc&lt;/code&gt; 是一个虚拟文件系统，它并不存在于磁盘上，而是由 Linux 内核动态生成，用来提供有关系统状态和正在运行的进程的信息。对于每个正在运行的进程，&lt;code&gt;/proc&lt;/code&gt; 下都有一个以该进程的 PID（Process ID）命名的目录。&lt;/p&gt;
&lt;p&gt;在一个进程内部，可能有一个或多个线程。在 Linux 内核看来，线程本质上也是一种“任务”（Task），它们共享同一个地址空间和其他资源，但有自己独立的执行流和调度标识符（TID, Thread ID）。&lt;code&gt;/proc/$pid/task/&lt;/code&gt; 这个目录就包含了该进程（PID 为 &lt;code&gt;$pid&lt;/code&gt;）下的所有线程（任务）的信息。该目录下会为每个线程创建一个子目录，目录名就是该线程的 TID。&lt;/p&gt;
&lt;p&gt;通过读取 &lt;code&gt;/proc/$pid/task/&lt;/code&gt; 目录的内容，CRIU 可以识别出属于进程 &lt;code&gt;$pid&lt;/code&gt; 的所有线程（包括主线程和其他子线程），获取它们的 TID 列表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc/$pid/task/$tid/children&lt;/code&gt; 文件位于特定线程的目录下，记录了由 &lt;em&gt;这个特定线程&lt;/em&gt;（PID 为 &lt;code&gt;$pid&lt;/code&gt;，TID 为 &lt;code&gt;$tid&lt;/code&gt;）&lt;strong&gt;直接创建&lt;/strong&gt; 的所有子进程的 PID 列表。子进程是由 &lt;code&gt;fork()&lt;/code&gt; 或 &lt;code&gt;clone()&lt;/code&gt; 系统调用创建的。这个 &lt;code&gt;children&lt;/code&gt; 文件告诉我们，从这个线程出发，诞生了哪些新的进程。&lt;/p&gt;
&lt;p&gt;CRIU 从 &lt;code&gt;--tree&lt;/code&gt; 选项指定的那个初始 PID 开始，首先通过 &lt;code&gt;/proc/$pid/task/&lt;/code&gt; 找到一个进程的所有线程，然后通过 &lt;code&gt;/proc/$pid/task/$tid/children&lt;/code&gt; 找到每个线程创建的子进程，再对这些子进程重复同样的操作，一层层深入下去，最终像剥洋葱一样把整个进程家族（包括所有进程和线程）都识别出来。&lt;/p&gt;
&lt;p&gt;在遍历过程中，CRIU 使用 &lt;code&gt;ptrace&lt;/code&gt; 系统调用，命令为 &lt;code&gt;PTRACE_SEIZE&lt;/code&gt;，来附加（attach）到目标进程树中的每个任务（进程/线程）上，并将它们&lt;strong&gt;暂停&lt;/strong&gt;下来。&lt;/p&gt;
&lt;p&gt;传统的 &lt;code&gt;PTRACE_ATTACH&lt;/code&gt; 依赖信号机制，&lt;code&gt;PTRACE_ATTACH&lt;/code&gt; 会向目标进程发送 &lt;code&gt;SIGSTOP&lt;/code&gt;，&lt;code&gt;SIGSTOP&lt;/code&gt; 信号需要被目标进程的信号处理程序处理，然后进程才停止。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PTRACE_SEIZE&lt;/code&gt; 则不同，它&lt;strong&gt;不依赖用户空间的信号传递来让目标进程停止&lt;/strong&gt;，是内核层面的一个直接操作。当调用 &lt;code&gt;ptrace(PTRACE_SEIZE, tid, ...)&lt;/code&gt; 时，内核会标记目标任务（线程 tid）进入 &lt;code&gt;ptrace-stop&lt;/code&gt; 状态，这个任务会在&lt;strong&gt;下一次内核有机会介入任务执行流的时候&lt;/strong&gt;暂停。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;收集任务资源并转储&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进程树被冻结后，CRIU 开始收集每个任务的详细信息，并将这些信息写入镜像文件（dump files）。这些信息主要来源于 &lt;code&gt;/proc&lt;/code&gt; 文件系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存映射 (Memory maps)&lt;/strong&gt;
CRIU 通过解析 &lt;code&gt;/proc/$pid/maps&lt;/code&gt; 和 &lt;code&gt;/proc/$pid/smaps&lt;/code&gt; 获取虚拟内存区域（&lt;strong&gt;VMA&lt;/strong&gt;）的布局信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;/proc/$pid/maps&lt;/code&gt; 列出了当前进程 ($pid) &lt;strong&gt;所有内存映射区域（Virtual Memory Areas - VMA）&lt;/strong&gt; 的详细信息，每一行代表一个连续的虚拟内存区域，通常包含以下字段，用空格分隔：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;起始地址-结束地址   权限    偏移量   设备号&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;主:次&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;  inode  路径名
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果是&lt;strong&gt;文件映射&lt;/strong&gt;，&lt;strong&gt;设备号&lt;/strong&gt;表示文件所在的设备，&lt;strong&gt;inode&lt;/strong&gt; 表示文件的 &lt;code&gt;inode&lt;/code&gt; 编号，&lt;strong&gt;路径名&lt;/strong&gt;会显示被映射文件的&lt;strong&gt;路径&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;匿名映射&lt;/strong&gt;，即没有关联具体文件，如 malloc 分配的内存、进程的堆、栈等，&lt;strong&gt;inode&lt;/strong&gt; 值为 0，&lt;strong&gt;路径名&lt;/strong&gt;通常为空，或者显示一些特殊标记，如 &lt;code&gt;[heap]&lt;/code&gt; 表示进程的堆内存区域，&lt;code&gt;[stack]&lt;/code&gt;表示进程的主线程栈区域。&lt;/p&gt;
&lt;p&gt;例如查看应用服务器进程的 &lt;code&gt;maps&lt;/code&gt; 文件内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$cat&lt;/span&gt; /proc/10854/maps
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5b565de16000-5b565de17000 rw-p &lt;span class=&#34;m&#34;&gt;00003000&lt;/span&gt; 103:02 &lt;span class=&#34;m&#34;&gt;34101432&lt;/span&gt;                  /home/mazhen/works/jdk-21.0.6/jdk/bin/java
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5b5683910000-5b5683958000 rw-p &lt;span class=&#34;m&#34;&gt;00000000&lt;/span&gt; 00:00 &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;                          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;heap&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7f95a4000000-7f95a4028000 r--p &lt;span class=&#34;m&#34;&gt;00000000&lt;/span&gt; 103:02 58869401                  /usr/lib/x86_64-linux-gnu/libc.so.6
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7fff8da95000-7fff8dab7000 rw-p &lt;span class=&#34;m&#34;&gt;00000000&lt;/span&gt; 00:00 0                          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;stack&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;/proc/$pid/maps&lt;/code&gt; 是 CRIU 理解进程&lt;strong&gt;内存布局&lt;/strong&gt;的核心依据，而 &lt;code&gt;/proc/$pid/smaps&lt;/code&gt; 是 &lt;code&gt;/proc/$pid/maps&lt;/code&gt; 的一个&lt;strong&gt;扩展版本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc/$pid/smaps&lt;/code&gt;为每一个内存映射区域（&lt;strong&gt;VMA&lt;/strong&gt;）提供了更详细的内存占用统计信息（物理内存占用、共享/私有、干净/脏、匿名、交换、锁定等），以及重要的内核内部标志 (VmFlags)。&lt;code&gt;smaps&lt;/code&gt; 由多个&lt;strong&gt;块 (block)&lt;/strong&gt; 组成，每个块对应 &lt;code&gt;/proc/$pid/maps&lt;/code&gt; 文件中的一行（即一个 &lt;strong&gt;VMA&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;还是以应用服务器进程为例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$cat&lt;/span&gt; /proc/10854/smaps
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5b5683910000-5b5683958000 rw-p &lt;span class=&#34;m&#34;&gt;00000000&lt;/span&gt; 00:00 &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;                          &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;heap&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Size:                &lt;span class=&#34;m&#34;&gt;288&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;KernelPageSize:        &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;MMUPageSize:           &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Rss:                  &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Pss:                  &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Pss_Dirty:            &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Shared_Clean:          &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Shared_Dirty:          &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Private_Clean:         &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Private_Dirty:        &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Referenced:           &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Anonymous:            &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;KSM:                   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;LazyFree:              &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;AnonHugePages:         &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ShmemPmdMapped:        &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;FilePmdMapped:         &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Shared_Hugetlb:        &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Private_Hugetlb:       &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Swap:                  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SwapPss:               &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Locked:                &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;THPeligible:           &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ProtectionKey:         &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;VmFlags: rd wr mr mw me ac sd 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存映射文件（mapped files）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;/proc/$pid/map_files/&lt;/code&gt; 是一个&lt;strong&gt;目录&lt;/strong&gt;，这个目录包含了&lt;strong&gt;指向实际被映射文件的符号链接 (symbolic links)&lt;/strong&gt;。目录中的每个符号链接的&lt;strong&gt;名称&lt;/strong&gt;对应于 &lt;code&gt;/proc/$pid/maps&lt;/code&gt; 文件中列出的一个&lt;strong&gt;内存区域的地址范围&lt;/strong&gt; (格式为 起始地址 - 结束地址)。&lt;/p&gt;
&lt;p&gt;CRIU 通过 &lt;code&gt;/proc/$pid/map_files/&lt;/code&gt; 获取文件映射区域&lt;strong&gt;底层文件对象的直接链接&lt;/strong&gt;，主要用于&lt;strong&gt;可靠地访问和读取&lt;/strong&gt;这些文件映射区域的内容。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ls -l /proc/10854/map_files   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;total &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lr-------- &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 06:58 5b565de12000-5b565de13000 -&amp;gt; /home/mazhen/works/jdk-21.0.6/jdk/bin/java
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lr-------- &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 06:58 7f95a4000000-7f95a4028000 -&amp;gt; /usr/lib/x86_64-linux-gnu/libc.so.6
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件描述符 (File descriptors)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CRIU 通过读取 &lt;code&gt;/proc/$pid/fd&lt;/code&gt; 和 &lt;code&gt;/proc/$pid/fdinfo&lt;/code&gt; 获取进程打开的文件、管道、套接字等信息。CRIU 能够处理各种类型的文件描述符，包括常规文件、管道、Unix 套接字、TCP 套接字（甚至包括处于 ESTABLISHED 状态的连接）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc/$pid/fd&lt;/code&gt;是一个&lt;strong&gt;目录&lt;/strong&gt;，它包含&lt;strong&gt;符号链接&lt;/strong&gt;，每个符号链接的名称对应一个已打开的&lt;strong&gt;文件描述符编号&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ls -l /proc/10854/fd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;l-wx------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 02:00 &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; -&amp;gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;pipe:[195498]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lr-x------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 02:00 &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; -&amp;gt; /home/mazhen/works/jdk-21.0.6/jdk/lib/modules
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:21 &lt;span class=&#34;m&#34;&gt;379&lt;/span&gt; -&amp;gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;socket:[2629]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:21 &lt;span class=&#34;m&#34;&gt;380&lt;/span&gt; -&amp;gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;socket:[2636]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:21 &lt;span class=&#34;m&#34;&gt;477&lt;/span&gt; -&amp;gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;anon_inode:[eventpoll]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:21 &lt;span class=&#34;m&#34;&gt;478&lt;/span&gt; -&amp;gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;anon_inode:[eventfd]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lr-x------ &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:21 &lt;span class=&#34;m&#34;&gt;479&lt;/span&gt; -&amp;gt; anon_inode:inotify
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;/proc/$pid/fdinfo&lt;/code&gt;也是一个&lt;strong&gt;目录&lt;/strong&gt;，它包含&lt;strong&gt;普通文件&lt;/strong&gt;（不是符号链接），每个文件的名称对应一个已打开的&lt;strong&gt;文件描述符编号&lt;/strong&gt;。每个文件（例如&lt;code&gt;/proc/$pid/fdinfo/1&lt;/code&gt;）包含关于相应文件描述符的&lt;strong&gt;元数据和状态信息&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ls -l /proc/10854/fdinfo 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;total &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-r--r--r-- &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:31 &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-r--r--r-- &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:31 &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-r--r--r-- &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; mazhen mazhen &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;25&lt;/span&gt; 07:31 &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat /proc/10854/fdinfo/20
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pos:	&lt;span class=&#34;m&#34;&gt;381&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;flags:	&lt;span class=&#34;m&#34;&gt;0100000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mnt_id:	&lt;span class=&#34;m&#34;&gt;31&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ino:	&lt;span class=&#34;m&#34;&gt;32775204&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;/proc/$pid/fd&lt;/code&gt;告诉 CRIU 通过哪些描述符编号打开了&lt;strong&gt;哪些&lt;/strong&gt;资源，&lt;code&gt;/proc/$pid/fdinfo&lt;/code&gt;告诉 CRIU 每个已打开描述符的&lt;strong&gt;状态和元数据&lt;/strong&gt;（比如位置和标志）。CRIU 使用来自这两个位置的信息来完整保存进程已打开文件及其状态的情况，以便之后能够准确地恢复它们。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心运行参数 (Core parameters)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了保存一个任务（进程/线程）的核心运行状态以便后续恢复，CRIU 主要结合使用了两种方法。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ptrace&lt;/code&gt; 系统调用的特定命令（例如&lt;code&gt;PTRACE_GETREGS&lt;/code&gt; 或 &lt;code&gt;PTRACE_GETFPREGS&lt;/code&gt; ）来&lt;strong&gt;直接读取&lt;/strong&gt;任务暂停时的&lt;strong&gt;CPU 寄存器 (registers)&lt;/strong&gt; 内容，包括通用寄存器、指令指针、标志寄存器、浮点寄存器等），以及其他密切相关的底层执行状态信息。&lt;/p&gt;
&lt;p&gt;通过读取和解析 &lt;code&gt;/proc/$pid/stat&lt;/code&gt; 文件，获取关于任务的&lt;strong&gt;各种状态参数和统计数据&lt;/strong&gt;。&lt;code&gt;/proc/$pid/stat&lt;/code&gt; 以&lt;strong&gt;单行文本&lt;/strong&gt;的形式提供了关于进程的大量&lt;strong&gt;状态信息 (status information)&lt;/strong&gt;，其中的信息由&lt;strong&gt;空格&lt;/strong&gt;分隔，每个字段代表一个特定的进程属性或统计值。下面列出一些最核心和常用的字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可执行文件名 (comm)&lt;/li&gt;
&lt;li&gt;进程状态 (state)&lt;/li&gt;
&lt;li&gt;父进程 ID (ppid)&lt;/li&gt;
&lt;li&gt;进程组 ID (pgrp)&lt;/li&gt;
&lt;li&gt;会话 ID (session)&lt;/li&gt;
&lt;li&gt;调度优先级和 nice 值 (priority, nice)&lt;/li&gt;
&lt;li&gt;虚拟内存大小 (vsize)&lt;/li&gt;
&lt;li&gt;常驻集大小 (rss)&lt;/li&gt;
&lt;li&gt;进程启动时间 (starttime)&lt;/li&gt;
&lt;li&gt;等待子进程的 CPU 时间 (cutime, cstime)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;注入寄生代码（Parasite Code）并转储内存&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了获取某些无法从外部直接探测的信息（例如进程凭证、精确的内存布局和内容），CRIU 必须在目标进程的地址空间内部执行特定的代码。这正是通过 &lt;strong&gt;寄生代码 (Parasite Code)&lt;/strong&gt; 技术实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寄生代码&lt;/strong&gt;是一段精心构造的小型二进制程序，它以&lt;strong&gt;位置无关可执行文件 (PIE, Position-Independent Executable)&lt;/strong&gt; 格式编译。这一特性至关重要，因为它允许 CRIU 将这段代码加载到目标进程地址空间中的&lt;strong&gt;任何可用位置&lt;/strong&gt;，而无需担心因硬编码地址引发的冲突。该代码通常包含两部分：一小段依赖于具体处理器架构（如 x86, ARM）的汇编&lt;strong&gt;引导程序 (bootstrap)&lt;/strong&gt;，以及一段用 C 语言编写、负责处理命令的通用&lt;strong&gt;核心逻辑 (daemon)&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504251748420.png&#34; alt=&#34;Parasite Code&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;p&gt;要在目标进程中运行，&lt;strong&gt;寄生代码&lt;/strong&gt;需要自己的内存空间来存放其代码、运行栈以及用于和 CRIU 进行通信的参数区域。由于 CRIU 不能直接操作目标进程的内存分配，它巧妙地利用了 &lt;code&gt;ptrace&lt;/code&gt; 机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;准备内存空间&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CRIU 首先使用 &lt;code&gt;ptrace&lt;/code&gt; 控制目标进程，并&lt;strong&gt;保存其当前的寄存器状态&lt;/strong&gt;（尤其是指令指针 CS:IP 和栈指针）。&lt;/li&gt;
&lt;li&gt;接着，CRIU 修改目标进程的寄存器，填入执行 &lt;code&gt;mmap&lt;/code&gt; 系统调用所需的编号和参数。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;ptrace(PTRACE_SYSCALL,...)&lt;/code&gt;，&lt;strong&gt;强制目标进程执行这个 mmap 调用&lt;/strong&gt;。这会在目标进程的地址空间中分配一块&lt;strong&gt;共享内存区域&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注入并执行寄生代码&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CRIU 使用 &lt;code&gt;ptrace(PTRACE_POKEDATA, ...)&lt;/code&gt; ，将预先编译好的完整&lt;strong&gt;寄生代码&lt;/strong&gt;二进制数据写入到刚刚分配的共享内存区域中。&lt;/li&gt;
&lt;li&gt;CRIU 再次使用 &lt;code&gt;ptrace&lt;/code&gt; 修改目标进程的寄存器，将&lt;strong&gt;指令指针 (IP/PC)&lt;/strong&gt; 指向共享内存中&lt;strong&gt;寄生代码&lt;/strong&gt;的入口点。&lt;/li&gt;
&lt;li&gt;CRIU 命令目标进程恢复执行 &lt;code&gt;ptrace(PTRACE_CONT, ...)&lt;/code&gt;。此时，目标进程便开始执行被注入的&lt;strong&gt;寄生代码&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;寄生代码&lt;/strong&gt;运行在目标进程的上下文中，因此拥有访问该进程所有资源的权限。它可以执行 CRIU 指派的各种任务，例如读取和转储私有内存页、收集文件描述符的详细状态等。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;清理 (Cleanup)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当所有需要通过寄生代码完成的任务结束后，必须将其彻底移除，并将目标进程恢复到之前的状态，仿佛从未被打扰过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;寄生代码退出&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CRIU 通过共享内存或专用通信通道向寄生代码发送一个结束命令 (&lt;code&gt;PARASITE_CMD_FINI&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄生代码&lt;/strong&gt;收到命令后，执行必要的清理操作，然后调用 &lt;code&gt;rt_sigreturn()&lt;/code&gt; 系统调用。此系统调用会利用 CRIU 事先准备好的信息，&lt;strong&gt;恢复目标进程在寄生代码注入前一刻的寄存器状态&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRIU 清理环境&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CRIU 通过 &lt;code&gt;ptrace&lt;/code&gt; 监视系统调用，并拦截 &lt;code&gt;rt_sigreturn()&lt;/code&gt; 的退出。&lt;/li&gt;
&lt;li&gt;在目标进程寄存器已恢复、但寄生代码的内存区域还在的短暂时刻，CRIU 再次利用 &lt;code&gt;ptrace&lt;/code&gt; &lt;strong&gt;强制目标进程执行 munmap 系统调用&lt;/strong&gt;，将之前为寄生代码分配的共享内存区域解除映射，彻底抹除其痕迹。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复正常运行&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;最后，CRIU 调用 &lt;code&gt;ptrace(PTRACE_DETACH, ...)&lt;/code&gt; 从目标进程分离。&lt;/li&gt;
&lt;li&gt;目标进程从其原始被中断的指令处（由恢复的寄存器状态决定）继续执行，整个进程树恢复运行，&lt;strong&gt;Checkpoint&lt;/strong&gt; 操作完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;restore-过程详解&#34;&gt;
    &lt;a href=&#34;#restore-%e8%bf%87%e7%a8%8b%e8%af%a6%e8%a7%a3&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Restore 过程详解
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504270949861.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Restore&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restore (恢复)&lt;/strong&gt; 过程可以看作是 &lt;strong&gt;Checkpoint&lt;/strong&gt; (检查点) 的逆向操作。在这个过程中，执行恢复命令的 CRIU 进程会经历一系列精心设计的步骤，最终“变形”成为检查点时刻被冻结的目标进程（或进程树），并从那一刻继续运行。整个过程大致分为以下四个主要阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;解析共享资源&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CRIU 首先读取检查点生成的镜像文件，分析进程间的依赖关系。它会找出哪些资源实例（例如：同一个会话 ID、同一个打开的文件描述符指向的内核文件对象、同一块共享内存区域等）是被多个进程共同使用的。&lt;/p&gt;
&lt;p&gt;识别出这些共享资源后，CRIU 会标记它们，并确定恢复策略。某些资源会通过&lt;strong&gt;继承&lt;/strong&gt;（如会话 ID，在 fork() 时由子进程自然获得），其他的则需要更复杂的机制，比如利用 &lt;strong&gt;Unix domain socket&lt;/strong&gt; 和 &lt;strong&gt;SCM_RIGHTS 消息&lt;/strong&gt; 在进程间传递文件描述符，或者使用 &lt;strong&gt;memfd&lt;/strong&gt; 等技术来重建共享内存区域。这一步是为了确保在后续阶段，这些共享资源能被正确地创建一次，并被所有相关的进程共享，而不是各自创建独立的实例。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;创建进程树&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CRIU 严格按照镜像文件中记录的父子关系，通过多次调用 &lt;code&gt;fork()&lt;/code&gt; 系统调用来重新创建原始的进程树。每个 &lt;code&gt;fork()&lt;/code&gt; 都会产生一个新的进程，其父进程是之前已恢复的对应父进程。&lt;/p&gt;
&lt;p&gt;注意，在这个阶段，&lt;strong&gt;只创建进程的主线程&lt;/strong&gt;。目标进程的所有其他线程的恢复会被&lt;strong&gt;推迟到最后一个阶段&lt;/strong&gt;，主要是为了简化后续内存布局调整时的同步问题。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;恢复基本任务资源&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这个阶段，CRIU 为进程树中的每个进程恢复除了少数几类特殊资源之外的大部分状态。此时恢复的资源包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件描述符：&lt;/strong&gt; 打开检查点时记录的文件（使用保存的路径、访问模式、标志位），并根据需要设置到&lt;strong&gt;确切的文件偏移量&lt;/strong&gt;。对于管道、套接字等也会进行创建。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命名空间 (Namespaces):&lt;/strong&gt; 如果进程使用了非默认的命名空间（如 PID、Mount、Network、IPC、User、UTS），CRIU 会创建或加入相应的命名空间，隔离进程环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;私有内存映射：&lt;/strong&gt; 映射进程的&lt;strong&gt;私有&lt;/strong&gt;内存区域（如代码段、数据段、堆、匿名映射等），并从镜像文件中读取检查点时保存的数据，&lt;strong&gt;填充&lt;/strong&gt;到这些内存区域中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;套接字 (Sockets):&lt;/strong&gt; 创建套接字，并恢复其状态（如 TCP 连接的状态，如果检查点时保存了相关信息并配置了 TCP 修复）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作目录与根目录：&lt;/strong&gt; 调用 chdir() 和 chroot() 恢复进程检查点时刻的当前工作目录和根目录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他：&lt;/strong&gt; 还可能包括恢复信号处理器、进程的 umask 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有四类关键资源在此阶段&lt;strong&gt;不会&lt;/strong&gt;被完全恢复，它们的恢复被特意推迟到了最后阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存映射的&lt;strong&gt;确切虚拟地址&lt;/strong&gt;（此阶段可能映射在临时地址）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定时器 (Timers)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;凭证 (Credentials)&lt;/strong&gt; (如 UID, GID, Capabilities)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 (Threads)&lt;/strong&gt; (除了主线程)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几类资源之所以延迟恢复，主要是因为它们要么依赖于最终的内存布局，要么涉及特权操作，要么在最终执行前恢复可能导致状态不一致或复杂化处理。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;切换到 Restorer Context，恢复剩余资源并继续执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是最关键的一步。因为执行恢复操作的 CRIU 代码本身就位于需要被替换掉的内存区域中。直接执行 &lt;code&gt;munmap()&lt;/code&gt; 卸载旧内存或 &lt;code&gt;mmap()&lt;/code&gt; 映射新内存到当前地址，都会导致 CRIU 自身崩溃。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，CRIU 引入了一个 &lt;strong&gt;Restorer Context (恢复器上下文)&lt;/strong&gt;，这是一小段&lt;strong&gt;自包含的、位置无关的 (PIE)&lt;/strong&gt; 代码，不依赖外部库，并且被加载到一个临时的、既不属于 CRIU 主体也不属于目标进程最终内存布局的“&lt;strong&gt;安全地带 (safe zone)&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;CRIU 准备好恢复所需的数据（如最终内存映射信息、线程状态、凭证等），找到合适的内存“空洞”加载恢复器代码和数据，然后通过一次&lt;strong&gt;跳转&lt;/strong&gt;，将 CPU 的执行控制权转移给这段恢复器代码。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Restorer Context&lt;/strong&gt; 中，完成最后几项资源的恢复：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存映射 (Memory):&lt;/strong&gt; 使用 &lt;code&gt;mremap()&lt;/code&gt; 将之前映射在临时地址的私有匿名内存移动到最终的目标虚拟地址。使用 &lt;code&gt;mmap()&lt;/code&gt; 在正确的地址创建文件映射和共享内存映射（可能通过之前准备好的 &lt;code&gt;memfd&lt;/code&gt; 文件描述符来实现共享）。此时，完整的、精确的进程内存布局被建立起来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定时器 (Timers):&lt;/strong&gt; 恢复并启动所有的定时器。因为此时环境已稳定，可以避免定时器过早触发或计时偏差。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;凭证 (Credentials):&lt;/strong&gt; 设置进程最终的用户 ID、组 ID、能力集等。这通常在需要特权的操作（如 &lt;code&gt;fork()&lt;/code&gt; 指定 PID）完成后，但在彻底放弃特权之前进行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 (Threads):&lt;/strong&gt; 在最终的内存布局中，根据保存的状态创建并恢复目标进程的所有其他线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，&lt;strong&gt;Restorer Context&lt;/strong&gt; 完成所有设置后，它会&lt;strong&gt;精确地恢复目标进程主线程的寄存器状态&lt;/strong&gt;（包括最重要的&lt;strong&gt;指令指针 IP/PC&lt;/strong&gt;，指向检查点时刻被中断的那条指令），然后将 CPU 的控制权彻底交还给目标进程。至此，目标进程就像从未被打断过一样，从检查点时刻的状态&lt;strong&gt;无缝地继续执行&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;criu-小结&#34;&gt;
    &lt;a href=&#34;#criu-%e5%b0%8f%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRIU 小结
&lt;/h4&gt;&lt;p&gt;CRIU 通过 &lt;code&gt;ptrace&lt;/code&gt; 和精心设计的&lt;strong&gt;寄生代码&lt;/strong&gt;机制，以及对 &lt;code&gt;/proc&lt;/code&gt; 文件系统的深度利用，实现了在用户空间对运行中进程进行 &lt;strong&gt;Checkpoint&lt;/strong&gt; 和 &lt;strong&gt;Restore&lt;/strong&gt; 的强大能力，为 CRaC 技术的实现奠定了坚实的基础。&lt;/p&gt;
&lt;h3 id=&#34;crac-的设计理念&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e8%ae%be%e8%ae%a1%e7%90%86%e5%bf%b5&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的设计理念
&lt;/h3&gt;&lt;p&gt;理解了 CRIU 的强大能力后，一个自然的问题是：既然 CRIU 能够处理打开的文件描述符和网络连接，甚至可以透明地恢复它们，为什么 CRaC 却要求开发者通过 API（&lt;code&gt;jdk.crac.Resource&lt;/code&gt;）来手动管理这些外部资源，通常需要在 &lt;code&gt;beforeCheckpoint&lt;/code&gt; 中关闭它们，在 &lt;code&gt;afterRestore&lt;/code&gt; 中重新建立它们呢？&lt;/p&gt;
&lt;p&gt;对于这个问题，我查阅了 CRaC 所有相关的文档，阅读了 CRaC 原型实现的源码，都没有获得满意的答案。于是在 CRaC 的开发者邮件列表中询问，最终从核心 Committer 的&lt;a class=&#34;link&#34; href=&#34;https://mail.openjdk.org/pipermail/crac-dev/2025-April/002313.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;回复&lt;/a&gt;中得到解答。&lt;/p&gt;
&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271032455.jpg&#34; alt=&#34;CRaC 邮件列表&#34; style=&#34;zoom: 33%;&#34; /&gt;
&lt;p&gt;根据 CRaC 开发者的阐述，这并非技术上的限制，而是一个深思熟虑的&lt;strong&gt;架构选择 (architectural choice)&lt;/strong&gt;。其核心设计理念可以概括为 &lt;strong&gt;协调与适应&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CRIU 的主要动机之一是实现运行中容器的透明迁移。在容器迁移场景下，环境（文件系统、网络）通常是被精心管理的。容器运行时（如 Docker、Kubernetes CRI）可以配合 CRIU 工作，确保恢复后，外部环境（比如网络连接的对端、挂载的文件系统）仍然有效或被正确地重新建立，从而对容器内的进程做到“透明”。比如，网络连接恢复时，容器运行时会处理好 IP 地址、路由等问题。&lt;/p&gt;
&lt;p&gt;如果你追求的是 CRIU 那种“透明恢复”，理论上可以直接在 Java 进程上使用 CRIU。但这有风险，可能会破坏应用程序的内部逻辑。因为 Java 应用可能依赖外部资源的状态，如果环境变化而应用没有感知和调整，就会出问题（比如数据库连接指向了旧的、不存在的 IP，或者文件句柄指向了一个在恢复环境中已变化或不存在的文件）。&lt;/p&gt;
&lt;p&gt;CRaC 的目标不是追求完全透明的恢复。它想要的是：保留 JVM 和应用程序内部计算的&lt;strong&gt;有价值的状态&lt;/strong&gt;（比如 JIT 编译结果、缓存数据、业务逻辑状态），但要让应用程序有机会&lt;strong&gt;主动适应&lt;/strong&gt;恢复时可能已经变化的&lt;strong&gt;新环境&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CRaC（Coordinated Restore at Checkpoint）&lt;/strong&gt; 的名字强调了“协调”（&lt;strong&gt;Coordinated&lt;/strong&gt;）。它要求应用程序通过实现 &lt;code&gt;Resource&lt;/code&gt; 接口来参与 &lt;code&gt;Checkpoint&lt;/code&gt; 和 &lt;code&gt;Restore&lt;/code&gt; 过程。CRaC 希望开发者对每一个外部资源（文件、网络连接、数据库连接等）在恢复时如何处理，做出&lt;strong&gt;有意识的决定&lt;/strong&gt;：这个资源在 &lt;strong&gt;Checkpoint&lt;/strong&gt; 前应该如何处理（通常是关闭）？在 &lt;strong&gt;Restore&lt;/strong&gt; 后应该如何处理（通常是重新建立或验证）？&lt;/p&gt;
&lt;p&gt;这种强制性的协调机制被 CRaC 视为一个&lt;strong&gt;特性 (feature)&lt;/strong&gt;，而不是一个缺陷。这确保了应用程序能够优雅地适应 (gracefully adapt) 恢复后的新环境，而不是盲目地假设外部世界一成不变。通过显式地关闭和重新建立连接、验证文件句柄等操作，可以大大提高应用程序在 &lt;strong&gt;Restore&lt;/strong&gt; 后的健壮性和正确性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271102426.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;CRaC design&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;简而言之，CRaC 的设计哲学是，&lt;strong&gt;牺牲一定的透明度，换取应用在恢复后对环境变化的健壮适应能力&lt;/strong&gt;。它要求开发者更加明确地思考和管理应用的外部依赖。虽然这在初期可能带来一些额外的工作（比如处理日志文件句柄），但其目的是为了确保应用在 CRaC 恢复后能够稳定、正确地运行在一个可能已经发生变化的新环境中。&lt;/p&gt;
&lt;h3 id=&#34;openjdk-crac-实现概览&#34;&gt;
    &lt;a href=&#34;#openjdk-crac-%e5%ae%9e%e7%8e%b0%e6%a6%82%e8%a7%88&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    OpenJDK CRaC 实现概览
&lt;/h3&gt;&lt;p&gt;了解了 CRaC 的设计理念和底层依赖 CRIU 后，我们来看看 CRaC 功能在 OpenJDK 内部的大致实现流程。这个过程涉及 Java API 层、JVM 内部实现、外部引擎（默认是包装了 CRIU 的 criuengine）以及操作系统层面的交互。&lt;/p&gt;
&lt;h4 id=&#34;checkpoint-流程概览&#34;&gt;
    &lt;a href=&#34;#checkpoint-%e6%b5%81%e7%a8%8b%e6%a6%82%e8%a7%88&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Checkpoint 流程概览
&lt;/h4&gt;&lt;p&gt;Checkpoint 过程的目标是安全地停止 JVM，通知所有已注册的资源进行准备，然后调用外部引擎来创建进程镜像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271113195.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Checkpoint&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;触发 Checkpoint&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户执行 &lt;code&gt;jcmd &amp;lt;pid&amp;gt; JDK.checkpoint&lt;/code&gt;，&lt;code&gt;CheckpointDCmd::execute&lt;/code&gt; 被调用，它解析 &lt;code&gt;jdk.crac.Core&lt;/code&gt; 类，并调用其静态方法 &lt;code&gt;checkpointRestoreInternal(long jcmdStream)&lt;/code&gt;。&lt;code&gt;jcmdStream&lt;/code&gt; 是用于输出 &lt;code&gt;jcmd&lt;/code&gt; 结果的流。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Java 层准备&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;遍历所有注册到全局上下文 &lt;a class=&#34;link&#34; href=&#34;https://crac.github.io/openjdk-builds/javadoc/api/java.base/jdk/crac/Context.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Context&lt;/a&gt;的 &lt;a class=&#34;link&#34; href=&#34;https://crac.github.io/openjdk-builds/javadoc/api/java.base/jdk/crac/Resource.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Resource&lt;/a&gt; 实现，并调用它们的 &lt;code&gt;beforeCheckpoint&lt;/code&gt; 方法。&lt;code&gt;Resource&lt;/code&gt; 在此方法中执行必要的清理或准备工作（例如，关闭不需要的网络连接、刷新缓冲区等）。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;进入 JVM/Native 层&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;调用 native 方法 &lt;code&gt;checkpointRestore0(int[] fdArr, Object[] objArr, boolean dryRun, long jcmdStream)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;定义在 &lt;code&gt;CracCore.c&lt;/code&gt; 中的 JNI 实现 &lt;code&gt;Java_jdk_crac_Core_checkpointRestore0&lt;/code&gt; 调用 &lt;code&gt;JVM_Checkpoint&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JVM_Checkpoint&lt;/code&gt; 是一个 JVM 标准入口点，它调用 &lt;code&gt;crac::checkpoint&lt;/code&gt;，正式进入 CRaC 的 &lt;code&gt;checkpoint&lt;/code&gt; 阶段。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;JVM 内部 Checkpoint 准备&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;crac::checkpoint&lt;/code&gt; 是 CRaC 的主入口，首先执行一次强制 Full GC (&lt;code&gt;GCCause::_full_gc_alot&lt;/code&gt;) ，清理未使用的堆区域，以减小镜像体积。&lt;/p&gt;
&lt;p&gt;然后通过  &lt;code&gt;VMThread::execute()&lt;/code&gt; 进入 JVM 的 &lt;strong&gt;Safepoint&lt;/strong&gt;，这是所有的 Java 线程都已暂停，准备好执行接下来的 checkpoint 操作。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;checkpoint 操作执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;遍历 &lt;code&gt;/proc/self/fd&lt;/code&gt; 下的所有文件描述符，如果有应用程序打开但未声明的资源，会导致 Checkpoint 失败，操作会提前返回，最终导致 Java 层抛出 CheckpointException。&lt;/p&gt;
&lt;p&gt;如果一切顺利，调用 &lt;code&gt;report_ok_to_jcmd_if_any()&lt;/code&gt;。这会向 jcmd 客户端发送一个初步的成功响应，然后才调用外部引擎。这样做是因为外部引擎（如 CRIU）通常会杀死原始 JVM 进程，所以响应必须在此之前发送。&lt;/p&gt;
&lt;p&gt;接着在  &lt;code&gt;call_crengine&lt;/code&gt; fork 新的进程，加载外部引擎 &lt;code&gt;criuengine&lt;/code&gt;，执行 &lt;code&gt;criuengine&lt;/code&gt;的 &lt;code&gt;checkpoint&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;checkpoint&lt;/code&gt;方法中使用 &lt;strong&gt;double fork&lt;/strong&gt; 技巧，让孙子进程执行 CRIU，这样 CRIU 进程就不再是 JVM 的子进程。&lt;/p&gt;
&lt;p&gt;孙子进程执行的具体命令是 &lt;code&gt;criu dump -t &amp;lt;jvm_pid&amp;gt; -D &amp;lt;checkpoint_dir&amp;gt; --shell-job [options...]&lt;/code&gt;，冻结 JVM 进程，将其状态保存到 &lt;code&gt;&amp;lt;checkpoint_dir&amp;gt;&lt;/code&gt; 下的镜像文件中，然后 &lt;strong&gt;杀死&lt;/strong&gt; 原始的 JVM 进程。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;JVM 暂停点&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JVM 进程从 &lt;code&gt;call_crengine&lt;/code&gt; 快速返回，继续执行至 &lt;code&gt;sigwaitinfo()&lt;/code&gt; 阻塞。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;sigset_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;waitmask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;sigemptyset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;waitmask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// 初始化空信号集
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;sigaddset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;waitmask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RESTORE_SIGNAL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 添加自定义的恢复信号
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;siginfo_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;sig&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sigwaitinfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;waitmask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// &amp;lt;--- JVM 在这里阻塞，阻塞等待指定信号
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sig&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;errno&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EINTR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当 JVM 完成检查点（checkpoint）后，会进入等待循环，后续恢复进程会通过&lt;code&gt;RESTORE_SIGNAL&lt;/code&gt;信号唤醒 JVM。&lt;/p&gt;
&lt;h4 id=&#34;checkpoint-的进程交互&#34;&gt;
    &lt;a href=&#34;#checkpoint-%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%ba%a4%e4%ba%92&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Checkpoint 的进程交互
&lt;/h4&gt;&lt;p&gt;在通过外部引擎 &lt;code&gt;criuengine&lt;/code&gt;执行&lt;code&gt;criu dump&lt;/code&gt;的过程中，使用了 Linux 常见的编程技巧&lt;strong&gt;double fork&lt;/strong&gt;，主要原因是为了&lt;strong&gt;解耦&lt;/strong&gt;：通过让中间进程快速退出，使得执行 &lt;code&gt;criu dump&lt;/code&gt; 的孙子进程成为孤儿进程，被 init 进程收养，从而“逃离”了原始 JVM 的进程树。&lt;/p&gt;
&lt;p&gt;最终执行 &lt;code&gt;criu dump&lt;/code&gt; 的进程不属于原始 JVM 进程的进程树，这避免了 CRIU 在执行 Checkpoint 时尝试冻结其自身的问题，保证了 Checkpoint 操作的正确性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271546812.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;checkpoint&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图总结了 Checkpoint 过程中涉及的多个进程的创建。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;JVM fork -&amp;gt; P1 (criuengine checkpoint)&lt;/strong&gt;: JVM 创建子进程 P1 运行 &lt;code&gt;criuengine checkpoint&lt;/code&gt;，JVM 进程等待 P1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P1 fork -&amp;gt; P2&lt;/strong&gt;: P1 创建子进程 P2，P1 等待 P2。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P2 fork -&amp;gt; P3 &amp;amp; P2 exit&lt;/strong&gt;: P2 创建孙子进程 P3，然后 P2 &lt;strong&gt;立即退出&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P1 exit&lt;/strong&gt;: P1 检测到 P2 退出，于是 P1 也退出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JVM 继续&lt;/strong&gt;: JVM 检测到 P1 退出，&lt;code&gt;call_crengine&lt;/code&gt; 返回，JVM 继续执行直到 &lt;code&gt;sigwaitinfo&lt;/code&gt; 阻塞。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P3 fork -&amp;gt; criu dump&lt;/strong&gt;: P3 成为孤儿进程（被 &lt;code&gt;init/systemd&lt;/code&gt; 接管），创建 &lt;code&gt;criu&lt;/code&gt; 进程，最终执行 &lt;code&gt;criu dump&lt;/code&gt;，冻结并杀死阻塞中的 JVM。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;restore-流程概览&#34;&gt;
    &lt;a href=&#34;#restore-%e6%b5%81%e7%a8%8b%e6%a6%82%e8%a7%88&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Restore 流程概览
&lt;/h4&gt;&lt;p&gt;Restore 过程的目标是从 Checkpoint 镜像启动一个新的 JVM 实例，使其恢复到 Checkpoint 时刻的状态，然后继续执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271552897.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Restore&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;触发 Restore&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户启动 JVM，并指定 Restore 相关的参数  &lt;code&gt;-XX:CRaCRestoreFrom=&amp;lt;checkpoint_dir&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;JVM 初始化&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在创建 JVM 的过程中，检测到 &lt;strong&gt;Restore&lt;/strong&gt; 请求，调用 &lt;code&gt;crac::restore()&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;准备并切换引擎&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进入 &lt;code&gt;crac::restore()&lt;/code&gt; ，首先调用&lt;code&gt;compute_crengine()&lt;/code&gt; ，确定外部引擎的路径和参数。&lt;/p&gt;
&lt;p&gt;然后使用当前进程 ID (&lt;code&gt;os::current_process_id()&lt;/code&gt;) 创建一个唯一的 &lt;strong&gt;共享内存 (SHM)&lt;/strong&gt; 路径，打开 &lt;strong&gt;SHM&lt;/strong&gt; 文件，并将 Restore 参数写入到 &lt;strong&gt;SHM&lt;/strong&gt;（&lt;code&gt;CracRestoreParameters::write_to&lt;/code&gt;）。&lt;strong&gt;SHM&lt;/strong&gt; 用于在 &lt;code&gt;crac::restore&lt;/code&gt;（初始 JVM）和恢复后的 JVM 之间传递新的启动参数、属性和时间戳。&lt;/p&gt;
&lt;p&gt;最后调用 &lt;code&gt;os::execv(_crengine, _crengine_args)&lt;/code&gt;。 &lt;code&gt;execv&lt;/code&gt; 会用新的程序（外部引擎 &lt;code&gt;criuengine&lt;/code&gt;）&lt;strong&gt;替换&lt;/strong&gt;当前的 JVM 进程。初始启动的 JVM 到此结束。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;外部引擎执行 Restore (criuengine restore)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;外部引擎 &lt;code&gt;criuengine&lt;/code&gt; 执行 &lt;code&gt;restore&lt;/code&gt; 方法，构建 &lt;code&gt;criu restore&lt;/code&gt; 命令参数。关键参数包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-D &amp;lt;checkpoint_dir&amp;gt;&lt;/code&gt;: 指定镜像目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--action-script self&lt;/code&gt;: 指定 &lt;code&gt;criuengine&lt;/code&gt; 自身作为 CRIU 的动作脚本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--exec-cmd -- self restorewait&lt;/code&gt;: 指定 CRIU 成功恢复进程后，应该执行 &lt;code&gt;criuengine restorewait&lt;/code&gt; 命令。这个命令会等待恢复后的 JVM 进程结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行 &lt;code&gt;execv&lt;/code&gt; 运行 &lt;code&gt;criu restore&lt;/code&gt; 命令，再次替换当前进程。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;CRIU 执行恢复&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CRIU 读取镜像文件，在内存中重建 JVM 进程的状态（内存映射、线程状态、寄存器等）。&lt;/p&gt;
&lt;p&gt;在进程状态基本恢复但尚未完全运行时，CRIU 会调用 &lt;code&gt;--action-script&lt;/code&gt; 指定的脚本（即 &lt;code&gt;criuengine&lt;/code&gt;），进入 &lt;code&gt;post_resume&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;post_resume&lt;/code&gt; 方法中，获取恢复后的 JVM PID 和之前存入的 SHM ID，然后使用 &lt;code&gt;sigqueue&lt;/code&gt; 向恢复的 JVM 进程发送 &lt;code&gt;RESTORE_SIGNAL&lt;/code&gt; 信号。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;外部等待进程 (criuengine restorewait)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据参数 &lt;code&gt;--exec-cmd&lt;/code&gt; 指定的命令，再次执行 &lt;code&gt;execv&lt;/code&gt;，将执行恢复的 CRIU 进程替换为 &lt;code&gt;criuengine restorewait&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;criuengine&lt;/code&gt; 使用 &lt;code&gt;waitpid&lt;/code&gt; 等待刚刚恢复并继续运行的 JVM 进程，它会捕获发给它自己的信号，并尝试将这些信号转发给 JVM 进程。&lt;/p&gt;
&lt;p&gt;当 JVM 进程最终退出时，&lt;code&gt;waitpid&lt;/code&gt; 返回，&lt;code&gt;criuengine&lt;/code&gt; 进程也以相同的退出码或基于信号的状态退出。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;恢复的 JVM 继续执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271742570.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;jvm restore&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;恢复的 JVM 进程收到 CRIU 进程发送的 &lt;code&gt;RESTORE_SIGNAL&lt;/code&gt; 信号，从 &lt;code&gt;sigwaitinfo()&lt;/code&gt; 醒来，执行流回到 &lt;code&gt;checkpoint_restore&lt;/code&gt; 函数（在 &lt;code&gt;crac.cpp&lt;/code&gt; 中），正好在 &lt;code&gt;call_crengine()&lt;/code&gt; 之后等待信号的地方。&lt;/p&gt;
&lt;p&gt;执行一些 JVM 恢复动作，包括根据 SHM ID 从共享内存中读取新的命令行参数，进行时间校准，唤醒可能在 &lt;strong&gt;Checkpoint&lt;/strong&gt; 时处于 &lt;code&gt;sleep&lt;/code&gt; 或 &lt;code&gt;park&lt;/code&gt; 状态的线程。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;返回 Java 层&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JVM 将新参数返回给 &lt;code&gt;jdk.crac.Core&lt;/code&gt;，&lt;code&gt;Core&lt;/code&gt; 应用新属性，遍历所有注册的 &lt;code&gt;Resource&lt;/code&gt;，调用其 &lt;code&gt;afterRestore&lt;/code&gt; 方法，执行恢复后的初始化工作（例如，重新建立连接、重新加载配置等）。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;完成&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果没有异常，从 &lt;code&gt;Core.checkpointRestoreInternal&lt;/code&gt; 正常退出，Restore 成功，JVM 继续运行。&lt;/p&gt;
&lt;h4 id=&#34;restore-的进程交互&#34;&gt;
    &lt;a href=&#34;#restore-%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%ba%a4%e4%ba%92&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Restore 的进程交互
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Restore&lt;/strong&gt; 过程巧妙地利用了 &lt;code&gt;execv&lt;/code&gt; 系统调用来&lt;strong&gt;替换&lt;/strong&gt;当前进程的映像，从而将控制权逐步交给下一个阶段所需的工具，最终恢复目标 JVM 进程。需要注意的是，在这个流程中，&lt;code&gt;fork&lt;/code&gt; 并不像 &lt;strong&gt;Checkpoint&lt;/strong&gt; 流程那样显式地用于创建等待子进程的父进程，而是由 CRIU 内部管理，但 &lt;code&gt;execv&lt;/code&gt; 是贯穿始终的关键。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504271821190.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Restore&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动 Restore 命令 (用户 -&amp;gt; P1)&lt;/strong&gt;
用户执行 &lt;code&gt;java -XX:CRaCRestoreFrom=&amp;lt;checkpoint_dir&amp;gt;&lt;/code&gt; 命令，启动了一个初始的 JVM 进程，我们称之为 &lt;strong&gt;P1&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;P1&lt;/strong&gt; 执行第一次 &lt;code&gt;execv&lt;/code&gt; (&lt;strong&gt;P1&lt;/strong&gt; -&amp;gt; &lt;strong&gt;P2&lt;/strong&gt;: &lt;code&gt;criuengine restore&lt;/code&gt;)
在 &lt;code&gt;crac::restore()&lt;/code&gt;中，&lt;strong&gt;P1&lt;/strong&gt; 准备必要的参数，调用 &lt;code&gt;os::execv(_crengine, _crengine_args)&lt;/code&gt;，这里的 &lt;code&gt;_crengine&lt;/code&gt; 是 &lt;code&gt;criuengine&lt;/code&gt; 的路径，&lt;code&gt;_crengine_args&lt;/code&gt; 包含了 &amp;ldquo;restore&amp;rdquo; 和 Checkpoint 目录等参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结果 &lt;code&gt;execv&lt;/code&gt; 用 &lt;code&gt;criuengine restore&lt;/code&gt; 程序替换了 &lt;strong&gt;P1&lt;/strong&gt; 进程。原来的 Java 进程 &lt;strong&gt;P1&lt;/strong&gt; 不复存在。现在的进程我们称之为 &lt;strong&gt;P2&lt;/strong&gt;，虽然 PID 可能与 &lt;strong&gt;P1&lt;/strong&gt; 相同，但运行的程序已改变，&lt;strong&gt;P2&lt;/strong&gt; 正在执行 &lt;code&gt;criuengine restore&lt;/code&gt; 的代码。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;P2&lt;/strong&gt; 执行第二次 &lt;code&gt;execv&lt;/code&gt; (&lt;strong&gt;P2&lt;/strong&gt; -&amp;gt; &lt;strong&gt;P3&lt;/strong&gt;: &lt;code&gt;criu restore&lt;/code&gt;)
&lt;strong&gt;P2&lt;/strong&gt; 运行 &lt;code&gt;criuengine restore&lt;/code&gt; 代码，进行一些准备工作，构建 criu 命令行的参数，调用 &lt;code&gt;execv(criu, const_cast&amp;lt;char **&amp;gt;(args.data()))&lt;/code&gt; ，用 &lt;code&gt;criu restore&lt;/code&gt; 程序替换了 &lt;strong&gt;P2&lt;/strong&gt; 进程。&lt;code&gt;criuengine restore&lt;/code&gt; 进程 &lt;strong&gt;P2&lt;/strong&gt; 不复存在。现在的进程（我们称之为 &lt;strong&gt;P3&lt;/strong&gt;）正在执行 &lt;code&gt;criu restore&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;P3&lt;/strong&gt; (CRIU) 恢复 JVM 进程，执行第三次 &lt;code&gt;execv&lt;/code&gt; (&lt;strong&gt;P3&lt;/strong&gt; -&amp;gt; &lt;strong&gt;P4&lt;/strong&gt;: &lt;code&gt;criuengine restorewait&lt;/code&gt;)
&lt;strong&gt;P3&lt;/strong&gt; （运行 &lt;code&gt;criu restore&lt;/code&gt;）读取 Checkpoint 镜像文件，恢复（fork）目标 JVM 进程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在成功恢复 JVM 之后，CRIU 本身需要结束。由于指定了 &lt;code&gt;--exec-cmd -- self restorewait&lt;/code&gt;，CRIU 会执行最后一次 &lt;code&gt;execv&lt;/code&gt;，用 &lt;code&gt;criuengine restorewait&lt;/code&gt; 程序替换了 &lt;strong&gt;P3&lt;/strong&gt; 进程。&lt;code&gt;criu restore&lt;/code&gt; 进程 &lt;strong&gt;P3&lt;/strong&gt; 不复存在，现在的进程（我们称之为 &lt;strong&gt;P4&lt;/strong&gt;）正在执行 &lt;code&gt;criuengine restorewait&lt;/code&gt;。与此同时，&lt;strong&gt;JVM&lt;/strong&gt; 已经独立运行起来，并完成了 &lt;code&gt;Restore&lt;/code&gt; 的 Java 层逻辑。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;P4&lt;/strong&gt; (&lt;code&gt;criuengine restorewait&lt;/code&gt;) 等待 JVM
&lt;strong&gt;P4&lt;/strong&gt; （运行 &lt;code&gt;criuengine restorewait&lt;/code&gt; 代码）获取 JVM 的 PID，设置信号处理程序，尝试将接收到的信号转发给 JVM。最后调用 &lt;code&gt;waitpid(pid_P_JVM, &amp;amp;status, 0)&lt;/code&gt;，等待 JVM 进程终止。当 JVM 退出时，&lt;strong&gt;P4&lt;/strong&gt; 获取其退出状态，然后 &lt;strong&gt;P4&lt;/strong&gt; 也以相同的状态退出。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单来说，当 JVM 恢复时，通过 &lt;code&gt;java -XX:CRaCRestoreFrom=...&lt;/code&gt; 启动的进程并不会启动 JVM，而是通过 &lt;code&gt;criuengine&lt;/code&gt; 执行 CRIU，后者将恢复的进程作为其子进程启动。当 CRIU 完成进程重建后，它会执行 &lt;code&gt;criuengine restorewait&lt;/code&gt; ，该程序的唯一任务是等待其唯一子进程（恢复的 JVM）退出并传递其状态。这意味着现在有两个进程，恢复的 JVM 进程是 &lt;code&gt;criuengine&lt;/code&gt; 的子进程。&lt;/p&gt;
&lt;h2 id=&#34;四crac-使用指南&#34;&gt;
    &lt;a href=&#34;#%e5%9b%9bcrac-%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8d%97&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    四、CRaC 使用指南
&lt;/h2&gt;&lt;p&gt;本章将详细介绍如何在你的 Java 应用程序中使用 CRaC 技术，包括理解其协调机制、使用 API、文件描述符策略以及通过一个 Jetty 示例进行实战演练。&lt;/p&gt;
&lt;h3 id=&#34;为何需要-orgcrac-包&#34;&gt;
    &lt;a href=&#34;#%e4%b8%ba%e4%bd%95%e9%9c%80%e8%a6%81-orgcrac-%e5%8c%85&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    为何需要 org.crac 包
&lt;/h3&gt;&lt;p&gt;CRaC 的核心 API（如 &lt;code&gt;Resource&lt;/code&gt; 接口）最初存在于不同的包路径下（例如早期的 &lt;code&gt;javax.crac&lt;/code&gt; 或 JDK 内部的 &lt;code&gt;jdk.crac&lt;/code&gt;）。为了提供一个&lt;strong&gt;稳定且兼容&lt;/strong&gt;的编程接口，社区引入了 &lt;code&gt;org.crac&lt;/code&gt; 这个独立的库。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;org.crac&lt;/code&gt; 库的好处在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;平滑采用：&lt;/strong&gt; 开发者可以依赖这个库来编写 CRaC 相关的代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨运行时兼容：&lt;/strong&gt; 应用程序可以在不同的 Java 运行时上编译和运行，无论该运行时是否内置了 CRaC 支持（如标准的 OpenJDK、带有 jdk.crac 的 CRaC 构建版本，或者更早期的 javax.crac 实现）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;未来适应性：&lt;/strong&gt; 即便未来 CRaC API 的包路径发生变化，应用程序代码也无需修改，只需更新 org.crac 库版本即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;org.crac&lt;/code&gt; 库的核心功能是作为 CRaC API 的一个&lt;strong&gt;适配器&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编译时：&lt;/strong&gt; 它提供了与 &lt;code&gt;jdk.crac&lt;/code&gt;（以及历史上的 &lt;code&gt;javax.crac&lt;/code&gt;）完全镜像的 API 接口，供开发者编译时依赖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行时：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;org.crac&lt;/code&gt; 使用&lt;strong&gt;反射&lt;/strong&gt;机制来检测当前运行的 JVM 是否包含实际的 CRaC 实现（检查是否存在 &lt;code&gt;jdk.crac.Core&lt;/code&gt; 或 &lt;code&gt;javax.crac.Core&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;检测到&lt;/strong&gt; CRaC 实现，所有对 &lt;code&gt;org.crac&lt;/code&gt; API 的调用都会被&lt;strong&gt;转发&lt;/strong&gt;给底层的实际实现。&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;未检测到&lt;/strong&gt; CRaC 实现（例如在标准 OpenJDK 上运行），请求会被转发到一个&lt;strong&gt;虚拟（dummy）实现&lt;/strong&gt;。这个虚拟实现允许应用程序正常运行，&lt;code&gt;Resource&lt;/code&gt; 也可以注册，但任何尝试创建 &lt;code&gt;Checkpoint&lt;/code&gt; 的请求（如调用 &lt;code&gt;Core.checkpointRestore()&lt;/code&gt;）都会&lt;strong&gt;失败并抛出异常&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这种方式，&lt;code&gt;org.crac&lt;/code&gt; 库确保了应用程序即使在不支持 CRaC 的环境中也能运行，同时在支持 CRaC 的环境中能够无缝对接。&lt;/p&gt;
&lt;h3 id=&#34;添加-orgcrac-api-依赖&#34;&gt;
    &lt;a href=&#34;#%e6%b7%bb%e5%8a%a0-orgcrac-api-%e4%be%9d%e8%b5%96&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    添加 org.crac API 依赖
&lt;/h3&gt;&lt;p&gt;可以通过 Maven 或 Gradle 将 &lt;code&gt;org.crac&lt;/code&gt; 库添加到你的项目中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Maven&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dependency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;groupId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;org&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;groupId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;artifactId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;artifactId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dependency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Gradle&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;implementation&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;org&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;crac-的协调机制&#34;&gt;
    &lt;a href=&#34;#crac-%e7%9a%84%e5%8d%8f%e8%b0%83%e6%9c%ba%e5%88%b6&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 的协调机制
&lt;/h3&gt;&lt;p&gt;如前所述，CRaC 的核心设计理念是“协调与适应”。虽然底层的 CRIU 能够冻结和恢复进程的大部分状态，但对于&lt;strong&gt;外部资源&lt;/strong&gt;（External Resources），如打开的文件、网络连接（Socket）、数据库连接等，简单的透明恢复可能会导致问题。原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;环境变化：&lt;/strong&gt; &lt;code&gt;Restore&lt;/code&gt; 发生时，运行环境可能已经改变（例如，IP 地址、主机名、挂载的文件系统内容）。直接恢复旧的资源句柄可能指向无效或错误的目标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;状态失效：&lt;/strong&gt; 某些外部资源的状态可能具有时效性（例如，数据库连接超时、文件被其他进程修改）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源冲突：&lt;/strong&gt; 恢复的进程可能尝试使用已被新环境占用的资源（例如，端口号）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，CRaC &lt;strong&gt;不选择&lt;/strong&gt;让 CRIU 默认透明地处理这些外部资源，而是要求应用程序&lt;strong&gt;必须&lt;/strong&gt;参与到 &lt;strong&gt;Checkpoint&lt;/strong&gt; 和 &lt;strong&gt;Restore&lt;/strong&gt; 的过程中，主动管理这些资源。这就是“协调”的含义。应用程序需要明确告知 CRaC 如何安全地处理这些外部连接和状态，以确保在 &lt;strong&gt;Restore&lt;/strong&gt; 后能够正确地适应新环境。&lt;/p&gt;
&lt;p&gt;为了实现这种协调，&lt;code&gt;org.crac&lt;/code&gt; 包提供了核心的 &lt;code&gt;Resource&lt;/code&gt; 接口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;org.crac&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ... imports ...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;beforeCheckpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;afterRestore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;需要管理外部资源的类可以实现 &lt;code&gt;Resource&lt;/code&gt; 接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Checkpoint 前调用 &lt;code&gt;beforeCheckpoint(Context&amp;lt;? extends Resource&amp;gt; context)&lt;/code&gt;，用于&lt;strong&gt;释放/关闭&lt;/strong&gt;外部资源，确保状态一致。如果无法准备好，抛出异常阻止 Checkpoint。&lt;/li&gt;
&lt;li&gt;在 Restore 后调用 &lt;code&gt;afterRestore(Context&amp;lt;? extends Resource&amp;gt; context)&lt;/code&gt;，用于&lt;strong&gt;重新建立/验证&lt;/strong&gt;外部资源，恢复状态。如果恢复失败，抛出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 &lt;code&gt;org.crac.Core.getGlobalContext().register(this)&lt;/code&gt; ，将实现了 &lt;code&gt;Resource&lt;/code&gt; 的对象注册给 CRaC 运行时。注册顺序决定了 &lt;code&gt;beforeCheckpoint&lt;/code&gt; 的调用顺序，而 &lt;code&gt;afterRestore&lt;/code&gt; 则以相反顺序调用。&lt;/p&gt;
&lt;h3 id=&#34;文件描述符策略-file-descriptor-policies&#34;&gt;
    &lt;a href=&#34;#%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6%e7%ad%96%e7%95%a5-file-descriptor-policies&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    文件描述符策略 (File Descriptor Policies)
&lt;/h3&gt;&lt;p&gt;虽然 CRaC 推荐通过实现 &lt;code&gt;Resource&lt;/code&gt; 接口来主动管理外部资源，但也提供了一种基于配置的备选方案，称为&lt;strong&gt;文件描述符策略 (File Descriptor Policies)&lt;/strong&gt;。这主要用于处理那些&lt;strong&gt;难以修改&lt;/strong&gt;以添加 &lt;code&gt;Resource&lt;/code&gt; 回调的代码，例如第三方库或 JDK 内部代码（注意：此策略仅适用于通过 JDK API 打开的文件描述符，不适用于 Native 代码打开的 FD）。&lt;/p&gt;
&lt;h4 id=&#34;配置方式&#34;&gt;
    &lt;a href=&#34;#%e9%85%8d%e7%bd%ae%e6%96%b9%e5%bc%8f&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    配置方式
&lt;/h4&gt;&lt;p&gt;通过设置系统属性 &lt;code&gt;jdk.crac.resource-policies&lt;/code&gt; 指向一个策略文件来启用。该文件采用类似 YAML 的格式，包含一个或多个规则，规则之间用 &lt;code&gt;---&lt;/code&gt; 分隔。以 &lt;code&gt;#&lt;/code&gt; 开头的行是注释。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;# 规则示例 1: 关闭特定文件  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;file  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/path/to/my/file  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;close  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 规则示例 2: 忽略所有 .log 文件 (交给 CRIU 处理)  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;FILE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 类型不区分大小写  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;**\*.log&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 支持 glob 模式  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ignore  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;warn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 禁止对此规则匹配的 FD 打印警告  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 规则示例 3: 重新打开 Unix socket  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;socket  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;unix  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;localPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/var/run/app.sock  &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reopen&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 注意：socket 的 reopen 目前可能不完善&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;CRaC 在 Checkpoint 时会检查所有打开的文件描述符。对于每个 FD，它会&lt;strong&gt;按顺序&lt;/strong&gt;查找策略文件中的规则，&lt;strong&gt;第一个匹配&lt;/strong&gt;的规则将被应用，后续规则会被忽略。&lt;/p&gt;
&lt;p&gt;每个规则必须包含 &lt;code&gt;type&lt;/code&gt; 和 &lt;code&gt;action&lt;/code&gt; 两个属性（值不区分大小写）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可用类型 (type):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;file: 本地文件系统上的文件或目录。&lt;/li&gt;
&lt;li&gt;pipe: 匿名管道（命名管道使用 file 类型）。&lt;/li&gt;
&lt;li&gt;socket: 网络套接字（TCP, UDP 等）或 Unix 域套接字。&lt;/li&gt;
&lt;li&gt;filedescriptor: 无法通过以上类型识别的原始文件描述符（例如，由 Native 代码打开但通过 JDK API 暴露的）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件-file-规则&#34;&gt;
    &lt;a href=&#34;#%e6%96%87%e4%bb%b6-file-%e8%a7%84%e5%88%99&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    文件 (file) 规则
&lt;/h4&gt;&lt;p&gt;通过 &lt;code&gt;path&lt;/code&gt; 属性匹配，支持 &lt;a class=&#34;link&#34; href=&#34;https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;glob 模式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;**可用操作 (action)**支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;error&lt;/strong&gt;: (默认) 打印错误并导致 Checkpoint 失败。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ignore&lt;/strong&gt;: 忽略此 FD，将其处理完全委托给底层的 Checkpoint/Restore 引擎（如 CRIU）。CRIU 通常会尝试验证并在 Restore 时重新打开文件。&lt;strong&gt;这是将处理责任交给 CRIU 的方式。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;close&lt;/strong&gt;: 在 Checkpoint 前关闭文件。如果在 Restore 后尝试使用该 FD，会导致运行时异常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reopen&lt;/strong&gt;: 在 Checkpoint 前关闭文件，并在 Restore 后尝试在相同位置重新打开它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;管道-pipe-规则&#34;&gt;
    &lt;a href=&#34;#%e7%ae%a1%e9%81%93-pipe-%e8%a7%84%e5%88%99&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    管道 (pipe) 规则
&lt;/h4&gt;&lt;p&gt;匿名管道无法通过名称识别，因此通常最多只有一个 pipe 规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可用操作 (action)&lt;/strong&gt; 支持 &lt;strong&gt;error&lt;/strong&gt;，&lt;strong&gt;ignore&lt;/strong&gt; 和 &lt;strong&gt;close&lt;/strong&gt;，含义和文件规则相同。&lt;/p&gt;
&lt;h4 id=&#34;套接字-socket-规则&#34;&gt;
    &lt;a href=&#34;#%e5%a5%97%e6%8e%a5%e5%ad%97-socket-%e8%a7%84%e5%88%99&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    套接字 (socket) 规则
&lt;/h4&gt;&lt;p&gt;可以通过以下属性细化匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;family&lt;/strong&gt;: &lt;code&gt;ipv4/inet4&lt;/code&gt;, &lt;code&gt;ipv6/inet6&lt;/code&gt;, &lt;code&gt;ip/inet&lt;/code&gt; (任意 IP), &lt;code&gt;unix&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;localAddress&lt;/strong&gt;, &lt;strong&gt;remoteAddress&lt;/strong&gt;: IP 地址或 &lt;code&gt;*&lt;/code&gt; (任意地址)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;localPort&lt;/strong&gt;, &lt;strong&gt;remotePort&lt;/strong&gt;: 端口号或 &lt;code&gt;*&lt;/code&gt; (任意端口)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;localPath&lt;/strong&gt;, &lt;strong&gt;remotePath&lt;/strong&gt;: Unix 套接字路径，支持 glob 模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;可用操作 (action)&lt;/strong&gt;  支持 &lt;strong&gt;error&lt;/strong&gt;，&lt;strong&gt;ignore&lt;/strong&gt; 和 &lt;strong&gt;close&lt;/strong&gt;。&lt;strong&gt;reopen&lt;/strong&gt; 也可以使用，它会在 Checkpoint 前关闭套接字，但目前重新打开的逻辑（特别是对于监听套接字）可能尚未完全实现。&lt;/p&gt;
&lt;h4 id=&#34;原始文件描述符-filedescriptor-规则&#34;&gt;
    &lt;a href=&#34;#%e5%8e%9f%e5%a7%8b%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6-filedescriptor-%e8%a7%84%e5%88%99&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    原始文件描述符 (filedescriptor) 规则
&lt;/h4&gt;&lt;p&gt;用于匹配那些没有对应 Java 对象（如 &lt;code&gt;FileOutputStream&lt;/code&gt;）的文件描述符。&lt;/p&gt;
&lt;p&gt;可以通过数值 &lt;code&gt;value: 123&lt;/code&gt; ，或原生描述的正则表达式 &lt;code&gt;regex: .*something.*&lt;/code&gt; (Java 正则语法) 来匹配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可用操作 (action)&lt;/strong&gt;  支持 &lt;strong&gt;error&lt;/strong&gt;， &lt;strong&gt;ignore&lt;/strong&gt; 和 &lt;strong&gt;close&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;重要提示&#34;&gt;
    &lt;a href=&#34;#%e9%87%8d%e8%a6%81%e6%8f%90%e7%a4%ba&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    重要提示
&lt;/h4&gt;&lt;p&gt;文件描述符策略被认为是&lt;strong&gt;权宜之计&lt;/strong&gt;，用于处理无法直接修改代码的情况。&lt;strong&gt;首选且更健壮的方式仍然是实现 Resource 接口&lt;/strong&gt;，因为应用程序最了解如何正确、安全地处理其外部资源，尤其是在面对环境变化时。过度依赖 ignore 策略可能隐藏潜在的 Restore 后问题。&lt;/p&gt;
&lt;h3 id=&#34;crac-实战&#34;&gt;
    &lt;a href=&#34;#crac-%e5%ae%9e%e6%88%98&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 实战
&lt;/h3&gt;&lt;p&gt;下面我们通过一个简单的 Jetty Web 服务器示例，演示如何使用 &lt;code&gt;org.crac&lt;/code&gt; API 来支持 CRaC。完整代码可在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/org-crac/example-jetty&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;example-jetty&lt;/a&gt; 仓库找到。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;初始 Jetty 应用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设我们有一个简单的 Jetty 应用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;App&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AbstractHandler&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;serverManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;handle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(...)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;serverManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;App&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;添加 org.crac 依赖&lt;/strong&gt;&lt;br&gt;
在 &lt;code&gt;pom.xml&lt;/code&gt; (Maven) 或 &lt;code&gt;build.gradle&lt;/code&gt; (Gradle) 中添加 &lt;code&gt;org.crac&lt;/code&gt; 依赖。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dependency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;groupId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;org&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;groupId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;artifactId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;crac&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;artifactId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dependency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;尝试 Checkpoint (预期失败)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;编译并运行应用，启用 CRaC 并指定 Checkpoint 目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 编译&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ mvn clean package
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 运行  &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ java -XX:CRaCCheckpointTo&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr -Djdk.crac.collect-fd-stacktraces&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt; -jar target/example-jetty-1.0-SNAPSHOT.jar
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;应用启动后，尝试访问 &lt;code&gt;http://localhost:8080&lt;/code&gt;，应该能看到“Hello World”。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl localhost:8080
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Hello World
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后尝试触发 Checkpoint：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 查找 PID &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ jps
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;35297&lt;/span&gt; example-jetty-1.0-SNAPSHOT.jar
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;36051&lt;/span&gt; Jps
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 触发 Checkpoint&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;jcmd &lt;span class=&#34;m&#34;&gt;35297&lt;/span&gt; JDK.checkpoint
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此时，应用控制台会打印类似以下的异常并退出，因为 Jetty 打开了监听端口（一个 Socket 文件描述符），而我们没有处理它：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;An exception during a checkpoint operation:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;jdk.internal.crac.mirror.CheckpointException
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Suppressed: jdk.internal.crac.mirror.impl.CheckpointOpenSocketException: sun.nio.ch.ServerSocketChannelImpl&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;/&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0:0:0:0:0:0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;:8080&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		at java.base/jdk.internal.crac.JDKSocketResourceBase.lambda&lt;span class=&#34;nv&#34;&gt;$beforeCheckpoint$0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;JDKSocketResourceBase.java:68&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		at java.base/jdk.internal.crac.mirror.Core.checkpointRestore1&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;Core.java:170&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		at java.base/jdk.internal.crac.mirror.Core.checkpointRestore&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;Core.java:315&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		at java.base/jdk.internal.crac.mirror.Core.checkpointRestoreInternal&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;Core.java:328&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;实现 Resource 接口&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们需要让 &lt;code&gt;ServerManager&lt;/code&gt; 实现 &lt;code&gt;Resource&lt;/code&gt; 接口，在 Checkpoint 前停止 Jetty 服务器（关闭 Socket），在 Restore 后重新启动它。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;org.crac.Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;org.crac.Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;org.crac.Resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;beforeCheckpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Stop the connectors only and keep the expensive application running&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;asList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getConnectors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;forEach&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LifeCycle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;afterRestore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;asList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getConnectors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;forEach&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LifeCycle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;将 &lt;code&gt;Resource&lt;/code&gt; 注册到一个 &lt;code&gt;Context&lt;/code&gt; 中，该 &lt;code&gt;Context&lt;/code&gt; 将调用 &lt;code&gt;Resource&lt;/code&gt; 的方法作为通知。有一个全局的 &lt;code&gt;Context&lt;/code&gt; 可以作为默认选择。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Resource&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServerManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;		&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Core&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getGlobalContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;再次尝试 Checkpoint (预期成功)&lt;/strong&gt;&lt;br&gt;
重新编译并运行应用&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ mvn  clean package  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ java -XX:CRaCCheckpointTo&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr -jar target/example-jetty-1.0-SNAPSHOT.jar
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;访问 &lt;code&gt;http://localhost:8080&lt;/code&gt; 进行预热。然后再次触发 Checkpoint：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ jcmd &amp;lt;pid&amp;gt; JDK.checkpoint
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这次，你应该在应用控制台看到类似输出，表明 Jetty 被停止，然后 Checkpoint 被创建，最后原始 JVM 被杀死：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;INFO: Starting checkpoint
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2025-04-28 02:42:16.653:INFO:oejs.AbstractConnector:Attach Listener: Stopped ServerConnector@270421f5&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;HTTP/1.1, &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;http/1.1&lt;span class=&#34;o&#34;&gt;)}{&lt;/span&gt;0.0.0.0:8080&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;42035&lt;/span&gt; killed     java -XX:CRaCCheckpointTo&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr -jar target/example-jetty-1.0-SNAPSHOT.jar
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;同时，在 &lt;code&gt;cr&lt;/code&gt; 目录下会生成 Checkpoint 镜像文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ls cr                                                                                                                                                   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42035.img  core-42045.img  core-42081.img  core-42092.img  core-42426.img  core-42436.img  core-42446.img     pstree.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42036.img  core-42046.img  core-42082.img  core-42093.img  core-42427.img  core-42437.img  dump4.log          seccomp.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42037.img  core-42047.img  core-42083.img  core-42094.img  core-42428.img  core-42438.img  fdinfo-2.img       stats-dump
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42038.img  core-42048.img  core-42084.img  core-42116.img  core-42429.img  core-42439.img  files.img          timens-0.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42039.img  core-42049.img  core-42085.img  core-42119.img  core-42430.img  core-42440.img  fs-42035.img       tty-info.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42040.img  core-42050.img  core-42086.img  core-42121.img  core-42431.img  core-42441.img  ids-42035.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42041.img  core-42051.img  core-42088.img  core-42422.img  core-42432.img  core-42442.img  inventory.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42042.img  core-42052.img  core-42089.img  core-42423.img  core-42433.img  core-42443.img  mm-42035.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42043.img  core-42079.img  core-42090.img  core-42424.img  core-42434.img  core-42444.img  pagemap-42035.img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;core-42044.img  core-42080.img  core-42091.img  core-42425.img  core-42435.img  core-42445.img  pages-1.img
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;从 Checkpoint 恢复&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;-XX:CRaCRestoreFrom&lt;/code&gt; 参数启动一个新的 JVM 实例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ java -XX:CRaCRestoreFrom&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2025-04-28 02:46:57.664:INFO:oejs.AbstractConnector:Attach Listener: Started ServerConnector@270421f5&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;HTTP/1.1, &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;http/1.1&lt;span class=&#34;o&#34;&gt;)}{&lt;/span&gt;0.0.0.0:8080&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;现在，你可以再次访问 &lt;code&gt;http://localhost:8080&lt;/code&gt;，应用应该能够正常响应。&lt;/p&gt;
&lt;p&gt;查看进程的父子关系：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ps axfo pid,ppid,command
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;31809&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;31807&lt;/span&gt;  &lt;span class=&#34;se&#34;&gt;\_&lt;/span&gt; sshd: mazhen &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;priv&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;31830&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;31809&lt;/span&gt;      &lt;span class=&#34;se&#34;&gt;\_&lt;/span&gt; sshd: mazhen@pts/0,pts/1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;31831&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;31830&lt;/span&gt;          &lt;span class=&#34;se&#34;&gt;\_&lt;/span&gt; -zsh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;44224&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;31831&lt;/span&gt;          &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;   &lt;span class=&#34;se&#34;&gt;\_&lt;/span&gt; /home/mazhen/21.0.5.crac/lib/criuengine restorewait
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;42035&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;44224&lt;/span&gt;          &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;       &lt;span class=&#34;se&#34;&gt;\_&lt;/span&gt; java -XX:CRaCCheckpointTo&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr -jar target/example-jetty-1.0-SNAPSHOT.jar
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;和前面 CRaC 实现原理分析一致，恢复的 JVM 进程是 &lt;code&gt;criuengine&lt;/code&gt; 的子进程。&lt;/p&gt;
&lt;h3 id=&#34;注意事项&#34;&gt;
    &lt;a href=&#34;#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    注意事项
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;架构与环境限制&lt;/strong&gt;
CRaC 的 Checkpoint 和 Restore &lt;strong&gt;必须在相同的 CPU 架构&lt;/strong&gt;（例如，都是 x64 或都是 ARM64）上进行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，它目前主要依赖 &lt;strong&gt;Linux&lt;/strong&gt; 操作系统和特定的支持 CRaC 的 JDK 构建版本（如 Azul Zulu CRaC builds, Apusic JDK with CRaC Support 等）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统时钟变化&lt;/strong&gt;
应用程序需要注意，从 Checkpoint 到 Restore 之间可能存在显著的&lt;strong&gt;系统时钟跳跃&lt;/strong&gt;。对于依赖时间的逻辑（如缓存过期、定时任务、同步机制），可能需要在 afterRestore 回调中进行校准或特殊处理，以避免因时间差导致的行为异常。虽然 OpenJDK CRaC 内部会尝试校准 System.nanoTime()，但应用层面的时间敏感逻辑仍需开发者关注。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;幂等性&lt;/strong&gt;
&lt;code&gt;beforeCheckpoint&lt;/code&gt; 和 &lt;code&gt;afterRestore&lt;/code&gt; 的实现应该是幂等的，即多次调用也应该产生相同的结果或无副作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安全性&lt;/strong&gt;
Checkpoint 镜像包含了 JVM 进程的完整内存状态，可能包含敏感数据（如密码、密钥、用户数据等）。必须像对待生产数据库备份一样，妥善保管 Checkpoint 文件，控制访问权限。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五crac-的应用场景与生态&#34;&gt;
    &lt;a href=&#34;#%e4%ba%94crac-%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e4%b8%8e%e7%94%9f%e6%80%81&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    五、CRaC 的应用场景与生态
&lt;/h2&gt;&lt;p&gt;CRaC 技术以其显著缩短启动时间和实现即时峰值性能的优势，在多个领域展现出巨大的应用潜力，并且其生态系统正在逐步发展壮大。&lt;/p&gt;
&lt;h3 id=&#34;理想应用场景&#34;&gt;
    &lt;a href=&#34;#%e7%90%86%e6%83%b3%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    理想应用场景
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Serverless Functions (FaaS)&lt;/strong&gt;
这是 CRaC 最典型的应用场景之一。Serverless 函数的冷启动延迟是影响用户体验和成本的关键因素。CRaC 可以将函数的启动时间从秒级降低到毫秒级，极大地改善冷启动性能，使得 Java 在 Serverless 领域更具竞争力。AWS Lambda SnapStart 就是基于类似 CRaC 的技术实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微服务&lt;/strong&gt;
在微服务架构中，服务实例需要频繁地启动、停止和水平扩展。CRaC 可以显著加快新服务实例的启动速度，提高自动伸缩（Auto-scaling）的响应能力和效率，尤其是在应对突发流量时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;批处理作业&lt;/strong&gt;
对于需要快速启动、执行任务然后退出的批处理作业，CRaC 可以消除大部分启动开销，提高作业执行效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资源受限环境&lt;/strong&gt;
在内存或 CPU 资源受限的环境中，CRaC 通过避免启动和预热阶段的高资源消耗，有助于更高效地利用资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;框架与平台支持&#34;&gt;
    &lt;a href=&#34;#%e6%a1%86%e6%9e%b6%e4%b8%8e%e5%b9%b3%e5%8f%b0%e6%94%af%e6%8c%81&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    框架与平台支持
&lt;/h3&gt;&lt;p&gt;随着 CRaC 技术的发展，越来越多的 Java 框架和平台开始提供对其的支持，以简化开发者的使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring Framework / Spring Boot&lt;/strong&gt;
从 Spring Framework 6.1 和 Spring Boot 3.2 开始，提供了对 CRaC 的官方支持。开发者可以通过简单的配置（例如 &lt;code&gt;-Dspring.context.checkpoint=onRefresh&lt;/code&gt;）实现应用启动时的自动 Checkpoint，或者手动触发 Checkpoint 以包含更完整的应用状态。Spring 会自动处理内部管理的资源（如数据库连接池、消息监听器等）的 CRaC 回调。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Micronaut&lt;/strong&gt;
Micronaut 框架提供了专门的 micronaut-crac 模块，可以方便地集成 CRaC 支持。它内置了对常见资源（如 Hikari 数据源、Redis 连接）的协调处理。Micronaut 的构建插件（如 Gradle 插件）甚至可以一键生成包含 CRaC 镜像的 Docker 镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Quarkus&lt;/strong&gt;
Quarkus 从 2.10.0 版本开始内置了对 CRaC 的基本支持。利用 Quarkus 的构建时优化和 CRaC 的运行时恢复能力，可以进一步提升应用的启动性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AWS Lambda SnapStart&lt;/strong&gt;
虽然底层实现细节未完全公开，但 AWS Lambda 的 SnapStart 功能在原理和效果上与 CRaC 非常相似，它允许用户为 Lambda 函数创建快照，并在调用时快速恢复，显著降低 Java Lambda 函数的冷启动延迟。这表明 CRaC 的理念已经在主流云平台上得到了应用和验证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Azul Zulu Builds of OpenJDK&lt;/strong&gt;
Azul 作为 CRaC 技术的主要推动者之一，提供了包含 CRaC 功能的 OpenJDK 发行版（Zulu），支持 Linux/x64 和 Linux/ARM64 平台，并为 Windows 和 macOS 提供用于开发和测试的模拟版本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;crac-部署方案&#34;&gt;
    &lt;a href=&#34;#crac-%e9%83%a8%e7%bd%b2%e6%96%b9%e6%a1%88&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    CRaC 部署方案
&lt;/h3&gt;&lt;p&gt;CRaC 的部署方案旨在收集 Java 应用程序初始化和预热所需的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504281423303.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;flow&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;在金丝雀环境中部署并预热应用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;将 Java 应用程序部署到金丝雀（canary）测试环境中。&lt;/li&gt;
&lt;li&gt;应用程序处理金丝雀请求，这会触发类加载和 JIT 编译，从而完成预热。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建 Checkpoint&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;对正在运行的应用程序进行 Checkpoint 操作。&lt;/li&gt;
&lt;li&gt;这将创建 JVM 和应用程序的镜像（image），该镜像被视为新部署包的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在生产环境中部署和恢复&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;将带有镜像的 Java 应用程序部署到生产环境中。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;-XX:CRaCRestoreFrom=PATH&lt;/code&gt; 选项从镜像恢复 Java 进程。&lt;/li&gt;
&lt;li&gt;恢复后的 Java 进程将直接使用镜像中已加载的类和 JIT 代码，从而实现快速启动和即时达到最佳性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;性能基准&#34;&gt;
    &lt;a href=&#34;#%e6%80%a7%e8%83%bd%e5%9f%ba%e5%87%86&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    性能基准
&lt;/h3&gt;&lt;p&gt;由 Java 社区及主流框架开发者进行的广泛性能基准测试一致表明，CRaC (Coordinated Restore at Checkpoint) 技术能够为 Java 应用带来显著的性能提升，尤其在启动速度方面表现突出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/2024/202504281408920.webp&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;crac&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对于常见的 Web 应用程序，例如基于 Spring Boot、Micronaut 或 Quarkus 构建的应用，采用 CRaC 的恢复机制可以将原先需要数秒的启动过程，&lt;strong&gt;缩短至几十毫秒级别&lt;/strong&gt;。这意味着应用能够更快地进入服务状态，提升用户体验和资源利用率。&lt;/p&gt;
&lt;p&gt;为了具体展示 CRaC 的效果，我对 Glassfish 7 进行了 CRaC 的改造适配。在部署了标准 Spring PetClinic 应用的场景下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;常规启动耗时：&lt;/strong&gt; 通过标准 &lt;code&gt;./bin/asadmin start-domain&lt;/code&gt; 命令启动，完成整个启动过程需要 &lt;strong&gt;8.813 秒&lt;/strong&gt; (8813 毫秒)。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./bin/asadmin start-domain
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Waiting &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; domain1 to start ........
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Waiting finished after 8,813 ms.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Successfully started the domain : domain1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;domain  Location: /home/mazhen/works/glassfish7/glassfish/domains/domain1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Log File: /home/mazhen/works/glassfish7/glassfish/domains/domain1/logs/server.log
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Admin Port: 4,848
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Command start-domain executed successfully.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CRaC 恢复耗时：&lt;/strong&gt; 从预先生成的 CRaC 快照 (checkpoint) 文件恢复，使用 &lt;code&gt;java -XX:CRaCRestoreFrom=cr&lt;/code&gt; 命令，启动过程&lt;strong&gt;仅需约 36.88 毫秒&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ java -XX:CRaCRestoreFrom&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.559868Z|INFO|GF 7.0.23-SNAPSHOT|jakarta.enterprise.logging.stdout|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  STARTUPTIME &lt;span class=&#34;m&#34;&gt;519895593501838&lt;/span&gt; restore&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.571942Z|INFO|GF 7.0.23-SNAPSHOT|org.glassfish.grizzly.config.GenericGrizzlyListener|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  After restore, start transport, &lt;span class=&#34;nv&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/0.0.0.0, &lt;span class=&#34;nv&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;8080&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.572851Z|INFO|GF 7.0.23-SNAPSHOT|org.glassfish.grizzly.config.GenericGrizzlyListener|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  After restore, start transport, &lt;span class=&#34;nv&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/0.0.0.0, &lt;span class=&#34;nv&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;8181&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.573165Z|INFO|GF 7.0.23-SNAPSHOT|org.glassfish.grizzly.config.GenericGrizzlyListener|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  After restore, start transport, &lt;span class=&#34;nv&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/0.0.0.0, &lt;span class=&#34;nv&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;4848&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.573409Z|INFO|GF 7.0.23-SNAPSHOT|org.glassfish.grizzly.config.GenericGrizzlyListener|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  After restore, start transport, &lt;span class=&#34;nv&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/0.0.0.0, &lt;span class=&#34;nv&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;3700&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#|2025-04-28T06:42:11.607504Z|INFO|GF 7.0.23-SNAPSHOT|jakarta.enterprise.logging.stdout|_ThreadID=323;_ThreadName=Attach Listener;_LevelValue=800;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  STARTUPTIME &lt;span class=&#34;m&#34;&gt;519895630386924&lt;/span&gt; restore-finish&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;恢复时间计算：&lt;code&gt;restore-finish - restore&lt;/code&gt;，恢复过程耗时为 &lt;code&gt;519895630386924 - 519895593501838 = 36,885,086&lt;/code&gt; 纳秒，即 &lt;strong&gt;36.88 毫秒&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对比结果清晰显示，使用 CRaC 恢复，启动时间缩短了约 239 倍 (8813 ms / 36.88 ms)，实现了数量级的性能飞跃。&lt;/p&gt;
&lt;p&gt;除了惊人的启动速度提升，CRaC 更为核心的优势在于实现了“即时峰值性能”。与传统启动方式不同，恢复后的应用程序&lt;strong&gt;几乎可以瞬间达到其完全预热 (warmed-up) 后的最佳运行性能&lt;/strong&gt;。这是因为它跳过了耗时的类加载、初始化以及 JIT (Just-In-Time) 编译器的早期编译和优化阶段。对于需要快速响应负载变化、频繁弹性伸缩或要求低延迟的场景 (如 Serverless、微服务快速扩容)，这一特性具有极其重要的价值。&lt;/p&gt;
&lt;h3 id=&#34;未来展望生态持续完善&#34;&gt;
    &lt;a href=&#34;#%e6%9c%aa%e6%9d%a5%e5%b1%95%e6%9c%9b%e7%94%9f%e6%80%81%e6%8c%81%e7%bb%ad%e5%ae%8c%e5%96%84&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    未来展望：生态持续完善
&lt;/h3&gt;&lt;p&gt;随着 OpenJDK 对 CRaC 项目的持续推进和标准化，以及越来越多第三方库、框架（如 Spring、Micronaut、Quarkus、Open Liberty 等）的积极适配与集成，CRaC 的生态系统正逐步成熟和完善。这预示着未来在 Java 应用中利用 Checkpoint/Restore 技术将变得更加便捷和普遍，有望成为提升 Java 应用启动性能和运行时效率的标准实践之一。&lt;/p&gt;
&lt;h2 id=&#34;六apusic-jdk-with-crac-support&#34;&gt;
    &lt;a href=&#34;#%e5%85%adapusic-jdk-with-crac-support&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    六、Apusic JDK with CRaC Support
&lt;/h2&gt;&lt;p&gt;Apusic JDK 是金蝶天燕（Apusic）公司基于 OpenJDK 项目构建和维护的 Java 开发工具包（JDK）发行版。为了满足用户对高性能和快速启动的需求，Apusic JDK 团队积极跟进社区前沿技术，并提供了对主流 LTS 版本的广泛支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基于 BiSheng JDK&lt;/strong&gt;
Apusic JDK 的上游是华为公司开源的 BiSheng JDK。BiSheng JDK 本身在 OpenJDK 的基础上进行了性能优化和特性增强，Apusic JDK 继承了这些优势，并结合自身在中间件领域的深厚积累，为企业级应用提供了稳定、高效的 Java 运行时环境。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持多 LTS 版本&lt;/strong&gt;
Apusic JDK 致力于提供稳定可靠的 Java 环境，目前为 &lt;strong&gt;Java 8, 11, 17, 21&lt;/strong&gt; 等多个长期支持（LTS）版本提供构建和支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为 JDK 17 和 21 引入 CRaC 支持&lt;/strong&gt;
Apusic 团队认识到 CRaC（Coordinated Restore at Checkpoint）技术在解决 Java 应用冷启动慢和提升运行时效率方面具有巨大潜力。然而，由于 CRaC 项目尚未正式合并到 OpenJDK 主线，Apusic 采用了与 Azul 等厂商类似的方式，&lt;strong&gt;主动将其核心功能移植（Port）并集成到了 Apusic JDK 17 和 Apusic JDK 21 发行版中&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提供特定版本的双重发行版&lt;/strong&gt;
为了方便用户根据实际需求进行选择，针对集成了 CRaC 功能的 &lt;strong&gt;JDK 17 和 JDK 21&lt;/strong&gt;，Apusic 提供了两种发行版：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标准的 Apusic JDK (17 / 21)&lt;/strong&gt; ：不包含 CRaC 功能，适用于不需要 Checkpoint/Restore 特性的标准 Java 应用场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Apusic JDK with CRaC Support (17 / 21)&lt;/strong&gt; ：内置了 CRaC 功能的特殊版本。用户可以使用这个版本来开发、测试和部署需要利用 CRaC 进行启动优化的 Java 应用程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过提供带有 CRaC 支持的 JDK 版本（目前为 JDK 17 和 21），Apusic 使得其用户能够在其熟悉的 JDK 发行版上，提前体验和应用 CRaC 技术带来的显著优势，特别是在微服务、Serverless 等对启动速度有严苛要求的场景下，能够获得明显的性能提升。用户在使用 Apusic JDK with CRaC Support 时，可以遵循 CRaC 的标准使用方法和最佳实践。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>使用火焰图进行Java性能分析</title>
        <link>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8%E7%81%AB%E7%84%B0%E5%9B%BE%E8%BF%9B%E8%A1%8Cjava%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
        <pubDate>Mon, 23 Mar 2020 11:01:58 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8%E7%81%AB%E7%84%B0%E5%9B%BE%E8%BF%9B%E8%A1%8Cjava%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
        <description>&lt;h2 id=&#34;性能分析工具的分类&#34;&gt;
    &lt;a href=&#34;#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7%e7%9a%84%e5%88%86%e7%b1%bb&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    性能分析工具的分类
&lt;/h2&gt;&lt;p&gt;性能分析的技术和工具可以分为以下几类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Counters&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内核维护着各种统计信息，被称为&lt;code&gt;Counters&lt;/code&gt;，用于对事件进行计数。例如，接收的网络数据包数量，发出的磁盘I/O请求，执行的系统调用次数。常见的这类工具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vmstat: 虚拟和物理内存统计&lt;/li&gt;
&lt;li&gt;mpstat: CPU使用率统计&lt;/li&gt;
&lt;li&gt;iostat：磁盘的I/O使用情况&lt;/li&gt;
&lt;li&gt;netstat：网络接口统计信息，TCP/IP协议栈统计信息，连接统计信息&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Tracing&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Tracing&lt;/strong&gt;是收集每个事件的数据进行分析。&lt;strong&gt;Tracing&lt;/strong&gt;会捕获所有的事件，因此有比较大的CPU开销，并且可能需要大量存储来保存数据。&lt;/p&gt;
&lt;p&gt;常见的&lt;strong&gt;Tracing&lt;/strong&gt;工具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tcpdump: network packet tracing&lt;/li&gt;
&lt;li&gt;blktrace: block I/O tracing&lt;/li&gt;
&lt;li&gt;perf: Linux Performance Events, 跟踪静态和动态探针&lt;/li&gt;
&lt;li&gt;strace: 系统调用tracing&lt;/li&gt;
&lt;li&gt;gdb: 源代码级调试器&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;Profiling&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Profiling&lt;/strong&gt; 是通过收集目标行为的样本或快照，来了解目标的特征。&lt;strong&gt;Profiling&lt;/strong&gt;可以从多个方面对程序进行动态分析，如&lt;code&gt;CPU&lt;/code&gt;、&lt;code&gt;Memory&lt;/code&gt;、&lt;code&gt;Thread&lt;/code&gt;、&lt;code&gt;I/O&lt;/code&gt;等，其中对&lt;code&gt;CPU&lt;/code&gt;进行&lt;code&gt;Profiling&lt;/code&gt;的应用最为广泛。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CPU Profiling&lt;/code&gt;原理是基于一定频率对运行的程序进行采样，来分析消耗CPU时间的代码路径。可以基于固定的时间间隔进行采样，例如每10毫秒采样一次。也可以设置固定速率采样，例如每秒采集100个样本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CPU Profiling&lt;/code&gt;经常被用于分析代码的热点，比如“哪个方法占用CPU的执行时间最长”、“每个方法占用CPU的比例是多少”等等，然后我们就可以针对热点瓶颈进行分析和性能优化。&lt;/p&gt;
&lt;p&gt;Linux上常用的&lt;strong&gt;CPU Profiling&lt;/strong&gt;工具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://perf.wiki.kernel.org/index.php/Main_Page&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;perf&lt;/a&gt;的 &lt;a class=&#34;link&#34; href=&#34;https://perf.wiki.kernel.org/index.php/Tutorial#Sampling_with_perf_record&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;record&lt;/a&gt; 子命令&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc/blob/master/tools/profile.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BPF profile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;Monitoring&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;系统性能监控会记录一段时间内的性能统计信息，以便能够基于时间周期进行比较。这对于容量规划，了解高峰期的使用情况都很有帮助。历史值还为我们理解当前的性能指标提供了上下文。&lt;/p&gt;
&lt;p&gt;监控单个操作系统最常用工具是&lt;strong&gt;sar&lt;/strong&gt;（system activity reporter，系统活动报告）命令。&lt;code&gt;sar&lt;/code&gt;通过一个定期执行的agent来记录系统计数器的状态，并可以使用&lt;code&gt;sar&lt;/code&gt;命令查看它们，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sar
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Linux 4.15.0-88-generic (mazhen) 	03/19/2020 	_x86_64_	(4 CPU)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:53:08 PM       LINUX RESTART
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:55:01 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;01:05:01 PM     all     14.06      0.00     10.97      0.11      0.00     74.87
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;01:15:01 PM     all      9.60      0.00      7.49      0.09      0.00     82.83
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;01:25:01 PM     all      0.04      0.00      0.02      0.02      0.00     99.92
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;01:35:01 PM     all      0.03      0.00      0.02      0.01      0.00     99.94
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;本文主要讨论如何使用&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;BPF&lt;/code&gt;进行&lt;code&gt;CPU Profiling&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;perf&#34;&gt;
    &lt;a href=&#34;#perf&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    perf
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;perf&lt;/strong&gt;最初是使用&lt;code&gt;Linux&lt;/code&gt;性能计数器子系统的工具，因此&lt;code&gt;perf&lt;/code&gt;开始的名称是&lt;code&gt;Performance Counters for Linux&lt;/code&gt;(PCL)。&lt;code&gt;perf&lt;/code&gt;在Linux&lt;code&gt;2.6.31&lt;/code&gt;合并进内核，位于&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/tree/master/tools/perf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tools/perf&lt;/a&gt;目录下。&lt;/p&gt;
&lt;p&gt;随后&lt;code&gt;perf&lt;/code&gt;进行了各种增强，增加了&lt;code&gt;tracing&lt;/code&gt;、&lt;code&gt;profiling&lt;/code&gt;等能力，可用于性能瓶颈的查找和热点代码的定位。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;是一个面向事件（event-oriented）的性能剖析工具，因此它也被称为&lt;code&gt;Linux perf events (LPE)&lt;/code&gt;，或&lt;code&gt;perf_events&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;的整体架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241109248.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;perf&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt; 由两部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;perf Tools&lt;/strong&gt;：perf用户态命令，为用户提供了一系列工具集，用于收集、分析性能数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;perf Event Subsystem&lt;/strong&gt;：Perf Events是内核的子系统之一，和用户态工具共同完成数据的采集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核依赖的硬件，比如说&lt;code&gt;CPU&lt;/code&gt;，一般会内置一些性能统计方面的寄存器（&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Hardware_performance_counter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hardware Performance Counter&lt;/a&gt;），通过软件读取这些特殊寄存器里的信息，我们也可以得到很多直接关于硬件的信息。&lt;code&gt;perf&lt;/code&gt;最初就是用来监测&lt;code&gt;CPU&lt;/code&gt;的性能监控单元（performance monitoring unit, PMU）的。&lt;/p&gt;
&lt;h3 id=&#34;perf-events分类&#34;&gt;
    &lt;a href=&#34;#perf-events%e5%88%86%e7%b1%bb&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    perf Events分类
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;支持多种性能事件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241110166.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;event sources&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这些性能事件分类为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hardware Events&lt;/strong&gt;: CPU性能监控计数器performance monitoring counters（PMC），也被称为performance monitoring unit（PMU）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Software Events&lt;/strong&gt;: 基于内核计数器的底层事件。例如，CPU迁移，minor faults，major faults等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kernel Tracepoint Events&lt;/strong&gt;: 内核的静态&lt;code&gt;Tracepoint&lt;/code&gt;，已经硬编码在内核需要收集信息的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User Statically-Defined Tracing (USDT)&lt;/strong&gt;: 用户级程序的静态&lt;code&gt;Tracepoint&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic Tracing&lt;/strong&gt;: 用户自定义事件，可以动态的插入到内核或正在运行中的程序。&lt;code&gt;Dynamic Tracing&lt;/code&gt;技术分为两类：
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://lwn.net/Articles/132196/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;kprobes&lt;/a&gt;：对于kernel的动态追踪技术，可以动态地在指定的内核函数的入口和出口等位置上放置探针，并定义自己的探针处理程序。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://lwn.net/Articles/499190/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;uprobes&lt;/a&gt;：对于用户态软件的动态追踪技术，可以安全地在用户态函数的入口等位置设置动态探针，并执行自己的探针处理程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用perf的&lt;code&gt;list&lt;/code&gt;子命令查看当前可用的事件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo perf list
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;List of pre-defined events (to be used in -e):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  branch-instructions OR branches                    [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  branch-misses                                      [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  bus-cycles                                         [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cache-misses                                       [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cache-references                                   [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cpu-cycles OR cycles                               [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  alignment-faults                                   [Software event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  bpf-output                                         [Software event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  context-switches OR cs                             [Software event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cpu-clock                                          [Software event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cpu-migrations OR migrations                       [Software event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  alarmtimer:alarmtimer_cancel                       [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  alarmtimer:alarmtimer_fired                        [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  alarmtimer:alarmtimer_start                        [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  alarmtimer:alarmtimer_suspend                      [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  block:block_bio_backmerge                          [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  block:block_bio_bounce                             [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;perf的使用&#34;&gt;
    &lt;a href=&#34;#perf%e7%9a%84%e4%bd%bf%e7%94%a8&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    perf的使用
&lt;/h3&gt;&lt;p&gt;如果还没有安装&lt;code&gt;perf&lt;/code&gt;，可以使用&lt;code&gt;apt&lt;/code&gt;或&lt;code&gt;yum&lt;/code&gt;进行安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;apt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;install&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;linux&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tools&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-$&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uname&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;linux&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tools&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;generic&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;的功能强大，支持硬件计数器统计，定时采样，静态和动态tracing等。本文只介绍几个常用的使用场景，如果想全面的了解&lt;code&gt;perf&lt;/code&gt;的使用，可以参考&lt;a class=&#34;link&#34; href=&#34;https://perf.wiki.kernel.org/index.php/Main_Page&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;perf.wiki&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CPU Statistics&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用&lt;code&gt;perf&lt;/code&gt;的&lt;code&gt;stat&lt;/code&gt;命令可以收集性能计数器统计信息，精确统计一段时间内 CPU 相关硬件计数器数值的变化。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-&amp;gt; % sudo perf stat  dd if=/dev/zero of=/dev/null count=10000000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10000000+0 records in
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10000000+0 records out
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5120000000 bytes (5.1 GB, 4.8 GiB) copied, 12.2795 s, 417 MB/s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Performance counter stats for &amp;#39;dd if=/dev/zero of=/dev/null count=10000000&amp;#39;:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      12280.299325      task-clock (msec)         #    1.000 CPUs utilized          
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                16      context-switches          #    0.001 K/sec                  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 0      cpu-migrations            #    0.000 K/sec                  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                70      page-faults               #    0.006 K/sec                  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    41,610,802,323      cycles                    #    3.388 GHz                    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    20,195,746,887      instructions              #    0.49  insn per cycle         
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     3,972,723,471      branches                  #  323.504 M/sec                  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        90,061,565      branch-misses             #    2.27% of all branches        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      12.280445133 seconds time elapsed
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;CPU Profiling&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以使用&lt;code&gt;perf record&lt;/code&gt;以任意频率收集快照。这通常用于CPU使用情况的分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo perf record -F 99 -a -g  sleep 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对所有CPU（&lt;strong&gt;-a&lt;/strong&gt;）进行&lt;code&gt;call stacks&lt;/code&gt;（&lt;strong&gt;-g&lt;/strong&gt;）采样，采样频率为&lt;code&gt;99 Hertz&lt;/code&gt;（&lt;strong&gt;-F 99&lt;/strong&gt;），即每秒99次，持续10秒（&lt;strong&gt;sleep 10&lt;/strong&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo perf record -F 99 -a -g  -p PID sleep 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对指定进程（&lt;strong&gt;-p PID&lt;/strong&gt;）进行采样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo perf record -F 99 -a -g -e context-switches -p PID sleep 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;可以和各种&lt;code&gt;instrumentation points&lt;/code&gt;一起使用，以跟踪内核调度程序（&lt;code&gt;scheduler&lt;/code&gt;）的活动。其中包括&lt;code&gt;software events&lt;/code&gt;和&lt;code&gt;tracepoint event&lt;/code&gt;（静态探针）。&lt;/p&gt;
&lt;p&gt;上面的例子对指定进程的上下文切换（&lt;strong&gt;-e context-switches&lt;/strong&gt;）进行采样。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;report&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;perf record&lt;/code&gt;的运行结果保存在当前目录的&lt;code&gt;perf.data&lt;/code&gt;文件中，采样结束后，我们使用&lt;code&gt;perf report&lt;/code&gt;查看结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;交互式查看模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo perf report
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241111810.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;perf report&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;+&lt;/code&gt;开头的行可以回车，展开详细信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用&lt;code&gt;--stdio&lt;/code&gt;选项打印所有输出&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo perf report --stdio
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241111875.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;perf report &amp;ndash;stdio&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;context-switches&lt;/code&gt;的采样报告：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241112884.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;perf-report-context-switches&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;后面我们会介绍&lt;strong&gt;火焰图&lt;/strong&gt;，以可视化的方式展示&lt;code&gt;stack traces&lt;/code&gt;，比&lt;code&gt;perf report&lt;/code&gt;更加直观。&lt;/p&gt;
&lt;h2 id=&#34;bpf&#34;&gt;
    &lt;a href=&#34;#bpf&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    BPF
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;BPF&lt;/strong&gt;是&lt;strong&gt;Berkeley Packet Filter&lt;/strong&gt;的缩写，最初是为BSD开发，第一个版本于1992年发布，&lt;a class=&#34;link&#34; href=&#34;https://www.tcpdump.org/papers/bpf-usenix93.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;用于改进网络数据包捕获的性能&lt;/a&gt;。&lt;code&gt;BPF&lt;/code&gt;是在内核级别进行过滤，不必将每个数据包拷贝到用户空间，从而提高了数据包过滤的性能。&lt;code&gt;tcpdump&lt;/code&gt;使用的就是&lt;code&gt;BPF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241113910.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;2013年&lt;code&gt;BPF&lt;/code&gt;被重写，被称为&lt;strong&gt;Extended BPF (eBPF)&lt;/strong&gt;，于2014年包含进&lt;code&gt;Linux&lt;/code&gt;内核中。改进后的&lt;code&gt;BPF&lt;/code&gt;成为了通用执行引擎，可用于多种用途，包括创建高级性能分析工具。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BPF&lt;/code&gt;允许在内核中运行&lt;code&gt;mini programs&lt;/code&gt;，来响应系统和应用程序事件（例如磁盘I/O事件）。这种运作机制和&lt;code&gt;JavaScript&lt;/code&gt;类似：&lt;code&gt;JavaScript&lt;/code&gt;是运行在浏览器引擎中的&lt;code&gt;mini programs&lt;/code&gt;，响应鼠标点击等事件。&lt;code&gt;BPF&lt;/code&gt;使内核可编程化，使用户（包括非内核开发人员）能够自定义和控制他们的系统，以解决实际问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BPF&lt;/code&gt;可以被认为是一个&lt;strong&gt;虚拟机&lt;/strong&gt;，由指令集，存储对象和helper函数三部分组成。&lt;code&gt;BPF&lt;/code&gt;指令集由位于Linux内核的&lt;code&gt;BPF runtime&lt;/code&gt;执行，&lt;code&gt;BPF runtime&lt;/code&gt;包括了&lt;strong&gt;解释器&lt;/strong&gt;和&lt;strong&gt;JIT编译器&lt;/strong&gt;。&lt;code&gt;BPF&lt;/code&gt;是一种灵活高效的技术，可以用于&lt;code&gt;networking&lt;/code&gt;，&lt;code&gt;tracing&lt;/code&gt;和安全等领域。我们重点关注它作为系统监测工具方面的应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241114773.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;linux_ebpf_internals&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;perf&lt;/code&gt;一样，&lt;code&gt;BPF&lt;/code&gt;能够监测多种性能事件源，同时可以通过调用&lt;code&gt;perf_events&lt;/code&gt;，使用&lt;code&gt;perf&lt;/code&gt;已有的功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241114535.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;linux_ebpf_support&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BPF&lt;/code&gt;可以在内核运行计算和统计汇总，这样大大减少了复制到用户空间的数据量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241115194.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;before_and_after_using_BPF&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BPF&lt;/code&gt;已经内置在Linux内核中，因此你无需再安装任何新的内核组件，就可以在生产环境中使用BPF。&lt;/p&gt;
&lt;h2 id=&#34;bcc和bpftrace&#34;&gt;
    &lt;a href=&#34;#bcc%e5%92%8cbpftrace&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    BCC和bpftrace
&lt;/h2&gt;&lt;p&gt;直接使用&lt;code&gt;BPF&lt;/code&gt;指令进行编程非常繁琐，因此很有必要提供高级语言前端方便用户使用，于是就出现了&lt;code&gt;BCC&lt;/code&gt;和&lt;code&gt;bpftrace&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241116502.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;bcc-bpftrace&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BCC（BPF Compiler Collection）&lt;/strong&gt; 提供了一个C编程环境，使用&lt;code&gt;LLVM&lt;/code&gt;工具链来把 C 代码编译为&lt;code&gt;BPF&lt;/code&gt;虚拟机所接受的字节码。此外它还支持&lt;code&gt;Python&lt;/code&gt;，&lt;code&gt;Lua&lt;/code&gt;和&lt;code&gt;C++&lt;/code&gt;作为用户接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bpftrace&lt;/strong&gt; 是一个比较新的前端，它为开发&lt;code&gt;BPF&lt;/code&gt;工具提供了一种专用的高级语言。&lt;code&gt;bpftrace&lt;/code&gt;适合单行代码和自定义短脚本，而&lt;code&gt;BCC&lt;/code&gt;更适合复杂的脚本和守护程序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BCC&lt;/code&gt;和&lt;code&gt;bpftrace&lt;/code&gt;没有在内核代码库，它们存放在GitHub上名为&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;IO Visor&lt;/a&gt;的&lt;code&gt;Linux Foundation&lt;/code&gt;项目中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;iovisor/bcc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;iovisor/bpftrace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bcc的安装&#34;&gt;
    &lt;a href=&#34;#bcc%e7%9a%84%e5%ae%89%e8%a3%85&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    BCC的安装
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;BCC&lt;/code&gt;可以参考官方的&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc/blob/master/INSTALL.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;安装文档&lt;/a&gt;。以&lt;code&gt;Ubuntu 18.04 LTS&lt;/code&gt;为例，建议从源码build安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装build依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get -y install bison build-essential cmake flex git libedit-dev \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  libllvm6.0 llvm-6.0-dev libclang-6.0-dev python zlib1g-dev libelf-dev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get -y install luajit luajit-5.1-dev
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;编译和安装&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/iovisor/bcc.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir bcc/build; cd bcc/build
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake ..
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;build python3 binding&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake -DPYTHON_CMD=python3 .. 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pushd src/python/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;popd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;make install&lt;/code&gt;完成后，&lt;code&gt;BCC&lt;/code&gt;自带的工具都安装在了&lt;code&gt;/usr/share/bcc/tools&lt;/code&gt;目录下。&lt;code&gt;BCC&lt;/code&gt;已经包含70多个&lt;code&gt;BPF&lt;/code&gt;工具，用于性能分析和故障排查。这些工具都可以直接使用，无需编写任何&lt;code&gt;BCC&lt;/code&gt;代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241116881.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;bcc_tracing_tools&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我们试用其中一个工具&lt;code&gt;biolatency&lt;/code&gt;，跟踪磁盘&lt;code&gt;I/O&lt;/code&gt;延迟：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;usr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;share&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bcc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tools&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;biolatency&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Tracing&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;device&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Hit&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Ctrl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;^&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;usecs&lt;/span&gt;               &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;     &lt;span class=&#34;n&#34;&gt;distribution&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;          &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;                                        &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;          &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;                                        &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;          &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;                                        &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;         &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;                                        &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;31&lt;/span&gt;         &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|***&lt;/span&gt;                                     &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;63&lt;/span&gt;         &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;                                        &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;64&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;127&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|*****&lt;/span&gt;                                   &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|***********&lt;/span&gt;                             &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;mi&#34;&gt;256&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;511&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|**********&lt;/span&gt;                              &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;mi&#34;&gt;512&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1023&lt;/span&gt;       &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt;       &lt;span class=&#34;o&#34;&gt;|******************&lt;/span&gt;                      &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;mi&#34;&gt;1024&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2047&lt;/span&gt;       &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;       &lt;span class=&#34;o&#34;&gt;|**************************&lt;/span&gt;              &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;mi&#34;&gt;2048&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4095&lt;/span&gt;       &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;24&lt;/span&gt;       &lt;span class=&#34;o&#34;&gt;|****************************************|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8191&lt;/span&gt;       &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|*&lt;/span&gt;                                       &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;mi&#34;&gt;8192&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16383&lt;/span&gt;      &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|**********&lt;/span&gt;                              &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;mi&#34;&gt;16384&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32767&lt;/span&gt;      &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;|*****&lt;/span&gt;                                   &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;biolatency&lt;/code&gt;展示的直方图比&lt;code&gt;iostat&lt;/code&gt;的平均值能更好的理解磁盘&lt;code&gt;I/O&lt;/code&gt;性能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BCC&lt;/code&gt;已经自带了&lt;code&gt;CPU profiling&lt;/code&gt;工具：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc/blob/master/tools/profile.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tools/profile&lt;/a&gt;: Profile CPU usage by sampling stack traces at a timed interval.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，&lt;code&gt;BCC&lt;/code&gt;还提供了&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/offcpuanalysis.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Off-CPU&lt;/a&gt;的分析工具：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc/blob/master/tools/offcputime.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tools/offcputime&lt;/a&gt;: Summarize off-CPU time by kernel stack trace&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般的&lt;code&gt;CPU profiling&lt;/code&gt;都是分析&lt;code&gt;on-CPU&lt;/code&gt;，即CPU时间都花费在了哪些代码路径。&lt;code&gt;off-CPU&lt;/code&gt;是指进程不在CPU上运行时所花费的时间，进程因为某种原因处于休眠状态，比如说等待锁，或者被进程调度器（scheduler）剥夺了 CPU 的使用。这些情况都会导致这个进程无法运行在 CPU 上，但是仍然花费了时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241117655.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;thread_states&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;off-CPU&lt;/code&gt;分析是对&lt;code&gt;on-CPU&lt;/code&gt;的补充，让我们知道线程所有的时间花费，更全面的了解程序的运行情况。&lt;/p&gt;
&lt;p&gt;后面会介绍&lt;code&gt;profile&lt;/code&gt;，&lt;code&gt;offcputime&lt;/code&gt;如何生成火焰图进行可视化分析。&lt;/p&gt;
&lt;h3 id=&#34;bpftrace的安装&#34;&gt;
    &lt;a href=&#34;#bpftrace%e7%9a%84%e5%ae%89%e8%a3%85&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    bpftrace的安装
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;bpftrace&lt;/a&gt; 建议运行在Linux 4.9 kernel或更高版本。根据&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace/blob/master/INSTALL.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;安装文档&lt;/a&gt;的说明，是因为&lt;code&gt;kprobes&lt;/code&gt;、&lt;code&gt;uprobes&lt;/code&gt;、&lt;code&gt;tracepoints&lt;/code&gt;等主要特性是在&lt;code&gt;4.x&lt;/code&gt;以上加入内核的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;4.1 - kprobes&lt;/li&gt;
&lt;li&gt;4.3 - uprobes&lt;/li&gt;
&lt;li&gt;4.6 - stack traces, count and hist builtins (use PERCPU maps for accuracy and efficiency)&lt;/li&gt;
&lt;li&gt;4.7 - tracepoints&lt;/li&gt;
&lt;li&gt;4.9 - timers/profiling&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以运行&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace/blob/master/scripts/check_kernel_features.sh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;scripts/check_kernel_features.sh&lt;/a&gt;脚本进行验证：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ./scripts/check_kernel_features.sh 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;All required features present!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;bpftrace&lt;/code&gt;对Linux的版本要求较高，以&lt;code&gt;Ubuntu&lt;/code&gt;为例，&lt;code&gt;19.04&lt;/code&gt;及以上才支持&lt;code&gt;apt&lt;/code&gt;安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install -y libbpfcc-dev
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;18.04&lt;/code&gt;和&lt;code&gt;18.10&lt;/code&gt;可以从源码build，但需要先build好&lt;code&gt;BCC&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install -y bison cmake flex g++ git libelf-dev zlib1g-dev libfl-dev systemtap-sdt-dev binutils-dev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install -y llvm-7-dev llvm-7-runtime libclang-7-dev clang-7
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;编译和安装&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/iovisor/bpftrace
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir bpftrace/build; cd bpftrace/build;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake -DCMAKE_BUILD_TYPE=Release ..
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make -j8
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;make install&lt;/code&gt;完成后，&lt;code&gt;bpftrace&lt;/code&gt;自带的工具安装在&lt;code&gt;/usr/local/share/bpftrace/tools&lt;/code&gt;目录下，这些工具的说明文档可以在&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;项目主页&lt;/a&gt;找到。&lt;/p&gt;
&lt;p&gt;我们同样试用查看&lt;code&gt;Block I/O&lt;/code&gt;延迟直方图的工具：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bpftrace&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;usr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;local&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;share&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bpftrace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tools&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;biolatency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bt&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Attaching&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;probes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Tracing&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;device&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Hit&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Ctrl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;^&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;usecs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;             &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@@@@@@@@@@&lt;/span&gt;                                          &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;512&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;             &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@@@@@@&lt;/span&gt;                                              &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;512&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;              &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@@@@@@@@@@@@@&lt;/span&gt;                                       &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;              &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;/span&gt;                  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;              &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;               &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;                                                   &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;              &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@@@@@&lt;/span&gt;                                               &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;             &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;                                                    &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;64&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;             &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@@@&lt;/span&gt;                                                 &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;关于&lt;code&gt;bpftrace&lt;/code&gt;脚本编写不在本文的讨论范围，感兴趣的可以参考&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;reference_guide&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;火焰图&#34;&gt;
    &lt;a href=&#34;#%e7%81%ab%e7%84%b0%e5%9b%be&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    火焰图
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;火焰图&lt;/a&gt;是&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Brendan Gregg&lt;/a&gt;发明的将&lt;code&gt;stack traces&lt;/code&gt;可视化展示的方法。火焰图把时间和空间两个维度上的信息融合在一张图上，将频繁执行的代码路径以可视化的形式，非常直观的展现了出来。&lt;/p&gt;
&lt;p&gt;火焰图可以用于可视化来自任何&lt;code&gt;profiler&lt;/code&gt;工具的记录的&lt;code&gt;stack traces&lt;/code&gt;信息，除了用来&lt;code&gt;CPU profiling&lt;/code&gt;，还适用于&lt;code&gt;off-CPU&lt;/code&gt;，&lt;code&gt;page faults&lt;/code&gt;等多种场景的分析。本文只讨论 &lt;code&gt;on-CPU&lt;/code&gt; 和 &lt;code&gt;off-CPU&lt;/code&gt; 火焰图的生成。&lt;/p&gt;
&lt;p&gt;要理解火焰图，先从理解&lt;code&gt;Stack Trace&lt;/code&gt;开始。&lt;/p&gt;
&lt;h3 id=&#34;stack-trace&#34;&gt;
    &lt;a href=&#34;#stack-trace&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Stack Trace
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Stack Trace&lt;/code&gt;是程序执行过程中，在特定时间点的函数调用列表。例如，&lt;code&gt;func_a()&lt;/code&gt;调用&lt;code&gt;func_b()&lt;/code&gt;，&lt;code&gt;func_b()&lt;/code&gt;调用&lt;code&gt;func_c()&lt;/code&gt;，此时的&lt;code&gt;Stack Trace&lt;/code&gt;可写为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_b
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_a
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;profiling-stack-traces&#34;&gt;
    &lt;a href=&#34;#profiling-stack-traces&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Profiling Stack Traces
&lt;/h3&gt;&lt;p&gt;我们做&lt;code&gt;CPU profiling&lt;/code&gt;时，会使用perf或bcc定时采样&lt;code&gt;Stack Trace&lt;/code&gt;，这样会收集到非常多的&lt;code&gt;Stack Trace&lt;/code&gt;。前面介绍了&lt;code&gt;perf report&lt;/code&gt;会将&lt;code&gt;Stack Trace&lt;/code&gt;样本汇总为调用树，并显示每个路径的百分比。火焰图是怎么展示的呢？&lt;/p&gt;
&lt;p&gt;考虑下面的示例，我们用perf定时采样收集了多个&lt;code&gt;Stack Trace&lt;/code&gt;，然后将相同的&lt;code&gt;Stack Trace&lt;/code&gt;归纳合并，统计出次数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_e
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_b
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_b
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_b
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看到，总共收集了10个样本，其中代码路径&lt;code&gt;func_a-&amp;gt;func_b-&amp;gt;func_c&lt;/code&gt;有7次，该路径上的&lt;code&gt;func_c&lt;/code&gt;在CPU上运行。 &lt;code&gt;func_a-&amp;gt;func_b&lt;/code&gt;进行了两次采样，&lt;code&gt;func_b&lt;/code&gt;在CPU上运行。&lt;code&gt;func_a-&amp;gt;func_b-&amp;gt;func_d-&amp;gt;func_e&lt;/code&gt;一次采样，&lt;code&gt;func_e&lt;/code&gt;在CPU上运行。&lt;/p&gt;
&lt;h3 id=&#34;火焰图-1&#34;&gt;
    &lt;a href=&#34;#%e7%81%ab%e7%84%b0%e5%9b%be-1&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    火焰图
&lt;/h3&gt;&lt;p&gt;根据前面对&lt;code&gt;Stack Trace&lt;/code&gt;的统计信息，可以绘制出如下的火焰图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241117302.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;flame-graph-demo&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;火焰图具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个长方块代表了函数调用栈中的一个函数&lt;/li&gt;
&lt;li&gt;Y 轴显示堆栈的深度（堆栈中的帧数）。调用栈越深，火焰就越高。顶层方块表示 CPU 上正在运行的函数，下面的函数即为它的祖先。&lt;/li&gt;
&lt;li&gt;X 轴的宽度代表被采集的样本数量，越宽表示采集到的越多，即执行的时间长。需要注意的是，X轴从左到右不代表时间，而是所有的调用栈合并后，按字母顺序排列的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拿到火焰图，寻找最宽的塔并首先了解它们。顶层的哪个函数占据的宽度最大，说明它可能存在性能问题。&lt;/p&gt;
&lt;p&gt;可以使用Brendan Gregg开发的开源项目&lt;a class=&#34;link&#34; href=&#34;https://github.com/brendangregg/FlameGraph&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;FlameGraph&lt;/a&gt;生成交互式的SVG火焰图。该项目提供了脚本，可以将采集的样本归纳合并，统计出&lt;code&gt;Stack Trace&lt;/code&gt;出现的频率，然后使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/brendangregg/FlameGraph/blob/master/flamegraph.pl&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;flamegraph.pl&lt;/a&gt;生成SVG火焰图。&lt;/p&gt;
&lt;p&gt;我们先把FlameGraph项目clone下来，后面会用到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/brendangregg/FlameGraph.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;java-cpu-profiling&#34;&gt;
    &lt;a href=&#34;#java-cpu-profiling&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Java CPU Profiling
&lt;/h2&gt;&lt;p&gt;虽然有很多Java专用的&lt;code&gt;profiler&lt;/code&gt;工具，但这些工具一般只能看到Java方法的执行，缺少了&lt;code&gt;GC&lt;/code&gt;，&lt;code&gt;JVM&lt;/code&gt;的CPU时间消耗，并且有些工具的&lt;code&gt;Method tracing&lt;/code&gt;性能损耗比较大。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;BCC profile&lt;/code&gt;的优点是它很高效，在内核上下文中对堆栈进行计数，并能完整显示用户态和内核态的CPU使用，能看到native libraries（例如libc），JVM（libjvm），Java方法和内核中花费的时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241118729.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;java-profilers&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;但是，&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;BCC profile&lt;/code&gt;这种系统级的profiler不能很好地与Java配合使用，它们识别不了Java方法和&lt;code&gt;stack traces&lt;/code&gt;。这是因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM的&lt;code&gt;JIT（just-in-time）&lt;/code&gt;没有给系统级profiler公开符号表&lt;/li&gt;
&lt;li&gt;JVM还使用帧指针寄存器（frame pointer register，x86-64上的RBP）作为通用寄存器，打破了传统的堆栈遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了能生成包含Java栈与Native栈的火焰图，目前有两种解决方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;JVMTI&lt;/code&gt; agent &lt;a class=&#34;link&#34; href=&#34;https://github.com/jvm-profiling-tools/perf-map-agent&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;perf-map-agent&lt;/a&gt;，生成Java符号表，供&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;bcc&lt;/code&gt;读取（/tmp/perf-PID.map）。同时要加上&lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt; JVM 参数，让&lt;code&gt;perf&lt;/code&gt;可以遍历基于帧指针（frame pointer）的堆栈。&lt;/li&gt;
&lt;li&gt;使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/jvm-profiling-tools/async-profiler&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;async-profiler&lt;/a&gt;，该项目将&lt;code&gt;perf&lt;/code&gt;的堆栈追踪和JDK提供的&lt;a class=&#34;link&#34; href=&#34;http://psy-lob-saw.blogspot.com/2016/06/the-pros-and-cons-of-agct.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AsyncGetCallTrace&lt;/a&gt;结合了起来，同样能够获得mixed-mode火焰图。同时，此方法不需要启用帧指针，所以不用加上&lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt;参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们就分别演示这两种方式。&lt;/p&gt;
&lt;h3 id=&#34;perf-map-agent&#34;&gt;
    &lt;a href=&#34;#perf-map-agent&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    perf-map-agent
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;期望能从&lt;code&gt;/tmp/perf-&amp;lt;pid&amp;gt;.map&lt;/code&gt;中获得在未知内存区域执行的代码的符号表。&lt;code&gt;perf-map-agent&lt;/code&gt;可以为&lt;code&gt;JIT&lt;/code&gt;编译的方法生成&lt;code&gt;/tmp/perf-&amp;lt;pid&amp;gt;.map&lt;/code&gt;文件，以满足&lt;code&gt;perf&lt;/code&gt;的要求。&lt;/p&gt;
&lt;p&gt;首先下载并编译&lt;code&gt;perf-map-agent&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;git&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clone&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;https&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;github&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;com&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;profiling&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tools&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;perf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;agent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;git&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cd&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;perf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;agent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cmake&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;make&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;配合perf使用&#34;&gt;
    &lt;a href=&#34;#%e9%85%8d%e5%90%88perf%e4%bd%bf%e7%94%a8&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    配合&lt;code&gt;perf&lt;/code&gt;使用
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;perf-map-agent&lt;/code&gt;提供了&lt;a class=&#34;link&#34; href=&#34;https://github.com/jvm-profiling-tools/perf-map-agent/blob/master/bin/perf-java-flames&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;perf-java-flames&lt;/a&gt;脚本，可以一步生成火焰图。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf-java-flames&lt;/code&gt;接收&lt;code&gt;perf record&lt;/code&gt;命令参数，它会调用&lt;code&gt;perf&lt;/code&gt;进行采样，然后使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/brendangregg/FlameGraph&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;FlameGraph&lt;/a&gt;生成火焰图，一步完成，非常方便。&lt;/p&gt;
&lt;p&gt;注意，记得要给被&lt;code&gt;profiling&lt;/code&gt;的Java进程加上&lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt; JVM 参数。&lt;/p&gt;
&lt;p&gt;设置必要的环境变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FLAMEGRAPH_DIR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FlameGraph&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;所在的目录&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PERF_RECORD_SECONDS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;采样时间&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./bin/perf-java-flames  [PID] -F 99 -a -g -p [PID]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对指定进程（&lt;strong&gt;-p PID&lt;/strong&gt;），在所有CPU（&lt;strong&gt;-a&lt;/strong&gt;）上进行call stacks（&lt;strong&gt;-g&lt;/strong&gt;）采样，采样频率为99 Hertz （&lt;strong&gt;-F 99&lt;/strong&gt;），持续时间为&lt;code&gt;PERF_RECORD_SECONDS&lt;/code&gt;秒。命令运行完成后，会在当前目录生成名为&lt;code&gt;flamegraph-pid.svg&lt;/code&gt;的火焰图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241119221.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;java-flamegraph&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./bin/perf-java-flames  [PID] -F 99 -g -a -e context-switches -p [PID]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对指定进程的上下文切换（&lt;strong&gt;-e context-switches&lt;/strong&gt;）进行采样，并生成火焰图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当然也可以只为&lt;code&gt;perf&lt;/code&gt;生成Java符号表，然后直接使用perf采样&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./bin/create-java-perf-map.sh [PID]; sudo perf record -F 99 -p [PID] -a -g -- sleep 15
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./bin/create-java-perf-map.sh [PID]; sudo perf record -g -a -e context-switches -p [PID] sleep 15
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 查看报告
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo perf report --stdio
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;配合bcc-profile使用&#34;&gt;
    &lt;a href=&#34;#%e9%85%8d%e5%90%88bcc-profile%e4%bd%bf%e7%94%a8&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    配合&lt;code&gt;bcc profile&lt;/code&gt;使用
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;FlameGraph&lt;/code&gt;项目提供了&lt;a class=&#34;link&#34; href=&#34;https://github.com/brendangregg/FlameGraph/blob/master/jmaps&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;jmaps&lt;/a&gt;脚本，它会调用&lt;code&gt;perf-map-agent&lt;/code&gt;为当前运行的所有Java进程生成符号表。&lt;/p&gt;
&lt;p&gt;首先为&lt;code&gt;jmaps&lt;/code&gt;脚本设置好&lt;code&gt;JAVA_HOME&lt;/code&gt;和&lt;code&gt;perf-map-agent&lt;/code&gt;的正确位置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;JAVA_HOME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=$&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JAVA_HOME&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;usr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;oracle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;AGENT_HOME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=$&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AGENT_HOME&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;usr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;perf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;agent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# from https://github.com/jvm-profiling-tools/perf-map-agent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行&lt;code&gt;jmaps&lt;/code&gt;，可以看到它会为当前所有的Java进程生成符号表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ./jmaps
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Fetching maps for all java processes...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Mapping PID 30711 (user adp):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wc(1):   3486  10896 214413 /tmp/perf-30711.map
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们在做任何&lt;code&gt;profiling&lt;/code&gt;之前，都需要调用&lt;code&gt;jmaps&lt;/code&gt;，保持符号表是最新的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU Profiling火焰图&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Profiling&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;./&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jmaps&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;usr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;share&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bcc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tools&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;profile&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dF&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;99&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;afp&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;profile01&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;txt&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 生成火焰图&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;./&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flamegraph&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;java&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;profile01&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;txt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flamegraph&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;svg&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;off-CPU火焰图&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Profiling&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;./&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jmaps&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;usr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;share&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bcc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tools&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offcputime&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fp&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offcpu01&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;txt&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 生成火焰图&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;./&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flamegraph&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;java&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bgcolor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;blue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;countname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;us&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1024&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Off-CPU Time Flame Graph&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offcpu01&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;txt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offcpu01&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;svg&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;off-CPU，并过滤指定的进程状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux的进程状态有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TASK_RUNNING&lt;/td&gt;
&lt;td&gt;意味着进程处于可运行状态。这并不意味着已经实际分配了CPU。进程可能会一直等到调度器选中它。该状态确保进程可以立即运行，而无需等待外部事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TASK_INTERRUPTIBLE&lt;/td&gt;
&lt;td&gt;可中断的等待状态，主要为恢复时间无法预测的长时间等待。例如等待来自用户的输入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TASK_UNINTERRUPTIBLE&lt;/td&gt;
&lt;td&gt;不可中断的等待状态。用于因内核指示而停用的睡眠进程。它们不能由外部信号唤醒，只能由内核亲自唤醒。例如磁盘输入输出等待。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TASK_STOPPED&lt;/td&gt;
&lt;td&gt;响应暂停信号而运行中断的状态。直到恢复前都不会被调度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TASK_ZOMBIE&lt;/td&gt;
&lt;td&gt;僵尸状态，子进程已经终止，但父进程尚未执行wait()，因此该进程的资源没有被系统释放。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在状态&lt;code&gt;TASK_RUNNING&lt;/code&gt;（0）会发生非自愿上下文切换，而我们通常感兴趣的阻塞事件是&lt;code&gt;TASK_INTERRUPTIBLE&lt;/code&gt;（1）或&lt;code&gt;TASK_UNINTERRUPTIBLE&lt;/code&gt;（2），&lt;code&gt;offcputime&lt;/code&gt;可以用&lt;code&gt;--state&lt;/code&gt;过滤指定的进程状态：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Profiling&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;./&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jmaps&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;usr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;share&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bcc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tools&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offcputime&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offcpu01&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;txt&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 生成火焰图&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;./&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flamegraph&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;io&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;countname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offcpu01&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;txt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offcpu01&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;svg&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;async-profiler&#34;&gt;
    &lt;a href=&#34;#async-profiler&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    async-profiler
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jvm-profiling-tools/async-profiler&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;async-profiler&lt;/a&gt;将&lt;code&gt;perf&lt;/code&gt;的堆栈追踪和JDK提供的&lt;a class=&#34;link&#34; href=&#34;http://psy-lob-saw.blogspot.com/2016/06/the-pros-and-cons-of-agct.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AsyncGetCallTrace&lt;/a&gt;结合了起来，做到同时采样Java栈与Native栈，因此也就可以同时分析Java代码和Native代码中存在的性能热点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AsyncGetCallTrace&lt;/code&gt;是JDK内部提供的一个函数，它的原型如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;jint&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lineno&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BCI&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;the&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;jmethodID&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;executed&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;this&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frame&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ASGCT_CallFrame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;JNIEnv&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env_id&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Env&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;where&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;trace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;was&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;recorded&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;jint&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_frames&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;number&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frames&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;this&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;trace&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;ASGCT_CallFrame&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frames&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ASGCT_CallTrace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AsyncGetCallTrace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ASGCT_CallTrace&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;trace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pre&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;allocated&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;trace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fill&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                       &lt;span class=&#34;n&#34;&gt;jint&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;depth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;             &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;number&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frames&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;walk&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;the&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                       &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ucontext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;signal&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看出，该函数直接通过&lt;code&gt;ucontext&lt;/code&gt;就能获取到完整的Java调用栈。&lt;/p&gt;
&lt;h4 id=&#34;async-profiler的使用&#34;&gt;
    &lt;a href=&#34;#async-profiler%e7%9a%84%e4%bd%bf%e7%94%a8&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    async-profiler的使用
&lt;/h4&gt;&lt;p&gt;下载并解压好&lt;code&gt;async-profiler&lt;/code&gt;安装包。&lt;/p&gt;
&lt;p&gt;从Linux 4.6开始，从&lt;code&gt;non-root&lt;/code&gt;进程使用&lt;code&gt;perf&lt;/code&gt;捕获内核的&lt;code&gt;call stacks&lt;/code&gt;，需要设置如下两个内核参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# echo 1 &amp;gt; /proc/sys/kernel/perf_event_paranoid
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# echo 0 &amp;gt; /proc/sys/kernel/kptr_restrict
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;async-profiler&lt;/code&gt;的使用非常简单，一步就能生成火焰图。另外，也不需要为被&lt;code&gt;profiling&lt;/code&gt;的Java进程设置&lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt;参数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./profiler.sh -d 30 -f /tmp/flamegraph.svg [PID]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241119380.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;async-profiler&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;
    &lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    总结
&lt;/h2&gt;&lt;p&gt;为Java生成&lt;code&gt;CPU profiling&lt;/code&gt;火焰图，基本的流程都是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用工具采集样本&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;FlameGraph&lt;/code&gt;项目提供的脚本，将采集的样本归纳合并，统计出&lt;code&gt;Stack Trace&lt;/code&gt;出现的频率&lt;/li&gt;
&lt;li&gt;最后使用&lt;code&gt;flamegraph.pl&lt;/code&gt;利用上一步的输出，绘制SVG火焰图&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了能够生成&lt;code&gt;Java stacks&lt;/code&gt;和&lt;code&gt;native stacks&lt;/code&gt;完整的火焰图，解决&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;bcc profile&lt;/code&gt;不能识别Java符号和Java &lt;code&gt;stack traces&lt;/code&gt;的问题，目前有以下两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;perf-map-agent&lt;/code&gt; 加上 &lt;code&gt;perf&lt;/code&gt;或&lt;code&gt;bcc profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;async-profiler&lt;/code&gt;（内部会使用到&lt;code&gt;perf&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果只是对Java进程做&lt;code&gt;on-CPU&lt;/code&gt;分析，&lt;code&gt;async-profiler&lt;/code&gt;更加方便好用。如果需要更全面的了解Java进程的运行情况，例如分析系统锁的开销，阻塞的 I/O 操作，以及进程调度器（&lt;code&gt;scheduler&lt;/code&gt;）的工作，那么还是需要使用功能更强大的&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;bcc&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;
    &lt;a href=&#34;#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/perf.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;perf Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/ebpf.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux Extended BPF (eBPF) Tracing Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/bpf-performance-tools-book.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BPF Performance Tools (book)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/offcpuanalysis.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Off-CPU Analysis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Flame Graphs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Linux TCP队列相关参数的总结</title>
        <link>https://mazhen.tech/p/linux-tcp%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93/</link>
        <pubDate>Sat, 16 Aug 2014 11:11:24 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/linux-tcp%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93/</guid>
        <description>&lt;p&gt;在Linux上做网络应用的性能优化时，一般都会对TCP相关的内核参数进行调节，特别是和缓冲、队列有关的参数。网上搜到的文章会告诉你需要修改哪些参数，但我们经常是知其然而不知其所以然，每次照抄过来后，可能很快就忘记或混淆了它们的含义。本文尝试总结TCP队列缓冲相关的内核参数，从协议栈的角度梳理它们，希望可以更容易的理解和记忆。注意，本文内容均来源于参考文档，没有去读相关的内核源码做验证，不能保证内容严谨正确。作为Java程序员没读过内核源码是硬伤。&lt;/p&gt;
&lt;p&gt;下面我以server端为视角，从&lt;strong&gt;连接建立&lt;/strong&gt;、&lt;strong&gt;数据包接收&lt;/strong&gt;和&lt;strong&gt;数据包发送&lt;/strong&gt;这3条路径对参数进行归类梳理。&lt;/p&gt;
&lt;h3 id=&#34;一连接建立&#34;&gt;
    &lt;a href=&#34;#%e4%b8%80%e8%bf%9e%e6%8e%a5%e5%bb%ba%e7%ab%8b&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    一、连接建立
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011113863.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;简单看下连接的建立过程，客户端向server发送&lt;code&gt;SYN&lt;/code&gt;包，server回复&lt;code&gt;SYN＋ACK&lt;/code&gt;，同时将这个处于&lt;code&gt;SYN_RECV&lt;/code&gt;状态的连接保存到半连接队列。客户端返回&lt;code&gt;ACK&lt;/code&gt;包完成三次握手，server将&lt;code&gt;ESTABLISHED&lt;/code&gt;状态的连接移入&lt;code&gt;accept&lt;/code&gt;队列，等待应用调用&lt;code&gt;accept()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以看到建立连接涉及两个队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;半连接队列&lt;/strong&gt;，保存&lt;code&gt;SYN_RECV&lt;/code&gt;状态的连接。队列长度由&lt;code&gt;net.ipv4.tcp_max_syn_backlog&lt;/code&gt;设置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;accept队列&lt;/strong&gt;，保存&lt;code&gt;ESTABLISHED&lt;/code&gt;状态的连接。队列长度为&lt;code&gt;min(net.core.somaxconn, backlog)&lt;/code&gt;。其中&lt;code&gt;backlog&lt;/code&gt;是我们创建&lt;code&gt;ServerSocket(int port,int backlog)&lt;/code&gt;时指定的参数，最终会传递给&lt;code&gt;listen&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;backlog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们设置的&lt;code&gt;backlog&lt;/code&gt;大于&lt;code&gt;net.core.somaxconn&lt;/code&gt;，&lt;code&gt;accept&lt;/code&gt;队列的长度将被设置为&lt;code&gt;net.core.somaxconn&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外，为了应对&lt;code&gt;SYN flooding&lt;/code&gt;（即客户端只发送SYN包发起握手而不回应ACK完成连接建立，填满server端的半连接队列，让它无法处理正常的握手请求），Linux实现了一种称为&lt;code&gt;SYN cookie&lt;/code&gt;的机制，通过&lt;code&gt;net.ipv4.tcp_syncookies&lt;/code&gt;控制，设置为1表示开启。简单说&lt;code&gt;SYN cookie&lt;/code&gt;就是将连接信息编码在&lt;code&gt;ISN&lt;/code&gt;(initial sequence number)中返回给客户端，这时server不需要将半连接保存在队列中，而是利用客户端随后发来的ACK带回的&lt;code&gt;ISN&lt;/code&gt;还原连接信息，以完成连接的建立，避免了半连接队列被攻击&lt;code&gt;SYN&lt;/code&gt;包填满。对于一去不复返的客户端握手，不理它就是了。&lt;/p&gt;
&lt;h3 id=&#34;二数据包的接收&#34;&gt;
    &lt;a href=&#34;#%e4%ba%8c%e6%95%b0%e6%8d%ae%e5%8c%85%e7%9a%84%e6%8e%a5%e6%94%b6&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    二、数据包的接收
&lt;/h3&gt;&lt;p&gt;先看看接收数据包经过的路径：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011113357.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;数据包的接收，从下往上经过了三层：网卡驱动、系统内核空间，最后到用户态空间的应用。Linux内核使用&lt;code&gt;sk_buff&lt;/code&gt;(&lt;a class=&#34;link&#34; href=&#34;http://vger.kernel.org/~davem/skb.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;socket kernel buffers&lt;/a&gt;)数据结构描述一个数据包。当一个新的数据包到达，&lt;code&gt;NIC&lt;/code&gt;（network interface controller）调用&lt;code&gt;DMA engine&lt;/code&gt;，通过&lt;code&gt;Ring Buffer&lt;/code&gt;将数据包放置到内核内存区。&lt;code&gt;Ring Buffer&lt;/code&gt;的大小固定，它不包含实际的数据包，而是包含了指向&lt;code&gt;sk_buff&lt;/code&gt;的描述符。当&lt;code&gt;Ring Buffer&lt;/code&gt;满的时候，新来的数据包将给丢弃。一旦数据包被成功接收，&lt;code&gt;NIC&lt;/code&gt;发起中断，由内核的中断处理程序将数据包传递给IP层。经过IP层的处理，数据包被放入队列等待TCP层处理。每个数据包经过TCP层一系列复杂的步骤，更新TCP状态机，最终到达&lt;code&gt;recv Buffer&lt;/code&gt;，等待被应用接收处理。有一点需要注意，数据包到达&lt;code&gt;recv Buffer&lt;/code&gt;，TCP就会回&lt;code&gt;ACK&lt;/code&gt;确认，既TCP的&lt;code&gt;ACK&lt;/code&gt;表示数据包已经被操作系统内核收到，但并不确保应用层一定收到数据（例如这个时候系统crash），因此一般建议应用协议层也要设计自己的&lt;code&gt;ACK&lt;/code&gt;确认机制。&lt;/p&gt;
&lt;p&gt;上面就是一个相当简化的数据包接收流程，让我们逐层看看队列缓冲有关的参数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;网卡Bonding模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当主机有1个以上的网卡时，Linux会将多个网卡绑定为一个虚拟的bonded网络接口，对TCP/IP而言只存在一个bonded网卡。多网卡绑定一方面能够提高网络吞吐量，另一方面也可以增强网络高可用。Linux支持7种Bonding模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- `Mode 0 (balance-rr)` Round-robin策略，这个模式具备负载均衡和容错能力
- `Mode 1 (active-backup)` 主备策略，在绑定中只有一个网卡被激活，其他处于备份状态
- `Mode 2 (balance-xor)` XOR策略，通过源MAC地址与目的MAC地址做异或操作选择slave网卡
- `Mode 3 (broadcast)` 广播，在所有的网卡上传送所有的报文
- `Mode 4 (802.3ad)`  IEEE 802.3ad 动态链路聚合。创建共享相同的速率和双工模式的聚合组
- `Mode 5 (balance-tlb)` Adaptive transmit load balancing
- `Mode 6 (balance-alb)` Adaptive load balancing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;详细的说明参考内核文档&lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/Documentation/networking/bonding.txt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux Ethernet Bonding Driver HOWTO&lt;/a&gt;。我们可以通过&lt;code&gt;cat /proc/net/bonding/bond0&lt;/code&gt;查看本机的Bonding模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011114466.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;一般很少需要开发去设置网卡Bonding模式，自己实验的话可以参考&lt;a class=&#34;link&#34; href=&#34;http://linux.cloudibee.com/2009/10/linux-network-bonding-setup-guide/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这篇文档&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;网卡多队列及中断绑定&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;随着网络的带宽的不断提升，单核CPU已经不能满足网卡的需求，这时通过多队列网卡驱动的支持，可以将每个队列通过中断绑定到不同的CPU核上，充分利用多核提升数据包的处理能力。&lt;/p&gt;
&lt;p&gt;首先查看网卡是否支持多队列，使用&lt;code&gt;lspci -vvv&lt;/code&gt;命令，找到&lt;code&gt;Ethernet controller&lt;/code&gt;项：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011115916.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果有MSI-X， Enable+ 并且Count &amp;gt; 1，则该网卡是多队列网卡。&lt;/p&gt;
&lt;p&gt;然后查看是否打开了网卡多队列。使用命令&lt;code&gt;cat /proc/interrupts&lt;/code&gt;，如果看到eth0-TxRx-0表明多队列支持已经打开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011115744.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;最后确认每个队列是否绑定到不同的CPU。&lt;code&gt;cat /proc/interrupts&lt;/code&gt;查询到每个队列的中断号，对应的文件&lt;code&gt;/proc/irq/${IRQ_NUM}/smp_affinity&lt;/code&gt;为中断号&lt;code&gt;IRQ_NUM&lt;/code&gt;绑定的CPU核的情况。以十六进制表示，每一位代表一个CPU核：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```
（00000001）代表CPU0
（00000010）代表CPU1
（00000011）代表CPU0和CPU1
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果绑定的不均衡，可以手工设置，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```
echo &amp;quot;1&amp;quot; &amp;gt; /proc/irq/99/smp_affinity  
echo &amp;quot;2&amp;quot; &amp;gt; /proc/irq/100/smp_affinity  
echo &amp;quot;4&amp;quot; &amp;gt; /proc/irq/101/smp_affinity  
echo &amp;quot;8&amp;quot; &amp;gt; /proc/irq/102/smp_affinity  
echo &amp;quot;10&amp;quot; &amp;gt; /proc/irq/103/smp_affinity  
echo &amp;quot;20&amp;quot; &amp;gt; /proc/irq/104/smp_affinity  
echo &amp;quot;40&amp;quot; &amp;gt; /proc/irq/105/smp_affinity  
echo &amp;quot;80&amp;quot; &amp;gt; /proc/irq/106/smp_affinity  
```
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ring Buffer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ring Buffer&lt;/code&gt;位于NIC和IP层之间，是一个典型的FIFO（先进先出）&lt;a class=&#34;link&#34; href=&#34;http://en.wikipedia.org/wiki/Circular_buffer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;环形队列&lt;/a&gt;。&lt;code&gt;Ring Buffer&lt;/code&gt;没有包含数据本身，而是包含了指向&lt;code&gt;sk_buff&lt;/code&gt;（&lt;a class=&#34;link&#34; href=&#34;http://vger.kernel.org/~davem/skb.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;socket kernel buffers&lt;/a&gt;）的描述符。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以使用&lt;code&gt;ethtool -g eth0&lt;/code&gt;查看当前&lt;code&gt;Ring Buffer&lt;/code&gt;的设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011116458.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上面的例子接收队列为4096，传输队列为256。可以通过&lt;code&gt;ifconfig&lt;/code&gt;观察接收和传输队列的运行状况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011116204.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RX errors&lt;/strong&gt;：收包总的错误数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RX dropped&lt;/strong&gt;: 表示数据包已经进入了&lt;code&gt;Ring Buffer&lt;/code&gt;，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RX overruns&lt;/strong&gt;: &lt;code&gt;overruns&lt;/code&gt;意味着数据包没到&lt;code&gt;Ring Buffer&lt;/code&gt;就被网卡物理层给丢弃了，而CPU无法及时的处理中断是造成&lt;code&gt;Ring Buffer&lt;/code&gt;满的原因之一，例如中断分配的不均匀。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;dropped&lt;/code&gt;数量持续增加，建议增大&lt;code&gt;Ring Buffer&lt;/code&gt;，使用&lt;code&gt;ethtool -G&lt;/code&gt;进行设置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;Input Packet Queue(数据包接收队列)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当接收数据包的速率大于内核TCP处理包的速率，数据包将会缓冲在TCP层之前的队列中。接收队列的长度由参数&lt;code&gt;net.core.netdev_max_backlog&lt;/code&gt;设置。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;recv Buffer&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;recv buffer&lt;/code&gt;是调节TCP性能的关键参数。&lt;code&gt;BDP&lt;/code&gt;(Bandwidth-delay product，带宽延迟积) 是网络的带宽和与&lt;code&gt;RTT&lt;/code&gt;(round trip time)的乘积，&lt;code&gt;BDP&lt;/code&gt;的含义是任意时刻处于在途未确认的最大数据量。&lt;code&gt;RTT&lt;/code&gt;使用&lt;code&gt;ping&lt;/code&gt;命令可以很容易的得到。为了达到最大的吞吐量，&lt;code&gt;recv Buffer&lt;/code&gt;的设置应该大于&lt;code&gt;BDP&lt;/code&gt;，即&lt;code&gt;recv Buffer &amp;gt;= bandwidth * RTT&lt;/code&gt;。假设带宽是100Mbps，&lt;code&gt;RTT&lt;/code&gt;是100ms，那么&lt;code&gt;BDP&lt;/code&gt;的计算如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;BDP = 100Mbps * 100ms = (100 / 8) * (100 / 1000) = 1.25MB
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Linux在2.6.17以后增加了&lt;code&gt;recv Buffer&lt;/code&gt;自动调节机制，&lt;code&gt;recv buffer&lt;/code&gt;的实际大小会自动在最小值和最大值之间浮动，以期找到性能和资源的平衡点，因此大多数情况下不建议将&lt;code&gt;recv buffer&lt;/code&gt;手工设置成固定值。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;net.ipv4.tcp_moderate_rcvbuf&lt;/code&gt;设置为1时，自动调节机制生效，每个TCP连接的recv Buffer由下面的3元数组指定：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;net.ipv4.tcp_rmem = &amp;lt;MIN&amp;gt; &amp;lt;DEFAULT&amp;gt; &amp;lt;MAX&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最初&lt;code&gt;recv buffer&lt;/code&gt;被设置为&lt;DEFAULT&gt;，同时这个缺省值会覆盖&lt;code&gt;net.core.rmem_default&lt;/code&gt;的设置。随后&lt;code&gt;recv buffer&lt;/code&gt;根据实际情况在最大值和最小值之间动态调节。在缓冲的动态调优机制开启的情况下，我们将&lt;code&gt;net.ipv4.tcp_rmem&lt;/code&gt;的最大值设置为&lt;code&gt;BDP&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;net.ipv4.tcp_moderate_rcvbuf&lt;/code&gt;被设置为0，或者设置了socket选项&lt;code&gt;SO_RCVBUF&lt;/code&gt;，缓冲的动态调节机制被关闭。&lt;code&gt;recv buffer&lt;/code&gt;的缺省值由&lt;code&gt;net.core.rmem_default&lt;/code&gt;设置，但如果设置了&lt;code&gt;net.ipv4.tcp_rmem&lt;/code&gt;，缺省值则被&lt;code&gt;&amp;lt;DEFAULT&amp;gt;&lt;/code&gt;覆盖。可以通过系统调用&lt;code&gt;setsockopt()&lt;/code&gt;设置&lt;code&gt;recv buffer&lt;/code&gt;的最大值为&lt;code&gt;net.core.rmem_max&lt;/code&gt;。在缓冲动态调节机制关闭的情况下，建议把缓冲的缺省值设置为&lt;code&gt;BDP&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意这里还有一个细节，缓冲除了保存接收的数据本身，还需要一部分空间保存socket数据结构等额外信息。因此上面讨论的&lt;code&gt;recv buffer&lt;/code&gt;最佳值仅仅等于&lt;code&gt;BDP&lt;/code&gt;是不够的，还需要考虑保存socket等额外信息的开销。Linux根据参数&lt;code&gt;net.ipv4.tcp_adv_win_scale&lt;/code&gt;计算额外开销的大小：&lt;/p&gt;
&lt;p&gt;Buffer / 2&lt;sup&gt;tcp_adv_win_scale&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;net.ipv4.tcp_adv_win_scale&lt;/code&gt;的值为1，则二分之一的缓冲空间用来做额外开销，如果为2的话，则四分之一缓冲空间用来做额外开销。因此&lt;code&gt;recv buffer&lt;/code&gt;的最佳值应该设置为：&lt;/p&gt;
&lt;p&gt;BDP / (1 – 1 / 2&lt;sup&gt;tcp_adv_win_scale&lt;/sup&gt;)&lt;/p&gt;
&lt;h3 id=&#34;三数据包的发送&#34;&gt;
    &lt;a href=&#34;#%e4%b8%89%e6%95%b0%e6%8d%ae%e5%8c%85%e7%9a%84%e5%8f%91%e9%80%81&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    三、数据包的发送
&lt;/h3&gt;&lt;p&gt;发送数据包经过的路径：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011117967.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;和接收数据的路径相反，数据包的发送从上往下也经过了三层：用户态空间的应用、系统内核空间、最后到网卡驱动。应用先将数据写入TCP &lt;code&gt;send buffer&lt;/code&gt;，TCP层将&lt;code&gt;send buffer&lt;/code&gt;中的数据构建成数据包转交给IP层。IP层会将待发送的数据包放入队列&lt;code&gt;QDisc&lt;/code&gt;(queueing discipline)。数据包成功放入&lt;code&gt;QDisc&lt;/code&gt;后，指向数据包的描述符&lt;code&gt;sk_buff&lt;/code&gt;被放入&lt;code&gt;Ring Buffer&lt;/code&gt;输出队列，随后网卡驱动调用&lt;code&gt;DMA engine&lt;/code&gt;将数据发送到网络链路上。&lt;/p&gt;
&lt;p&gt;同样我们逐层来梳理队列缓冲有关的参数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;send Buffer&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同&lt;code&gt;recv Buffer&lt;/code&gt;类似，和&lt;code&gt;send Buffer&lt;/code&gt;有关的参数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;net.ipv4.tcp_wmem = &amp;lt;MIN&amp;gt; &amp;lt;DEFAULT&amp;gt; &amp;lt;MAX&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;net.core.wmem_default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;net.core.wmem_max
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;发送端缓冲的自动调节机制很早就已经实现，并且是无条件开启，没有参数去设置。如果指定了&lt;code&gt;tcp_wmem&lt;/code&gt;，则&lt;code&gt;net.core.wmem_default&lt;/code&gt;被&lt;code&gt;tcp_wmem&lt;/code&gt;的&lt;DEFAULT&gt;覆盖。&lt;code&gt;send Buffer&lt;/code&gt;在&lt;code&gt;tcp_wmem&lt;/code&gt;的最小值和最大值之间自动调节。如果调用&lt;code&gt;setsockopt()&lt;/code&gt;设置了socket选项&lt;code&gt;SO_SNDBUF&lt;/code&gt;，将关闭发送端缓冲的自动调节机制，&lt;code&gt;tcp_wmem&lt;/code&gt;将被忽略，&lt;code&gt;SO_SNDBUF&lt;/code&gt;的最大值由&lt;code&gt;net.core.wmem_max&lt;/code&gt;限制。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;QDisc&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;QDisc&lt;/code&gt;（queueing discipline ）位于IP层和网卡的&lt;code&gt;ring buffer&lt;/code&gt;之间。我们已经知道，&lt;code&gt;ring buffer&lt;/code&gt;是一个简单的FIFO队列，这种设计使网卡的驱动层保持简单和快速。而&lt;code&gt;QDisc&lt;/code&gt;实现了流量管理的高级功能，包括流量分类，优先级和流量整形（rate-shaping）。可以使用&lt;code&gt;tc&lt;/code&gt;命令配置&lt;code&gt;QDisc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QDisc&lt;/code&gt;的队列长度由&lt;code&gt;txqueuelen&lt;/code&gt;设置，和接收数据包的队列长度由内核参数&lt;code&gt;net.core.netdev_max_backlog&lt;/code&gt;控制所不同，&lt;code&gt;txqueuelen&lt;/code&gt;是和网卡关联，可以用&lt;code&gt;ifconfig&lt;/code&gt;命令查看当前的大小：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011117299.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;ifconfig&lt;/code&gt;调整&lt;code&gt;txqueuelen&lt;/code&gt;的大小：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ifconfig eth0 txqueuelen 2000
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;Ring Buffer&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和数据包的接收一样，发送数据包也要经过&lt;code&gt;Ring Buffer&lt;/code&gt;，使用&lt;code&gt;ethtool -g eth0&lt;/code&gt;查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011118456.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;TX&lt;/code&gt;项是&lt;code&gt;Ring Buffer&lt;/code&gt;的传输队列，也就是发送队列的长度。设置也是使用命令&lt;code&gt;ethtool -G&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;TCP Segmentation和Checksum Offloading&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作系统可以把一些TCP/IP的功能转交给网卡去完成，特别是Segmentation(分片)和checksum的计算，这样可以节省CPU资源，并且由硬件代替&lt;code&gt;OS&lt;/code&gt;执行这些操作会带来性能的提升。&lt;/p&gt;
&lt;p&gt;一般以太网的&lt;code&gt;MTU&lt;/code&gt;（Maximum Transmission Unit）为1500 bytes，假设应用要发送数据包的大小为7300bytes，&lt;code&gt;MTU&lt;/code&gt;1500字节 － IP头部20字节 － TCP头部20字节＝有效负载为1460字节，因此7300字节需要拆分成5个segment：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011118576.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Segmentation&lt;/code&gt;(分片)操作可以由操作系统移交给网卡完成，虽然最终线路上仍然是传输5个包，但这样节省了CPU资源并带来性能的提升：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011118473.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;ethtool -k eth0&lt;/code&gt;查看网卡当前的offloading情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011119505.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上面这个例子&lt;code&gt;checksum&lt;/code&gt;和&lt;code&gt;tcp segmentation&lt;/code&gt;的&lt;code&gt;offloading&lt;/code&gt;都是打开的。如果想设置网卡的&lt;code&gt;offloading&lt;/code&gt;开关，可以使用&lt;code&gt;ethtool -K&lt;/code&gt;(注意K是大写)命令，例如下面的命令关闭了tcp segmentation offload：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ethtool&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eth0&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tso&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;off&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;网卡多队列和网卡Bonding模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在数据包的接收过程中已经介绍过了。&lt;/p&gt;
&lt;p&gt;至此，终于梳理完毕。整理TCP队列相关参数的起因是最近在排查一个网络超时问题，原因还没有找到，产生的“副作用”就是这篇文档。再想深入解决这个问题可能需要做TCP协议代码的profile，需要继续学习，希望不久的将来就可以再写文档和大家分享了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文档&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.linuxjournal.com/content/queueing-linux-network-stack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Queueing in the Linux Network Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.ece.virginia.edu/cheetah/documents/papers/TCPlinux.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TCP Implementation in Linux: A Brief Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://sandilands.info/sgordon/impact-of-bandwidth-delay-product-on-tcp-throughput&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Impact of Bandwidth Delay Product on TCP Throughput&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://hellojava.info/?p=292&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java程序员也应该知道的系统知识系列之网卡&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>使用USE Method分析系统性能问题</title>
        <link>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8use-method%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</link>
        <pubDate>Sat, 07 Jun 2014 10:56:00 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8use-method%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</guid>
        <description>&lt;p&gt;遇到性能问题怎么分析定位？这个问题太难回答了，各种底层环境、依赖系统、业务场景，怎么可能有统一的答案。于是产生了各种分析性能问题的“流派”。两个典型的 ANTI-METHODOLOGIES：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;blame-someone-else&lt;/strong&gt;
使用此方法的人遵循下列步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到一个不是他负责的系统或环境&lt;/li&gt;
&lt;li&gt;假定问题和这个组件有关&lt;/li&gt;
&lt;li&gt;将问题转交个负责这个组件的团队&lt;/li&gt;
&lt;li&gt;如果证明是错误的，重复步骤1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路灯法&lt;/strong&gt;
没有系统的方法论，只是使用自己擅长的工具去观察，而不管问题到底出现在哪儿。就像丢了钥匙的人去路灯下寻找，仅仅是因为路灯下比较亮。这种行为被称为&lt;a class=&#34;link&#34; href=&#34;http://en.wikipedia.org/wiki/Streetlight_effect&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;路灯效应&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相信很多同学已经脑补出上述的两个场景，他们的行为模式让人抓狂。于是有聪明人总结出了《&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/usemethod.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The USE Method&lt;/a&gt;》。USE是Utilization，Saturation 和 Errors的缩写，简单说USE是一套分析系统性能问题的方法论，具体表现为一个checklist，分析过程就是对照checklist一项项检查，希望能快速定位瓶颈资源或错误。&lt;/p&gt;
&lt;p&gt;初看这个方法感觉有点太简单了吧，这也能称为方法论？不过这确实体现出了老外的做事风格，任何事情都会去做定量分析，力求逻辑完整。而我们往往讳莫高深的一笑，只可意会不可言传。&lt;/p&gt;
&lt;p&gt;简单介绍下USE，详细内容推荐看这篇《&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/usemethod.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The USE Method&lt;/a&gt;》。USE的一句话总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For every resource, check utilization, saturation, and errors.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;术语解释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;resource&lt;/strong&gt;：CPU，内存，磁盘，网络等一切物理设备资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;utilization&lt;/strong&gt;：资源利用率。例如CPU的资源利用率90%&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;saturation&lt;/strong&gt;：当资源繁忙时仍能接收新的任务，这些额外的任务一般都放入了等待队列。&lt;code&gt;saturation&lt;/code&gt;就表现为队列的长度，例如CPU的平均运行队列为4（Linux上使用vmstat命令获得）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;errors&lt;/strong&gt;：系统的错误报告数，例如&lt;code&gt;TCP&lt;/code&gt;监听队列&lt;code&gt;overflowed&lt;/code&gt;次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;列出系统中的所有资源，然后逐项检查利用率、等待队列和错误数，就这么简单！下表是一个范例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;resource&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;type&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;metric&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CPU&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;utilization&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;CPU utilization (either per-CPU or a system-wide average)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CPU&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;saturation&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;run-queue length&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Memory capacity&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;utilization&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;available free memory (system-wide)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Memory capacity&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;saturation&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;anonymous paging or thread swapping&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Network interface&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;utilization&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RX/TX throughput / max bandwidth Storage&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Storage device I/O&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;utilization&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;device busy percent&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Storage device I/O&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;saturation&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;wait queue length&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Storage device I/O&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;errors&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;device errors (&amp;ldquo;soft&amp;rdquo;, &amp;ldquo;hard&amp;rdquo;, &amp;hellip;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于资源测量数据的解读，作者给了一些建议，例如：资源利用率100%肯定表示该资源是系统瓶颈，70%以上的利用率就要引起足够的重视，一般IO设备利用率高于70%，响应时间将大幅上升。资源等待队列大于0意味着可能存在问题。资源的任何错误计数，都值得仔细调查，特别是当性能变差时，错误计数在上升。&lt;/p&gt;
&lt;p&gt;要使用这个方法，你还需要一份完整的资源列表，一般的系统资源包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPUs: sockets, cores, hardware threads (virtual CPUs)&lt;/li&gt;
&lt;li&gt;Memory: capacity&lt;/li&gt;
&lt;li&gt;Network interfaces&lt;/li&gt;
&lt;li&gt;Storage devices: I/O, capacity&lt;/li&gt;
&lt;li&gt;Controllers: storage, network cards&lt;/li&gt;
&lt;li&gt;Interconnects: CPUs, memory, I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者很厚道的按照每种操作系统给出了checklist，重点关注《&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/USEmethod/use-linux.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;USE Method: Linux Performance Checklist&lt;/a&gt;》，不仅列出了资源，而且告诉你如何进行测量。例如CPU运行队列的测量：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;system-wide: vmstat 1, &amp;ldquo;r&amp;rdquo; &amp;gt; CPU count [2]; sar -q, &amp;ldquo;runq-sz&amp;rdquo; &amp;gt; CPU count; dstat -p, &amp;ldquo;run&amp;rdquo; &amp;gt; CPU count; per-process: /proc/PID/schedstat 2nd field (sched_info.run_delay); perf sched latency (shows &amp;ldquo;Average&amp;rdquo; and &amp;ldquo;Maximum&amp;rdquo; delay per-schedule); dynamic tracing, eg, SystemTap schedtimes.stp &amp;ldquo;queued(us)&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据作者的实践经验，使用USE方法解决了80%的性能问题，只付出了5%的努力，当考虑了所有的资源，你不太可能忽视任何问题。简单有效！&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
