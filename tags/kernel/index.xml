<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>kernel on mazhen.tech</title>
        <link>https://mazhen.tech/tags/kernel/</link>
        <description>Recent content in kernel on mazhen.tech</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-CN</language>
        <lastBuildDate>Fri, 30 Sep 2022 10:23:23 +0800</lastBuildDate><atom:link href="https://mazhen.tech/tags/kernel/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Linux, GNU/Linux以及Alpine Linux</title>
        <link>https://mazhen.tech/p/linux-gnu/linux%E4%BB%A5%E5%8F%8Aalpine-linux/</link>
        <pubDate>Fri, 30 Sep 2022 10:23:23 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/linux-gnu/linux%E4%BB%A5%E5%8F%8Aalpine-linux/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://twitter.com/iximiuz/status/1560977903227383810&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux&lt;/strong&gt; 是内核，由Linus在90年代创造。不包括驱动程序，内核本身在编译时只有几兆字节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GNU&lt;/strong&gt;是一个自由软件的大集合，可以和操作系统一起使用，包括你非常熟悉的 &lt;code&gt;grep&lt;/code&gt;、&lt;code&gt;sed&lt;/code&gt;、&lt;code&gt;gcc&lt;/code&gt;等等。&lt;strong&gt;GNU&lt;/strong&gt; 还包括 &lt;code&gt;glibc&lt;/code&gt;，C 语言标准库的实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GNU/Linux&lt;/strong&gt; 是任何基于 GNU 集合的Linux发行版（内核+用户态应用）。Debian、Ubuntu、CentOS，甚至RHEL在技术上都是 &lt;strong&gt;GNU/Linux&lt;/strong&gt;。因为有共同的C语言标准库和系统工具，通常你可以在 GNU/Linux 发行版之间跳来跳去，不会有什么麻烦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Alpine Linux&lt;/strong&gt; 是另一个类型 Linux 发行版，它不是基于 GNU 集合。&lt;/p&gt;
&lt;p&gt;为了替代 GNU，Alpine 使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BusyBox&lt;/strong&gt;：一个小型软件套件 (~2MB)，在单个可执行文件中提供了多个 Unix 实用程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;musl&lt;/strong&gt;：一种现代且更强大的 C 标准库实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，&lt;strong&gt;Alpine Linux&lt;/strong&gt; 不是 Debian 或 CentOS 等 GNU/Linux 发行版的直接替代品，&lt;code&gt;musl&lt;/code&gt; 的行为可能与 &lt;code&gt;glibc&lt;/code&gt; 不同！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>深入浅出容器技术</title>
        <link>https://mazhen.tech/p/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</link>
        <pubDate>Mon, 22 Aug 2022 16:24:52 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</guid>
        <description>&lt;script type=&#34;text/javascript&#34; src=&#34;https://mazhen.tech/js/pdf-js/build/pdf.js&#34;&gt;&lt;/script&gt;
&lt;style&gt;
  #the-canvas {
    border: 1px solid black;
    direction: ltr;
    width: 100%;
    height: auto;
    display: none;
  }

  #paginator {
    display: none;
    text-align: center;
    margin-bottom: 10px;
  }

  #loadingWrapper {
    display: none;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 350px;
  }

  #loading {
    display: inline-block;
    width: 50px;
    height: 50px;
    border: 3px solid #d2d0d0;
    ;
    border-radius: 50%;
    border-top-color: #383838;
    animation: spin 1s ease-in-out infinite;
    -webkit-animation: spin 1s ease-in-out infinite;
  }

  @keyframes spin {
    to {
      -webkit-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spin {
    to {
      -webkit-transform: rotate(360deg);
    }
  }
&lt;/style&gt;

&lt;div id=&#34;paginator&#34;&gt;
  &lt;button id=&#34;prev&#34;&gt;Previous&lt;/button&gt;
  &lt;button id=&#34;next&#34;&gt;Next&lt;/button&gt;
  &amp;nbsp; &amp;nbsp;
  &lt;span&gt;Page: &lt;span id=&#34;page_num&#34;&gt;&lt;/span&gt; / &lt;span id=&#34;page_count&#34;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div id=&#34;embed-pdf-container&#34;&gt;
  &lt;div id=&#34;loadingWrapper&#34;&gt;
    &lt;div id=&#34;loading&#34;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;canvas id=&#34;the-canvas&#34;&gt;&lt;/canvas&gt;
&lt;/div&gt;

&lt;script type=&#34;text/javascript&#34;&gt;
  window.onload = function () {
    
    
    var url = &#34;https:\/\/mazhen.tech&#34; + &#39;\/pdf\/202209241626966.pdf&#39;;

    var hidePaginator = &#34;&#34; === &#34;true&#34;;
    var hideLoader = &#34;&#34; === &#34;true&#34;;
    var selectedPageNum = parseInt(&#34;&#34;) || 1;

    
    var pdfjsLib = window[&#39;pdfjs-dist/build/pdf&#39;];

    
    pdfjsLib.GlobalWorkerOptions.workerSrc = &#34;https:\/\/mazhen.tech&#34; + &#39;/js/pdf-js/build/pdf.worker.js&#39;;

    
    var pdfDoc = null,
      pageNum = selectedPageNum,
      pageRendering = false,
      pageNumPending = null,
      scale = 3,
      canvas = document.getElementById(&#39;the-canvas&#39;),
      ctx = canvas.getContext(&#39;2d&#39;),
      paginator = document.getElementById(&#34;paginator&#34;),
      loadingWrapper = document.getElementById(&#39;loadingWrapper&#39;);


    
    showPaginator();
    showLoader();

    

    function renderPage(num) {
      pageRendering = true;
      
      pdfDoc.getPage(num).then(function (page) {
        var viewport = page.getViewport({ scale: scale });
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        
        var renderContext = {
          canvasContext: ctx,
          viewport: viewport
        };
        var renderTask = page.render(renderContext);

        
        renderTask.promise.then(function () {
          pageRendering = false;
          showContent();

          if (pageNumPending !== null) {
            
            renderPage(pageNumPending);
            pageNumPending = null;
          }
        });
      });

      
      document.getElementById(&#39;page_num&#39;).textContent = num;
    }

    

    function showContent() {
      loadingWrapper.style.display = &#39;none&#39;;
      canvas.style.display = &#39;block&#39;;
    }

    

    function showLoader() {
      if (hideLoader) return
      loadingWrapper.style.display = &#39;flex&#39;;
      canvas.style.display = &#39;none&#39;;
    }

    

    function showPaginator() {
      if (hidePaginator) return
      paginator.style.display = &#39;block&#39;;
    }

    

    function queueRenderPage(num) {
      if (pageRendering) {
        pageNumPending = num;
      } else {
        renderPage(num);
      }
    }

    

    function onPrevPage() {
      if (pageNum &lt;= 1) {
        return;
      }
      pageNum--;
      queueRenderPage(pageNum);
    }
    document.getElementById(&#39;prev&#39;).addEventListener(&#39;click&#39;, onPrevPage);

    

    function onNextPage() {
      if (pageNum &gt;= pdfDoc.numPages) {
        return;
      }
      pageNum++;
      queueRenderPage(pageNum);
    }
    document.getElementById(&#39;next&#39;).addEventListener(&#39;click&#39;, onNextPage);

    

    pdfjsLib.getDocument(url).promise.then(function (pdfDoc_) {
      pdfDoc = pdfDoc_;
      var numPages = pdfDoc.numPages;
      document.getElementById(&#39;page_count&#39;).textContent = numPages;

      
      if (pageNum &gt; numPages) {
        pageNum = numPages
      }

      
      renderPage(pageNum);
    });
  }

&lt;/script&gt;
</description>
        </item>
        <item>
        <title>GCC 为龙芯 CPU的预定义宏</title>
        <link>https://mazhen.tech/p/gcc-%E4%B8%BA%E9%BE%99%E8%8A%AF-cpu%E7%9A%84%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F/</link>
        <pubDate>Fri, 17 Jun 2022 16:19:54 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/gcc-%E4%B8%BA%E9%BE%99%E8%8A%AF-cpu%E7%9A%84%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F/</guid>
        <description>&lt;p&gt;GCC 会为不同 CPU 架构预定义宏，如 &lt;code&gt;__x86_64__&lt;/code&gt; 代表Intel 64位CPU， &lt;code&gt;__aarch64__&lt;/code&gt;代表  ARM64。 网上已经有文档对 GCC 为 CPU 的预定义宏进行了&lt;a class=&#34;link&#34; href=&#34;https://sourceforge.net/p/predef/wiki/Architectures/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;总结&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这些预定义的宏有什么用呢？我们在代码中可以判断出当前的 CPU 架构，那么可以针对 不同CPU的特性，进行优化实现。例如&lt;code&gt;RocksDB&lt;/code&gt; 对于获取当前时间，在 x86 平台上，会用到 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Time_Stamp_Counter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Time Stamp Counter (TSC)&lt;/a&gt; 寄存器，使用 &lt;code&gt;RDTSC&lt;/code&gt; 指令提取 TSC 中值。对于 ARM 64 也有类似的实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Get the value of tokutime for right now.  We want this to be fast, so we
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// expose the implementation as RDTSC.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;inline&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tokutime_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;toku_time_now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if defined(__x86_64__) || defined(__i386__)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;__asm__&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__volatile__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;rdtsc&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;=a&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;=d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#elif defined(__aarch64__)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kr&#34;&gt;__asm&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__volatile__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mrs %[rt], cntvct_el0&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rt&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;=r&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#elif defined(__powerpc__)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__ppc_get_timebase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#elif defined(__s390x__)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;asm&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;volatile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;stckf %0&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;=Q&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;cc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#else
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#error No timer implementation for this platform
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;而在将 &lt;code&gt;RocksDB&lt;/code&gt; 移植到龙芯的过程中，需要修改上面的代码，判断出当前是龙芯 &lt;code&gt;loongarch64&lt;/code&gt; 架构。&lt;/p&gt;
&lt;p&gt;网上没有搜到 GCC 对龙芯 CPU 的预定宏的文档说明，只能从&lt;a class=&#34;link&#34; href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/loongarch/loongarch-c.cc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;源码&lt;/a&gt;中找答案：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;loongarch_cpu_cpp_builtins&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cpp_reader&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pfile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;builtin_define&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;__loongarch__&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看到，&lt;code&gt;__loongarch__&lt;/code&gt;代表龙芯CPU。 在暂时不知道龙芯是否支持&lt;code&gt;RDTSC&lt;/code&gt;的情况下，只能给出通用的实现，以后再查龙芯的CPU手册进行优化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#if defined(__x86_64__) || defined(__i386__)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#elif defined(__aarch64__)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#elif defined(__powerpc__)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#elif defined(__loongarch__)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;timeval&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;gettimeofday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tv_sec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1000000&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tv_usec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#else
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;cp&#34;&gt;#error No implementation for this platform
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>Linux 信号(Signal)</title>
        <link>https://mazhen.tech/p/linux-%E4%BF%A1%E5%8F%B7signal/</link>
        <pubDate>Wed, 13 Apr 2022 16:17:35 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/linux-%E4%BF%A1%E5%8F%B7signal/</guid>
        <description>&lt;p&gt;我们经常会使用 &lt;code&gt;kill&lt;/code&gt; 命令杀掉运行中的进程，对多次杀不死的进程进一步用 &lt;code&gt;kill -9&lt;/code&gt; 干掉它。你可能知道这是在用 &lt;code&gt;kill&lt;/code&gt; 命令向进程发送信号，优雅或粗暴的让进程退出。我们能向进程发送很多类型的信号，其中一些常见的信号 &lt;strong&gt;SIGINT&lt;/strong&gt; 、&lt;strong&gt;SIGQUIT&lt;/strong&gt;、 &lt;strong&gt;SIGTERM&lt;/strong&gt; 和 &lt;strong&gt;SIGKILL&lt;/strong&gt; 都是通知进程退出，但它们有什么区别呢？很多人经常把它们搞混，这篇文章会让你了解 Linux 的信号机制，以及一些常见信号的作用。&lt;/p&gt;
&lt;h2 id=&#34;什么是信号&#34;&gt;什么是信号&lt;/h2&gt;
&lt;p&gt;信号（Signal）是 Linux 进程收到的一个通知。当进程收到一个信号时，该进程会中断其执行，并执行收到信号对应的处理程序。&lt;/p&gt;
&lt;p&gt;信号机制作为 Linux 进程间通信的一种方法。Linux 进程间通信常用的方法还有管道、消息、共享内存等。&lt;/p&gt;
&lt;p&gt;信号的产生有多种来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件来源，例如 CPU 内存访问出错，当前进程会收到信号 SIGSEGV；按下 &lt;code&gt;Ctrl+C&lt;/code&gt; 键，当前运行的进程会收到信号 SIGINT 而退出；&lt;/li&gt;
&lt;li&gt;软件来源，例如用户通过命令 &lt;code&gt;kill [pid]&lt;/code&gt;，直接向一个进程发送信号。进程使用系统调用 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/kill.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;int kill(pid_t pid, int sig)&lt;/a&gt; 显示的向另一个进程发送信号。内核在某些情况下，也会给进程发送信号，例如当子进程退出时，内核给父进程发送 SIGCHLD 信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以使用 &lt;code&gt;kill -l&lt;/code&gt; 命令查看系统实现了哪些信号：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kill -l
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;63) SIGRTMAX-1	64) SIGRTMAX
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用 &lt;code&gt;man 7 signal&lt;/code&gt; 命令查看系统对每个信号作用的描述：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Signal      Standard   Action   Comment       
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;────────────────────────────────────────────────────────────────────────
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SIGABRT      P1990      Core    Abort signal from abort(3)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SIGALRM      P1990      Term    Timer signal from alarm(2)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SIGBUS       P2001      Core    Bus error (bad memory access)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SIGCHLD      P1990      Ign     Child stopped or terminated
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SIGCLD         -        Ign     A synonym for SIGCHLD
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SIGCONT      P1990      Cont    Continue if stopped
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SIGEMT         -        Term    Emulator trap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SIGFPE       P1990      Core    Floating-point exception
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SIGHUP       P1990      Term    Hangup detected on controlling terminal
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                or death of controlling process
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SIGILL       P1990      Core    Illegal Instruction
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;信号和中断&#34;&gt;信号和中断&lt;/h2&gt;
&lt;p&gt;信号处理是一种典型的&lt;strong&gt;异步事件处理方式&lt;/strong&gt;：进程需要提前向内核注册信号处理函数，当某个信号到来时，内核会就执行相应的信号处理函数。&lt;/p&gt;
&lt;p&gt;我们知道，硬件中断也是一种内核的&lt;strong&gt;异步事件处理方式&lt;/strong&gt;。当外部设备出现一个必须由 CPU 处理的事件，如键盘敲击、数据到达网卡等，内核会收到中断通知，暂时打断当前程序的执行，跳转到该中断类型对应的中断处理程序。中断处理程序是由 BIOS 和操作系统在系统启动过程中预先注册在内核中的。&lt;/p&gt;
&lt;p&gt;中断和信号通知都是在内核产生。中断是完全在内核里完成处理，而&lt;strong&gt;信号的处理则是在用户态完成的&lt;/strong&gt;。也就是说，内核只是将信号保存在进程相关的数据结构里面，在执行信号处理程序之前，需要从内核态切换到用户态，执行完信号处理程序之后，又回到内核态，再恢复进程正常的运行。&lt;/p&gt;
&lt;p&gt;可以看出，中断和信号的严重程度不一样。信号影响的是一个进程，信号处理出了问题，最多是这个进程被干掉。而中断影响的是整个系统，一旦中断处理程序出了问题，可能整个系统都会挂掉。&lt;/p&gt;
&lt;h2 id=&#34;信号处理&#34;&gt;信号处理&lt;/h2&gt;
&lt;p&gt;一旦有信号产生，进程对它的处理都有下面三个选择。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;执行缺省操作（Default）&lt;/strong&gt;。Linux 为每个信号都定义了一个缺省的行为。例如，信号 SIGKILL 的缺省操作是 Term，也就是终止进程的意思。信号 SIGQUIT 的缺省操作是 Core，即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;捕捉信号（Catch）&lt;/strong&gt;。这个是指让用户进程可以注册自己针对这个信号的处理函数。当信号发生时，就执行我们注册的信号处理函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;忽略信号（Ignore）&lt;/strong&gt;。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有两个信号例外，对于 &lt;strong&gt;SIGKILL&lt;/strong&gt; 和 &lt;strong&gt;SIGSTOP&lt;/strong&gt; 这个两个信号，进程是无法捕捉和忽略，它们用于在任何时候中断或结束某一进程。&lt;strong&gt;SIGKILL&lt;/strong&gt; 和 &lt;strong&gt;SIGSTOP&lt;/strong&gt; 为内核和超级用户提供了删除任意进程的特权。&lt;/p&gt;
&lt;p&gt;如果我们不想让信号执行缺省操作，可以对特定的信号注册信号处理函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sighandler_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sighandler_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;signum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sighandler_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;例如下面的例子，程序捕获了信号 SIGINT ，并且只是输出不做其他处理，这样在键盘上按 &lt;code&gt;Ctrl+C&lt;/code&gt; 并不能让程序退出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sig_handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;signo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SIGINT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;received SIGINT&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SIGINT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sig_handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Process is sleeping&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过 &lt;code&gt;signal&lt;/code&gt; 注册的信号处理函数，会保存在进程内核的数据结构 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/linux-5.17.y/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct&lt;/a&gt; 中。由于信号都发给进程，并由进程在用户态处理，所以发送给进程的信号也保存在 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/linux-5.17.y/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct&lt;/a&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241618125.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;signal&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/linux-5.17.y/source/include/linux/sched.h#L1084&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct-&amp;gt;sighand&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/linux-5.17.y/source/include/linux/sched.h#L1083&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct-&amp;gt;signal&lt;/a&gt; 是线程组内共享，而 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/linux-5.17.y/source/include/linux/sched.h#L1089&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct-&amp;gt;pending&lt;/a&gt; 是线程私有的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stask_struct-&amp;gt;sighand&lt;/code&gt; 里面有一个 &lt;code&gt;action&lt;/code&gt;，这是一个数组，下标是信号，数组内容就是注册的信号处理函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;task_struct-&amp;gt;pending&lt;/code&gt; 内包含了一个链表，保存了本线程所有的待处理信号。&lt;code&gt;task_struct-&amp;gt;signal-&amp;gt;shared_pending&lt;/code&gt; 上也有一个待处理信号链表，这个链表保存的是线程组内共享的信号。&lt;/p&gt;
&lt;h2 id=&#34;常见信号&#34;&gt;常见信号&lt;/h2&gt;
&lt;p&gt;下面的列表列举了一些常见的信号。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Singal&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Action&lt;/th&gt;
&lt;th&gt;comment&lt;/th&gt;
&lt;th&gt;key binding&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGHUP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;Hangup detected on controlling terminal or death of controlling process&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGINT&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;Interrupt from keyboard&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Ctrl-c&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGQUIT&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;Quit from keyboard&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Ctrl-\&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGKILL&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;Kill signal&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGSEGV&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;Invalid memory reference&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGPIPE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;Broken pipe: write to pipe with no readers&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGTERM&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;Termination signal&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGCHLD&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;Ign&lt;/td&gt;
&lt;td&gt;Child stopped or terminated&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGCONT&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;Cont&lt;/td&gt;
&lt;td&gt;Continue if stopped&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGSTOP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;Stop&lt;/td&gt;
&lt;td&gt;Stop process&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGTSTP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;Stop&lt;/td&gt;
&lt;td&gt;Stop typed at terminal&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Ctrl-z&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGTTIN&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;Stop&lt;/td&gt;
&lt;td&gt;Terminal input for background process&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SIGTTOU&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;Stop&lt;/td&gt;
&lt;td&gt;Terminal output for background process&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;第一列是信号名称，第二列是信号编号。使用 &lt;code&gt;kill&lt;/code&gt; 向进程发送信号时，用信号名称和编号都可以，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kill -1 [pid]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kill -SIGHUP [pid]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Action 列是信号的缺省行为，主要有如下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Term&lt;/strong&gt; 终止进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Core&lt;/strong&gt; 终止进程并core dump&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ign&lt;/strong&gt; 忽略信号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stop&lt;/strong&gt; 停止进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cont&lt;/strong&gt; 如果进程是已停止，则恢复进程执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一些信号在 TTY 终端做了键盘按键绑定，例如 &lt;code&gt;CTRL+c&lt;/code&gt;  会向终端上运行的前台进程发送  SIGINT 信号。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;sighup&#34;&gt;SIGHUP&lt;/h3&gt;
&lt;p&gt;运行在终端中，由 bash 启动的进程，都是 bash 的子进程。终端退出结束时会向 bash 的每一个子进程发送 &lt;strong&gt;SIGHUP&lt;/strong&gt; 信号。由于 &lt;strong&gt;SIGHUP&lt;/strong&gt; 的缺省行为是 Term，因此，即使运行在后台的进程也会和终端一起结束。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;nohup&lt;/code&gt; 命令可解决这个问题，它的作用是让进程忽略 SIGHUP 信号：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ nohup command &amp;gt;cmd.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样，即使我们退出了终端，运行在后台的程序会忽视 &lt;strong&gt;SIGHUP&lt;/strong&gt; 信号而继续运行。由于作为父进程的 bash 进程已经结束，因此 &lt;code&gt;/sbin/init&lt;/code&gt; 就成为孤儿进程新的父进程。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;sigint-sigquit-sigterm-和-sigkill&#34;&gt;SIGINT, SIGQUIT, SIGTERM 和 SIGKILL&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;SIGTERM&lt;/strong&gt; 和 &lt;strong&gt;SIGKILL&lt;/strong&gt; 是通用的终止进程请求，&lt;strong&gt;SIGINT&lt;/strong&gt; 和 &lt;strong&gt;SIGQUIT&lt;/strong&gt; 是专门用于来自终端的终止进程请求。他们的关键不同点是：&lt;strong&gt;SIGINT&lt;/strong&gt; 和 &lt;strong&gt;SIGQUIT&lt;/strong&gt; 可以是用户在终端使用快捷键生成的，而 &lt;strong&gt;SIGTERM&lt;/strong&gt; 和 &lt;strong&gt;SIGKILL&lt;/strong&gt; 必须由另一个程序以某种方式生成（例如通过 kill 命令）。&lt;/p&gt;
&lt;p&gt;当用户按下 &lt;strong&gt;ctrl-c&lt;/strong&gt; 时，终端将发送 &lt;strong&gt;SIGINT&lt;/strong&gt; 到前台进程。 SIGINT 的缺省行为是终止进程（Term），但它可以被捕获或忽略。 信号 SIGINT 的目的是为进程提供一种有序、优雅的关闭机制。&lt;/p&gt;
&lt;p&gt;当用户按下 &lt;strong&gt;ctrl-\&lt;/strong&gt; 时，终端将发送 &lt;strong&gt;SIGQUIT&lt;/strong&gt; 到前台进程。 SIGQUIT 的缺省行为是终止进程并 core dump，它同样可以被捕获或忽略。 你可以认为 &lt;strong&gt;SIGINT&lt;/strong&gt; 是用户发起的&lt;em&gt;愉快的终止&lt;/em&gt;，而 &lt;strong&gt;SIGQUIT&lt;/strong&gt; 是用户发起的&lt;em&gt;不愉快终止&lt;/em&gt;，需要生成 Core Dump ，方便用户事后进行分析问题在哪里。&lt;/p&gt;
&lt;p&gt;在 ubuntu 上由 &lt;a class=&#34;link&#34; href=&#34;http://manpages.ubuntu.com/manpages/focal/man8/systemd-coredump.8.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;systemd-coredump&lt;/a&gt; 系统服务处理 core dump。我们可以使用 &lt;a class=&#34;link&#34; href=&#34;http://manpages.ubuntu.com/manpages/focal/man1/coredumpctl.1.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;coredumpctl&lt;/a&gt; 命令行工具查询和处理 core dump 文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ coredumpctl list
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;TIME                         PID  UID  GID SIG     COREFILE EXE           SIZE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tue 2022-04-12 22:09:52 CST 6754 1000 1000 SIGQUIT present  /usr/bin/cat 17.1K
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;core dump 文件缺省保存在 &lt;code&gt;/var/lib/systemd/coredump&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SIGTERM&lt;/strong&gt; 默认行为是终止进程，但它也可以被捕获或忽略。&lt;strong&gt;SIGTERM&lt;/strong&gt; 的目的是杀死进程，它允许进程有机会在终止前进行清理，优雅的退出。当我们使用 &lt;code&gt;kill&lt;/code&gt; 命令时，SIGTERM 是默认信号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SIGKILL&lt;/strong&gt;  唯一的行为是立即终止进程。 由于 &lt;strong&gt;SIGKILL&lt;/strong&gt; 是特权信号，进程无法捕获和忽略，因此进程在收到该信号后无法进行清理，立刻退出。&lt;/p&gt;
&lt;p&gt;例如 docker 在停止容器的时候，先给容器里的1号进程发送 &lt;strong&gt;SIGTERM&lt;/strong&gt;，如果不起作用，那么等待30秒后会会发送 &lt;strong&gt;SIGKILL&lt;/strong&gt;，保证容器最终会被停止。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;sigstop--sigtstp-和-sigcont&#34;&gt;SIGSTOP 、 SIGTSTP 和 SIGCONT&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;SIGSTOP&lt;/strong&gt; 和 &lt;strong&gt;SIGTSTP&lt;/strong&gt; 这两个信号都是为了暂停一个进程，但 &lt;strong&gt;SIGSTOP&lt;/strong&gt;  是特权信息，不能被捕获或忽略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SIGSTOP&lt;/strong&gt; 必须由另一个程序以某种方式生成（例如：kill -SIGSTOP pid），而&lt;strong&gt;SIGTSTP&lt;/strong&gt; 也可以由用户在键盘上键入快捷键 &lt;code&gt;Ctrl-z&lt;/code&gt; 生成。&lt;/p&gt;
&lt;p&gt;被暂停的进程通过信号 &lt;strong&gt;SIGCONT&lt;/strong&gt; 恢复。当用户调用 &lt;strong&gt;fg&lt;/strong&gt; 命令时，&lt;strong&gt;SIGCONT&lt;/strong&gt; 由 shell 显式发送给被暂停的进程。&lt;/p&gt;
&lt;p&gt;Linux 使用他们进行作业控制，让你能够手动干预和停止正在运行的应用程序，并在未来某个时间恢复程序的执行。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;sigttou-和-sigttin&#34;&gt;SIGTTOU 和 SIGTTIN&lt;/h3&gt;
&lt;p&gt;Linux 系统中可以有多个会话（&lt;strong&gt;session&lt;/strong&gt;），每个会话可以包含多个进程组，每个进程组可以包含多个进程。&lt;/p&gt;
&lt;p&gt;会话是用户登录系统到退出的所有活动，从登录到结束前创建的所有进程都属于这次会话。会话有一个前台进程组，还可以有一个或多个后台进程组。只有前台进程可以从终端接收输入，也只有前台进程才被允许向终端输出。如果一个后台作业中的进程试图进行终端读写操作，终端会向整个作业发送 &lt;strong&gt;SIGTTOU&lt;/strong&gt; 或 &lt;strong&gt;SIGTTIN&lt;/strong&gt; 信号，默认的行为是暂停进程。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jvm-对信号的处理&#34;&gt;JVM 对信号的处理&lt;/h2&gt;
&lt;p&gt;如果你使用 &lt;code&gt;strace&lt;/code&gt; 追踪 Java 应用，发现 Java 程序会抛出大量 &lt;code&gt;SIGSEGV&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ strace -fe &amp;#39;trace=!all&amp;#39; java [app]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[pid 21746] --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7f9cbc061680} ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[pid 21872] --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7f9cbc061480} ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[pid 21943] --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7f9cbc061500} ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[pid 21844] --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7f9cbc061780} ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[pid 21728] --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7f9cbc061c00} ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[pid 21906] --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7f9cbc061980} ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[pid 21738] --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7f9cbc061100} ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[pid 21729] --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7f9cbc061e00} ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;SIGSEGV&lt;/code&gt; 信号的意思是 “分段错误”（segmentation fault），是当系统检测到进程试图访问不属于它的内存地址时，内核向进程发送的信号。&lt;code&gt;SIGSEGV&lt;/code&gt; 对于一般应用来说是很严重的错误，但 Java 进程中的 &lt;code&gt;SIGSEGV&lt;/code&gt; 几乎总是正常和安全的。&lt;/p&gt;
&lt;p&gt;在常规的 C/C++ 程序中，当你期望指针是指向某个结构，但实际指向的是 &lt;code&gt;NULL&lt;/code&gt;，会导致应用程序崩溃。这种崩溃实际上是内核向进程发送了信号 &lt;code&gt;SIGSEGV&lt;/code&gt;。如果应用程序没有为该信号注册信号处理程序，则信号会返回到内核，然后内核会终止应用。实际上 JVM 为 &lt;code&gt;SIGSEGV&lt;/code&gt; 注册了一个信号处理程序，因为 JVM 想使用 &lt;code&gt;SIGSEGV&lt;/code&gt; 和其他一些信号来实现自己的目的。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/signals006.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这篇文档&lt;/a&gt; 描述了 JVM 对信号的特殊处理：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Signal&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;SIGSEGV&lt;/code&gt;, &lt;code&gt;SIGBUS&lt;/code&gt;, &lt;code&gt;SIGFPE&lt;/code&gt;, &lt;code&gt;SIGPIPE&lt;/code&gt;, &lt;code&gt;SIGILL&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;These signals are used in the implementation for implicit null check, and so forth.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;SIGQUIT&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;This signal is used to dump Java stack traces to the standard error stream. (Optional)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;SIGTERM&lt;/code&gt;, &lt;code&gt;SIGINT&lt;/code&gt;, &lt;code&gt;SIGHUP&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;These signals are used to support the shutdown hook mechanism (&lt;code&gt;java.lang.Runtime.addShutdownHook&lt;/code&gt;) when the VM is terminated abnormally. (Optional)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;SIGUSR1&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;This signal is used in the implementation of the &lt;code&gt;java.lang.Thread.interrupt&lt;/code&gt; method. Not used starting with Oracle Solaris 10 reserved on Linux. (Configurable)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;SIGUSR2&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;This signal is used internally. Not used starting with Oracle Solaris 10 operating system. (Configurable)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;SIGABRT&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;The HotSpot VM does not handle this signal. Instead it calls the &lt;code&gt;abort&lt;/code&gt; function after fatal error handling. If an application uses this signal then it should terminate the process to preserve the expected semantics.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;实际上，JVM 是使用 SIGSEGV、SIGBUS、SIGPIPE 等进行代码中的各种 &lt;code&gt;NULL&lt;/code&gt; 检查。&lt;/p&gt;
&lt;p&gt;同样，我们在终端上键入 &lt;strong&gt;ctrl-\&lt;/strong&gt;，也不会让前台运行的 Java 进程终止并 core dump，而是会将 Java 进程的 stack traces 输出到终端的标准错误流。&lt;/p&gt;
&lt;p&gt;那么如何对 Java 进程进行 core dump 呢？需要在 Java 的启动命令里增加 JVM 选项 &lt;code&gt;-Xrs&lt;/code&gt; ，它会让 JVM 不自己处理 SIGQUIT 信号，这样 SIGQUIT 会触发缺省行为 core dump。&lt;/p&gt;
&lt;p&gt;一般 Java 进程的运行时内存占用都比较大，在进行 core dump 时很容易超过缺省大小而被truncated，因此需要修改配置文件 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man5/coredump.conf.5.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;/etc/systemd/coredump.conf&lt;/a&gt;，合理设置 ProcessSizeMax 和 ExternalSizeMax 的大小。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>深入理解 Page Cache</title>
        <link>https://mazhen.tech/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-page-cache/</link>
        <pubDate>Fri, 01 Apr 2022 16:06:54 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-page-cache/</guid>
        <description>&lt;p&gt;长时间运行的Linux服务器，通常 free 的内存越来越少，让人觉得 Linux 特别能“吃”内存，甚至有人专门做了个网站 &lt;a class=&#34;link&#34; href=&#34;http://www.linuxatemyram.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LinuxAteMyRam.com&lt;/a&gt;解释这个现象。实际上 Linux 内核会尽可能的对访问过的文件进行缓存，来弥补磁盘和内存之间巨大的延迟差距。缓存文件内容的内存就是 &lt;strong&gt;Page Cache&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Google 的大神 &lt;a class=&#34;link&#34; href=&#34;https://research.google/people/jeff/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Jeffrey Dean&lt;/a&gt;总结过一个&lt;a class=&#34;link&#34; href=&#34;https://gist.github.com/hellerbarde/2843375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Latency numbers every programmer should know&lt;/a&gt;，其中提到从磁盘读取 1MB 数据的耗时是内存的80倍，即使换成 SSD 也是内存延迟的 4 倍。&lt;/p&gt;
&lt;p&gt;我在本机做了实验，来体会一下 &lt;strong&gt;Page Cache&lt;/strong&gt; 的作用。首先生成一个 1G 大小的文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# dd if=/dev/zero of=/root/dd.out bs=4096 count=262144
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;清空 Page Cache：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# sync &amp;amp;&amp;amp; echo 3 &amp;gt; /proc/sys/vm/drop_caches
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;统计第一次读取文件的耗时：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# time cat /root/dd.out &amp;amp;&amp;gt; /dev/null
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;real	0m2.097s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;user	0m0.010s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sys	    0m0.638s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;再此读取同一个文件，由于系统已经将读取过的文件内容放入了 &lt;strong&gt;Page Cache&lt;/strong&gt; ，这次耗时大大缩短：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# time cat /root/dd.out &amp;amp;&amp;gt; /dev/null
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;real	0m0.186s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;user	0m0.004s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sys	    0m0.182s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Page Cache&lt;/strong&gt; 不仅能加速对文件内容的访问，对共享库建立 &lt;strong&gt;Page Cache&lt;/strong&gt;，可以在多个进程间共享，避免每个进程都单独加载，造成宝贵内存资源的浪费。&lt;/p&gt;
&lt;h2 id=&#34;page-cache-是什么&#34;&gt;&lt;strong&gt;Page Cache&lt;/strong&gt; 是什么&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Page Cache&lt;/strong&gt; 是由内核管理的内存，位于 &lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/filesystems/vfs.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;VFS(Virtual File System)&lt;/a&gt; 层和具体文件系统层（例如ext4，ext3）之间。应用进程使用 &lt;code&gt;read&lt;/code&gt;/&lt;code&gt;write&lt;/code&gt; 等文件操作，通过系统调用进入到 &lt;strong&gt;VFS&lt;/strong&gt; 层，根据 &lt;strong&gt;O_DIRECT&lt;/strong&gt; 标志，可以使用 &lt;strong&gt;Page Cache&lt;/strong&gt; 作为文件内容的缓存，也可以跳过 &lt;strong&gt;Page Cache&lt;/strong&gt; 不使用内核提供的缓存功能。&lt;/p&gt;
&lt;p&gt;另外，应用程序可以使用 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/mmap.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mmap&lt;/a&gt; ，将文件内容映射到进程的虚拟地址空间，可以像读写内存一样直接读写硬盘上的文件。进程的虚拟内存直接和 &lt;strong&gt;Page Cache&lt;/strong&gt; 映射。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241608564.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;page cache&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;为了了解内核是怎么管理 Page Cache 的，我们先看一下 &lt;strong&gt;VFS&lt;/strong&gt; 的几个核心对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L956&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;file&lt;/a&gt; 存放已打开的文件信息，是进程访问文件的接口；&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/dcache.h#L81&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;dentry&lt;/a&gt; 使用 &lt;code&gt;dentry&lt;/code&gt; 将文件组织成目录树结构；&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L614&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;inode&lt;/a&gt; 唯一标识文件系统中的文件。对于同一个文件，内核中只会有一个 &lt;strong&gt;inode&lt;/strong&gt; 结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每一个进程，打开的文件都有一个文件描述符，内核中进程数据结构 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct&lt;/a&gt; 中有一个类型为 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fdtable.h#L49:8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;files_struct&lt;/a&gt; 的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/sched.h#L1073&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;files&lt;/a&gt; 字段，保存着该进程打开的所有文件。&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fdtable.h#L49:8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;files_struct&lt;/a&gt; 结构的&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fdtable.h#L67&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;fd_array&lt;/a&gt; 字段是 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fs.h#L956&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;file&lt;/a&gt; 数组， 数组的下标是文件描述符，内容指向一个 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fs.h#L956&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;file&lt;/a&gt; 结构，表示该进程打开的文件。&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fs.h#L956&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;file&lt;/a&gt; 与打开文件的进程相关联，如果多个进程打开同一个文件，那么每个进程都有自己的  &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fs.h#L956&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;file&lt;/a&gt; ，但这些 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fs.h#L956&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;file&lt;/a&gt;  指向同一个 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fs.h#L614&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;inode&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241609976.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;vfs&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，进程通过文件描述符与 &lt;code&gt;VFS&lt;/code&gt; 中的 &lt;code&gt;file&lt;/code&gt; 产生联系， 每个 &lt;code&gt;file&lt;/code&gt; 对象又与一个 &lt;code&gt;dentry&lt;/code&gt; 对应，根据 &lt;code&gt;dentry&lt;/code&gt; 能找到 &lt;code&gt;inode&lt;/code&gt;，而 &lt;code&gt;inode&lt;/code&gt; 则代表文件本身。上图中进程 A 和进程 B 打开了同一个文件，进程 A 和进程 B 都维护着各自的 &lt;code&gt;file&lt;/code&gt; ，但它们指向同一个 &lt;code&gt;inode&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L614&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;inode&lt;/a&gt; 通过 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fs.h#L450&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;address_space&lt;/a&gt; 管理着文件已加载到内存中的内容，也就是 &lt;strong&gt;Page Cache&lt;/strong&gt;。&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fs.h#L450&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;address_space&lt;/a&gt; 的字段 &lt;code&gt;i_pages&lt;/code&gt; 指向一棵 &lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/core-api/xarray.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;xarray&lt;/a&gt; 树，与这个文件相关的 &lt;strong&gt;Page Cache&lt;/strong&gt; 页都挂在这颗树上。我们在访问文件内容的时候，根据指定文件和相应的页偏移量，就可以通过 &lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/core-api/xarray.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;xarray&lt;/a&gt; 树快速判断该页是否已经在 &lt;strong&gt;Page Cache&lt;/strong&gt; 中。如果该页存在，说明文件内容已经被读取到了内存，也就是存在于 &lt;strong&gt;Page Cache&lt;/strong&gt; 中；如果该页不存在，就说明内容不在 &lt;strong&gt;Page Cache&lt;/strong&gt; 中，需要从磁盘中去读取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241609688.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;address space&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;由于文件和  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L614&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;inode&lt;/a&gt; 一一对应，我们可以认为  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L614&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;inode&lt;/a&gt; 是 &lt;strong&gt;Page Cache&lt;/strong&gt; 的宿主（&lt;code&gt;host&lt;/code&gt;），内核通过 &lt;code&gt;inode-&amp;gt;imapping-&amp;gt;i_pages&lt;/code&gt; 指向的树，管理维护着 &lt;strong&gt;Page Cache&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Page Cache&lt;/strong&gt; 是如何产生和释放，又是如何与进程相关联的呢？我们需要先了解进程虚拟地址空间。&lt;/p&gt;
&lt;h2 id=&#34;进程虚拟地址空间&#34;&gt;进程虚拟地址空间&lt;/h2&gt;
&lt;p&gt;Linux 是多任务系统，它支持多个进程的的并发执行。操作系统和 CPU 联手制造了一个假象：每个进程都独享连续的虚拟内存空间，并且各个进程的地址空间是完全隔离的，因此进程并不会意识到彼此的存在。从进程的角度来看，它会认为自己是系统中唯一的进程。&lt;/p&gt;
&lt;p&gt;进程看到的是虚拟内存的地址空间，它也不能直接访问物理地址。当进程访问某个虚拟地址的时候，该虚拟地址由内核负责转换成物理内存地址，即完成虚拟地址到物理地址的映射。这样不同进程在运行的时候，即使访问相同的虚拟地址，但内核会将它们映射到不同的物理地址，因此不会发生冲突。&lt;/p&gt;
&lt;p&gt;进程在 Linux 内核由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct&lt;/a&gt; 所描述。估计 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct&lt;/a&gt; 是你学习内核时第一个熟悉的数据结构，因为它实在太重要了。 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct&lt;/a&gt;描述了进程相关的所有信息，包括进程状态，运行时统计信息，进程亲缘关系，进度调度信息，信号处理，进程内存管理，进程打开的文件等等。我们这里关注的进程虚拟内存空间，是由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct&lt;/a&gt; 中的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/sched.h#L860&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mm&lt;/a&gt; 字段指向的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L458&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mm_struct&lt;/a&gt; 所描述，它是一个进程内存的运行时摘要信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241610272.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;process_address_space&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;进程的虚拟地址是线性的，使用结构体 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 来描述。内核将每一段具有相同属性的内存区域当作一个 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 进行管理，每个 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt;  是一个连续的虚拟地址范围，这些区域不会互相重叠。 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L458&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mm_struct&lt;/a&gt; 里面有一个单链表 &lt;code&gt;mmap&lt;/code&gt;，用于将 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 串联起来，另外还有一颗红黑树 &lt;code&gt;mm_rb&lt;/code&gt; ，&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 根据起始地址挂在这颗树上。使用红黑树可以根据地址，快速查找一个内存区域。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 可以直接映射到物理内存，也可以关联文件。如果 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 是文件映射，由成员 &lt;code&gt;vm_file&lt;/code&gt; 指向对应的文件指针。一个没有关联文件的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 是匿名内存。&lt;/p&gt;
&lt;p&gt;开发者使用 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man3/free.3.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;malloc&lt;/a&gt; 等 glibc 库函数分配内存的时候，不是直接分配物理内存，而是在进程的虚拟内存空间中申请一段虚拟内存，生成相应的数据结构 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; ，然后将它插进 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L458&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mm_struct&lt;/a&gt; 的链表 &lt;code&gt;mmap&lt;/code&gt;，同时挂在红黑树 &lt;code&gt;mm_rb&lt;/code&gt; 上，就算完成了工作，根本没有涉及到物理内存的分配。只有当第一次对这块虚拟内存进行读写时，发现该内存区域没有映射到物理内存，这时会触发缺页中断，然后由内核填写页表，完成虚拟内存到物理内存的映射。&lt;/p&gt;
&lt;p&gt;当开发者使用 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/mmap.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mmap&lt;/a&gt; 进行文件映射时，内核根据 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt;  中代表文件映射关系 &lt;code&gt;vm_file&lt;/code&gt;，将文件内容从磁盘加载到物理内存，也就是 &lt;strong&gt;Page Cache&lt;/strong&gt; 中，最后建立这段虚拟地址到物理地址的映射。&lt;/p&gt;
&lt;p&gt;另外，在虚拟内存中连续的页面，在物理内存中不必是连续的。只要维护好从虚拟内存页到物理内存页的映射关系，你就能正确地使用内存。由于每个进程都有独立的地址空间，为了完成虚拟地址到物理地址的映射，每个进程都要有独立的进程页表。在一个实际的进程里面，虚拟内存占用的地址空间，通常是两段连续的空间，而不是完全散落的随机的内存地址。基于这个特点，内核使用多级页表保存映射关系，可以大大减少页表本身的空间占用。最顶级的页表保存在  &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L458&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mm_struct&lt;/a&gt; 的 &lt;code&gt;pgd&lt;/code&gt; 字段中。&lt;/p&gt;
&lt;p&gt;好了，我们对进程虚拟地址空间有了基本的了解，下面看看 &lt;strong&gt;Page Cache&lt;/strong&gt; 的产生和释放，以及如何与进程空间发生联系的。&lt;/p&gt;
&lt;h2 id=&#34;page-cache-的产生和释放&#34;&gt;Page Cache 的产生和释放&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Page Cache&lt;/strong&gt; 的产生有两种不同的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buffered I/O&lt;/li&gt;
&lt;li&gt;Memory-Mapped file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241611674.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Memory Mapped File&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;使用这两种方式访问磁盘上的文件时，内核会根据指定的文件和相应的页偏移量，判断文件内容是否已经在 &lt;strong&gt;Page Cache&lt;/strong&gt; 中，如果内容不存在，需要从磁盘中去读取并创建 &lt;strong&gt;Page Cache&lt;/strong&gt; 页。&lt;/p&gt;
&lt;p&gt;这两种方式的不同之处在于，使用 &lt;code&gt;Buffered I/O&lt;/code&gt;，要先将数据从 &lt;strong&gt;Page Cache&lt;/strong&gt; 拷贝到用户缓冲区，应用才能从用户缓冲区读取数据。而对于 &lt;code&gt;Memory-Mapped file&lt;/code&gt; 而言，则是直接将 &lt;strong&gt;Page Cache&lt;/strong&gt; 页映射到进程虚拟地址空间，用户可以直接读写 &lt;strong&gt;Page Cache&lt;/strong&gt; 中的内容。由于少了一次 copy，使用 &lt;code&gt;Memory-Mapped file&lt;/code&gt; 要比 &lt;code&gt;Buffered I/O&lt;/code&gt;  的效率高一些。&lt;/p&gt;
&lt;p&gt;随着服务器运行时间的增加，系统中空闲内存会越来越少，其中很大一部分都被 Page Cache 占用。访问过的文件都被 Page Cache 缓存，内存最终会被耗尽，那什么时候回收 Page Cache 呢？ 内核认为，Page Cache 是可回收内存，当应用在申请内存时，如果没有足够的空闲内存，就会先回收 Page Cache，再尝试申请。回收的方式主要是两种：直接回收和后台回收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241611132.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;reclaim_page_cache&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;Buffered I/O&lt;/code&gt; 时，&lt;strong&gt;Page Cache&lt;/strong&gt; 并没有和进程的虚拟内存空间产生直接的关联，而是通过用户缓冲区作为中转。效率更好的&lt;code&gt;Memory-Mapped file&lt;/code&gt;方式，看着比较简单，但背后的实现却有些复杂。下面我们看一下内核是如何实现 &lt;code&gt;Memory-Mapped file&lt;/code&gt; 的。&lt;/p&gt;
&lt;h2 id=&#34;内存文件映射&#34;&gt;内存文件映射&lt;/h2&gt;
&lt;p&gt;前面我们介绍过，  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L614&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;inode&lt;/a&gt; 是 &lt;strong&gt;Page Cache&lt;/strong&gt; 的宿主（&lt;code&gt;host&lt;/code&gt;），内核通过 &lt;code&gt;inode-&amp;gt;imapping-&amp;gt;i_pages&lt;/code&gt; 指向的树，管理维护着 &lt;strong&gt;Page Cache&lt;/strong&gt;。那么内核是如何完成内存文件映射，直接把缓存了文件内容的 &lt;strong&gt;Page Cache&lt;/strong&gt; 映射到进程虚拟内存空间的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241612690.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;address_space_memory_mapping&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我们知道，进程结构体 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct&lt;/a&gt; 中的字段 &lt;code&gt;mm&lt;/code&gt; 指向该进程的虚拟地址空间 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/mm_types.h#L458&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mm_struct&lt;/a&gt; ，而一段虚拟内存由结构体 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 所描述，将 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 串在一起的链表 &lt;code&gt;mmap&lt;/code&gt; 就代表了已经申请分配的虚拟内存。&lt;/p&gt;
&lt;p&gt;如果是进行内存文件映射，那么映射了文件的虚拟内存区域  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; ，它的 &lt;code&gt;vm_file&lt;/code&gt; 会指向被映射的文件结构体  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L956&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;file&lt;/a&gt;。&lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L956&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;file&lt;/a&gt; 表示进程打开的文件，它的成员 &lt;code&gt;f_mapping&lt;/code&gt; 指向 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fs.h#L450&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;address_space&lt;/a&gt;，这样就和管理文件着 &lt;strong&gt;Page Cache&lt;/strong&gt; 的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fs.h#L450&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;address_space&lt;/a&gt; 关联了起来。&lt;/p&gt;
&lt;p&gt;当第一次访问文件映射的虚拟内存区域时，这段虚拟内存并没有映射到物理内存，这时会触发缺页中断。内核在处理缺页中断时，发现代表这段虚拟内存的 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 有关联的文件，即 &lt;code&gt;vm_file&lt;/code&gt; 字段指向一个文件结构体 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L956&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;file&lt;/a&gt;。内核拿到该文件的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/fs.h#L450&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;address_space&lt;/a&gt;，根据要访问内容的页偏移量，对 &lt;code&gt;address_space-&amp;gt;i_pages&lt;/code&gt; 指向的 &lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/core-api/xarray.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;xarray&lt;/a&gt; 树进行查找。这颗树上挂的都是页偏移量对应的内存页，如果没找到，就说明文件内容还没加载进内存，就会分配内存页，将文件内容加载到内存中，然后把内存页挂在  &lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/core-api/xarray.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;xarray&lt;/a&gt; 树上。下次再访问同样的页偏移量时，文件内容已经在树上，可直接返回。 &lt;code&gt;address_space-&amp;gt;i_pages&lt;/code&gt; 指向的树就是内核管理的 &lt;strong&gt;Page Cache&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;将文件内容加载到 &lt;strong&gt;Page Cache&lt;/strong&gt; 后，内核就可以填写进程相关的页表项，将这块文件映射的虚拟地址区域，直接映射到 &lt;strong&gt;Page Cache&lt;/strong&gt; 页，完成缺页中断的处理。&lt;/p&gt;
&lt;p&gt;当内存紧张需要回收 &lt;strong&gt;Page Cache&lt;/strong&gt; 时，内核需要知道这些  Page Cache 页映射到了哪些进程，这样才能修改进程的页表，解除虚拟内存和物理内存的映射。我们知道，同一个文件可以映射到多个进程空间，所以需要保存&lt;strong&gt;反向映射关系&lt;/strong&gt;，即根据 Page Cache 页找到进程。&lt;/p&gt;
&lt;p&gt;Page Cache  页的反向映射关系保存在 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L450&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;address_space&lt;/a&gt; 维护的另一颗树 &lt;code&gt;i_mmap&lt;/code&gt;。&lt;code&gt;address_space-&amp;gt;i_mmap&lt;/code&gt; 是一个优先查找树（Priority Search Tree），关联了这个文件 Page Cache 页的 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 就挂在这棵树上，而这些  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt;都将指向各自的进程空间描述符 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/mm_types.h#L458&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mm_struct&lt;/a&gt;，从而建立了 Page Cache 页到进程的联系。&lt;/p&gt;
&lt;p&gt;当需要解除一个 Page Cache 页的映射时，利用 &lt;code&gt;address_space-&amp;gt;i_mmap&lt;/code&gt; 指向的树，查找 Page Cache 页映射到哪些进程的哪些 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt;，从而确定需要修改的进程页表项内容。&lt;/p&gt;
&lt;p&gt;简单总结一下，一个文件对应的  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L450&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;address_space&lt;/a&gt; 主要管理着两颗树：&lt;code&gt;i_pages&lt;/code&gt; 指向的 &lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/core-api/xarray.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;xarray&lt;/a&gt; 树，维护着的所有 Page Cache 页；&lt;code&gt;i_mmap&lt;/code&gt; 指向的 PST 树，维护着文件映射所形成的  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 虚拟内存区域，用来在释放 Page Cache 页时，查找映射了该文件的进程。如果文件没有被映射到进程空间，那么 &lt;code&gt;i_mmap&lt;/code&gt; 对应的 PST 树为空。&lt;/p&gt;
&lt;h2 id=&#34;page-cache-的观测&#34;&gt;Page Cache 的观测&lt;/h2&gt;
&lt;p&gt;可以通过查看 &lt;code&gt;/proc/meminfo&lt;/code&gt; 文件获知 &lt;strong&gt;Page Cache&lt;/strong&gt; 相关的各种指标。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc&lt;/code&gt; 是伪文件系统（Pseudo filesystems ）。Linux 通过伪文件系统，让系统和内核信息在用户空间可用。使用 &lt;code&gt;free&lt;/code&gt;、&lt;code&gt;vmstat&lt;/code&gt;等命令查看到的内存信息，数据实际上都来自 &lt;code&gt;/proc/meminfo&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们看一个示例：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;关于 &lt;code&gt;/proc/meminfo&lt;/code&gt; 每一项的详细解释，可以查看 [Linux 内核文档 - The /proc Filesystem](&lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/filesystems/proc.html#meminfo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The /proc Filesystem — The Linux Kernel documentation&lt;/a&gt;)。我们重点看一下 &lt;strong&gt;Page Cache&lt;/strong&gt; 相关的字段。&lt;/p&gt;
&lt;p&gt;当前系统 Page Cache 等于 Buffers + Cached 之和 ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Buffers + Cached = 5072756 kB
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;前面讨论过，如果 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 关联到文件，那么这段内存区域就是 File-backed 内存。没有关联文件的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/f443e374ae131c168a065ea1748feac6b2e76613/include/linux/mm_types.h#L375&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 内存区域是匿名内存。我们是否可以认为，和磁盘文件相关联的 File-backed 内存总和，应该等于 Page Cache 呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Active(file) + Inactive(file) = 4908664 kB
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;好像有点对不上，还差了一些，差的这部分是共享内存（&lt;strong&gt;Shmem&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;Linux 为了实现“共享内存”（shared memory）功能，即多个进程共同使用同一内存中的内容，需要使用虚拟文件系统。虚拟文件并不是真实存在于磁盘上的文件，它只是由内核模拟出来的。但虚拟文件也有自己的 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L614&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;inode&lt;/a&gt;  和  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L450&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;address_space&lt;/a&gt;结构。内核在创建共享匿名映射区域时，会创建出一个虚拟文件，并将这个文件与 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt;关联起来，这样多个进程的  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 会关联到同一个虚拟文件，最终映射到同样的物理内存页，从而实现了共享内存功能。这就是共享内存（&lt;strong&gt;Shmem&lt;/strong&gt;）的实现原理。&lt;/p&gt;
&lt;p&gt;由于 &lt;strong&gt;Shmem&lt;/strong&gt; 没有关联磁盘上的文件，因此它不属于 File-backed 内存，而是被记录在匿名内存（&lt;strong&gt;Active(anon)&lt;/strong&gt; 或 &lt;strong&gt;Inactive(anon)&lt;/strong&gt;）部分。但因为 &lt;strong&gt;Shmem&lt;/strong&gt; 有自己的 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/fs.h#L614&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;inode&lt;/a&gt; ，&lt;code&gt;inode-&amp;gt;address_sapce&lt;/code&gt; 维护的 Page Cache 页挂在 &lt;code&gt;address_space-&amp;gt;i_pages&lt;/code&gt; 指向的 &lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/core-api/xarray.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;xarray&lt;/a&gt; 树上，因此 &lt;strong&gt;Shmem&lt;/strong&gt; 部分的内存也应该算在 Page Cache 里。&lt;/p&gt;
&lt;p&gt;此外 File-backed 内存还有 Active 和 Inactive 的区别。刚被使用过的数据的内存空间被认为是 Active 的，长时间未被使用过的数据的内存空间则被认为是 Inactive 的。当物理内存不足，不得不释放正在使用的内存时，会首先释放 Inactive 的内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Page Cache&lt;/strong&gt; 和 匿名内存以及 File-backed 内存等之间的关系，如图下图所示。虽然难免存在误差，但大体来说下面的关系式是成立的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241613319.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;file-backed anon&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是，&lt;strong&gt;AnonPages != Active(anon) + Inactive(anon)&lt;/strong&gt;。&lt;strong&gt;Active(anon)&lt;/strong&gt; 和 &lt;strong&gt;Inactive(anon)&lt;/strong&gt; 是用来表示不可回收但是可以被交换到 swap 分区的内存，而 &lt;strong&gt;AnonPages&lt;/strong&gt; 则是指没有对应文件的内存，两者的角度不一样。 &lt;strong&gt;Shmem&lt;/strong&gt; 虽然属于&lt;strong&gt;Active(anon)&lt;/strong&gt; 或者 &lt;strong&gt;Inactive(anon)&lt;/strong&gt;，但是 &lt;strong&gt;Shmem&lt;/strong&gt; 有对应的内存虚拟文件，所以它不属于 &lt;strong&gt;AnonPages&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;总之，&lt;strong&gt;Page Cache&lt;/strong&gt; 肯定关联了文件，不管是真实存在的磁盘文件，还是虚拟内存文件。&lt;strong&gt;AnonPages&lt;/strong&gt; 则没有关联任何文件。&lt;strong&gt;Shmem&lt;/strong&gt; 关联了虚拟文件，它属于 &lt;strong&gt;Active(anon)&lt;/strong&gt; 或者 &lt;strong&gt;Inactive(anon)&lt;/strong&gt;，同时也算在 &lt;strong&gt;Page Cache&lt;/strong&gt; 中。&lt;/p&gt;
&lt;p&gt;如果我们想知道某个文件有多少内容被缓存在 Page Cache ，可以使用 [fincore](&lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man1/fincore.1.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;fincore（1） - Linux 手册页 (man7.org)&lt;/a&gt;) 命令。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ fincore /usr/lib/x86_64-linux-gnu/libc.so.6
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;RES  PAGES  SIZE FILE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2.1M   542  2.1M /usr/lib/x86_64-linux-gnu/libc.so.6
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;RES&lt;/code&gt; 是文件内容被加载进物理内存占用的内存空间大小。&lt;code&gt;PAGES&lt;/code&gt; 是换算成文件内容占用了多少内存页。 在上面的例子中，文件 &lt;code&gt;/usr/lib/x86_64-linux-gnu/libc.so.6&lt;/code&gt; 的全部内容，都被加载进了 Page Cache。&lt;/p&gt;
&lt;p&gt;结合 &lt;code&gt;lsof&lt;/code&gt; 命令，我们可以查看某一进程打开的文件占用了多少 Page Cache：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo lsof -p 1270 | grep REG | awk &amp;#39;{print $9}&amp;#39; | xargs sudo fincore
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  RES PAGES   SIZE FILE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;64.8M 16580  89.9M /usr/bin/dockerd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  32K     8    32K /var/lib/docker/buildkit/cache.db
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  16K     4    16K /var/lib/docker/buildkit/metadata_v2.db
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  16K     4    16K /var/lib/docker/buildkit/snapshots.db
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  16K     4    16K /var/lib/docker/buildkit/containerdmeta.db
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 284K    71 282.4K /usr/lib/x86_64-linux-gnu/libnss_systemd.so.2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 244K    61 594.7K /usr/lib/x86_64-linux-gnu/libpcre2-8.so.0.10.2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 156K    39 154.2K /usr/lib/x86_64-linux-gnu/libgpg-error.so.0.29.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  24K     6  20.6K /usr/lib/x86_64-linux-gnu/libpthread.so.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 908K   227 906.5K /usr/lib/x86_64-linux-gnu/libm.so.6
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;另外，对于所有缓存类型，缓存命中率都是一个非常重要的指标。我们可以使用 &lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;bcc&lt;/a&gt; 内置的工具 &lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc/blob/master/tools/cachestat_example.txt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cachestat&lt;/a&gt;  追踪整个系统的  Page Cache 命中率：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo cachestat-bpfcc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    HITS   MISSES  DIRTIES HITRATIO   BUFFERS_MB  CACHED_MB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    2059        0       32  100.00%           74       1492
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     522        0        0  100.00%           74       1492
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      32        0        7  100.00%           74       1492
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     135        0       69  100.00%           74       1492
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      97        1        3   98.98%           74       1492
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     512        0       82  100.00%           74       1492
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     303        0       86  100.00%           74       1492
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    2474        7     1028   99.72%           74       1494
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     815        0      964  100.00%           74       1497
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    2786        0        1  100.00%           74       1497
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    1051        0        0  100.00%           74       1497
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;^C     502        0        0  100.00%           74       1497
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Detaching...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用 &lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc/blob/master/tools/cachetop_example.txt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cachetop&lt;/a&gt; 可以按进程追踪 Page Cache 命中率：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo cachetop-bpfcc 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;14:20:41 Buffers MB: 86 / Cached MB: 2834 / Sort: HITS / Order: descending
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;PID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   14237 mazhen   java                12823     4594     3653      52.6%      13.2%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   14370 mazhen   ldd                   869        0        0     100.0%       0.0%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   14371 mazhen   grep                  596        0        0     100.0%       0.0%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   14376 mazhen   ldd                   536        0        0     100.0%       0.0%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   14369 mazhen   env                   468        0        0     100.0%       0.0%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   14377 mazhen   ldd                   467        0        0     100.0%       0.0%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   14551 mazhen   grpc-default-ex       466        0        0     100.0%       0.0%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   14375 mazhen   ldd                   435        0        0     100.0%       0.0%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   14479 mazhen   ldconfig              421        0        0     100.0%       0.0%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   14475 mazhen   BookieJournal-3       417       58      132      60.0%       6.1%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;mmap系统调用&#34;&gt;mmap系统调用&lt;/h2&gt;
&lt;p&gt;系统调用 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/mmap.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mmap&lt;/a&gt;是最重要的内存管理接口。使用 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/mmap.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mmap&lt;/a&gt; 可以创建文件映射，从而产生 Page Cache。使用  &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/mmap.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mmap&lt;/a&gt; 还可以用来申请堆内存。glibc 提供的  &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man3/free.3.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;malloc&lt;/a&gt;，内部使用的就是 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/mmap.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mmap&lt;/a&gt; 系统调用。 由于 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/mmap.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mmap&lt;/a&gt; 系统调用分配内存的效率比较低，  &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man3/free.3.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;malloc&lt;/a&gt; 会先使用 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/mmap.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mmap&lt;/a&gt; 向操作系统申请一块比较大的内存，然后再通过各种优化手段让内存分配的效率最大化。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/mmap.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mmap&lt;/a&gt; 根据参数的不同， 可以从是不是文件映射，以及是不是私有内存这两个不同的维度来进行组合：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241614395.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;mmap&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;私有匿名映射&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在调用 &lt;code&gt;mmap(MAP_ANON | MAP_PRIVATE)&lt;/code&gt; 时，只需要在进程虚拟内存空间分配一块内存，然后创建这块内存所对应的  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 结构，这次调用就结束了。当访问到这块虚拟内存时，由于这块虚拟内存都没有映射到物理内存上，就会发生缺页中断。 &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt;关联文件属性为空，所以是匿名映射。内核会分配一个物理内存，然后在页表里建立起虚拟地址到物理地址的映射关系。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;私有文件映射&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程通过 &lt;code&gt;mmap(MAP_FILE | MAP_PRIVATE)&lt;/code&gt; 这种方式来申请的内存，比如进程将共享库（Shared libraries）和可执行文件的代码段（Text Segment）映射到自己的地址空间就是通过这种方式。&lt;/p&gt;
&lt;p&gt;如果文件是只读的话，那这个文件在物理页的层面上其实是共享的。也就是进程 A 和进程 B 都有一页虚拟内存被映射到了相同的物理页上。但如果要写文件的时候，因为这一段内存区域的属性是私有的，所以内核就会做一次写时复制，为写文件的进程单独地创建一份副本。这样，一个进程在写文件时，并不会影响到其他进程的读。&lt;/p&gt;
&lt;p&gt;私有文件映射的只读页是多进程间共享的，可写页是每个进程都有一个独立的副本，创建副本的时机仍然是写时复制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;共享文件映射&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程通过 &lt;code&gt;mmap(MAP_FILE | MAP_SHARED)&lt;/code&gt; 这种方式来申请的内存。在私有文件映射的基础上，共享文件映射就很简单了：对于可写的页面，在写的时候不进行复制就可以了。这样的话，无论何时，也无论是读还是写，多个进程在访问同一个文件的同一个页时，访问的都是相同的物理页面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;共享匿名映射&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程通过 &lt;code&gt;mmap(MAP_ANON | MAP_SHARED)&lt;/code&gt; 这种方式来申请的内存。借助虚拟文件系统，多个进程的  &lt;a class=&#34;link&#34; href=&#34;https://elixir.bootlin.com/linux/v5.17/source/include/linux/sched.h#L728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vm_area_struct&lt;/a&gt; 会关联到同一个虚拟文件，最终映射到同样的物理内存页，实现进程间共享内存的功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mmap&lt;/code&gt; 的四种映射类型，和上面介绍的 &lt;code&gt;/proc/meminfo&lt;/code&gt; 内存指标之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241614330.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;mmap&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;私有映射都属于 &lt;strong&gt;AnonPages&lt;/strong&gt;，共享映射都是 &lt;strong&gt;Page cache&lt;/strong&gt;。前面讨论过，共享的匿名映射 &lt;strong&gt;Shmem&lt;/strong&gt;，虽然没有关联真实的磁盘文件，但是关联了虚拟内存文件，所以也属于 &lt;strong&gt;Page Cache&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;私有文件映射，如果文件是只读的话，这块内存属于 &lt;strong&gt;Page Cache&lt;/strong&gt;。如果有进程写文件，因为这一段内存区域的属性是私有的，所以内核就会做一次写时复制，为写文件的进程单独地创建一份副本，这个副本就属于 &lt;strong&gt;AnonPages&lt;/strong&gt; 了。&lt;/p&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;Page Cache 机制涉及了进程空间，文件系统，内存管理等多个内核功能，Page Cache 就像一条线将这几部分串在了一起。因此深入理解 Page Cache 机制，对学习内核会有很大的帮助。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>进程ID及进程间的关系</title>
        <link>https://mazhen.tech/p/%E8%BF%9B%E7%A8%8Bid%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
        <pubDate>Sun, 14 Nov 2021 16:02:22 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E8%BF%9B%E7%A8%8Bid%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
        <description>&lt;h2 id=&#34;进程id&#34;&gt;进程ID&lt;/h2&gt;
&lt;p&gt;进程相关的 &lt;code&gt;ID&lt;/code&gt; 有多种，除了进程标识 &lt;strong&gt;PID&lt;/strong&gt; 外，还包括：线程组标识 &lt;strong&gt;TGID&lt;/strong&gt;，进程组标识 &lt;strong&gt;PGID&lt;/strong&gt;，回话标识 &lt;strong&gt;SID&lt;/strong&gt;。&lt;strong&gt;TGID/PGID/SID&lt;/strong&gt; 分别是相关线程组长/进程组长/回话 leader 进程的 &lt;strong&gt;PID&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面分别介绍这几种ID。&lt;/p&gt;
&lt;h3 id=&#34;pid&#34;&gt;PID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程总是会被分配一个唯一标识它们的进程ID号，简称 &lt;strong&gt;PID&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;code&gt;fork&lt;/code&gt; 或 &lt;code&gt;clone&lt;/code&gt; 产生的每个进程都由内核自动地分配了一个唯一的 &lt;strong&gt;PID&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PID&lt;/strong&gt; 保存在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L943&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct-&amp;gt;pid&lt;/a&gt;中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tgid&#34;&gt;TGID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程以 &lt;code&gt;CLONE_THREAD&lt;/code&gt; 标志调用 &lt;code&gt;clone&lt;/code&gt; 方法，创建与该进程共享资源的线程。线程有独立的&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L723&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct&lt;/a&gt;，但它 &lt;code&gt;task_struct&lt;/code&gt;内的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L1070&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;files_struct&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L1067&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;fs_struct&lt;/a&gt; 、&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L1081&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;sighand_struct&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L1080&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;signal_struct&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L857&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mm_struct&lt;/a&gt; 等数据结构仅仅是对进程相应数据结构的引用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由进程创建的所有线程都有相同的线程组ID(&lt;strong&gt;TGID&lt;/strong&gt;)。线程有自己的 &lt;strong&gt;PID&lt;/strong&gt;，它的&lt;strong&gt;TGID&lt;/strong&gt; 就是进程的主线程的 &lt;strong&gt;PID&lt;/strong&gt;。如果进程没有使用线程，则其 &lt;strong&gt;PID&lt;/strong&gt; 和 &lt;strong&gt;TGID&lt;/strong&gt; 相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在内核中进程和线程都用 &lt;code&gt;task_struct&lt;/code&gt;表示，而有了 &lt;strong&gt;TGID&lt;/strong&gt;，我们就可以知道 &lt;code&gt;task_struct&lt;/code&gt; 代表的是一个进程还是一个线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TGID&lt;/strong&gt; 保存在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L944&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct-&amp;gt;tgid&lt;/a&gt; 中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当 &lt;code&gt;task_struct&lt;/code&gt; 代表一个线程时，&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L967&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct-&amp;gt;group_leader&lt;/a&gt; 指向主线程的 &lt;code&gt;task_struct&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pgid&#34;&gt;PGID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;code&gt;shell&lt;/code&gt; 具有作业管理能力，则它所创建的相关进程构成一个进程组，同一进程组的进程都有相同的 &lt;strong&gt;PGID&lt;/strong&gt;。例如，用管道连接的进程包含在同一个进程组中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程组简化了向组的所有成员发送信号的操作。进程组提供了一种机制，让信号可以发送给组内的所有进程，这使得作业控制变得简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当 &lt;code&gt;task_struct&lt;/code&gt; 代表一个进程，且该进程属于某一个进程组，则 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L967&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct-&amp;gt;group_leader&lt;/a&gt; 指向组长进程的 &lt;code&gt;task_struct&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PGID&lt;/strong&gt; 保存在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched/signal.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L153&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct-&amp;gt;signal-&amp;gt;pids[PIDTYPE_PGID].pid&lt;/a&gt;中。 &lt;code&gt;pids[]&lt;/code&gt; 的数组下标是枚举类型，在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/v5.15/include/linux/pid.h&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;include/linux/pid.h&lt;/a&gt; 中定义了 &lt;code&gt;PID&lt;/code&gt; 的类型：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid_type&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;PIDTYPE_PID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;PIDTYPE_TGID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;PIDTYPE_PGID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;PIDTYPE_SID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;PIDTYPE_MAX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;task_struce-&amp;gt;signal&lt;/code&gt; 是 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched/signal.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L82&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;signal_struct&lt;/a&gt; 类型，维护了进程收到的信号，&lt;code&gt;task_struce-&amp;gt;signal&lt;/code&gt; 被该进程的所有线程共享。从 &lt;strong&gt;PGID&lt;/strong&gt; 保存在 &lt;code&gt;task_struct-&amp;gt;signal-&amp;gt;pids[PIDTYPE_PGID]&lt;/code&gt;中可以看出进程组和信号处理相关。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sid&#34;&gt;SID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户一次登录所涉及所有活动称为一个会话（&lt;strong&gt;session&lt;/strong&gt;），其间产生的所有进程都有相同的会话ID（&lt;strong&gt;SID&lt;/strong&gt;），等于会话 leader 进程的  &lt;strong&gt;PID&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SID&lt;/strong&gt; 保存在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched/signal.h?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L153&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task_struct-&amp;gt;signal-&amp;gt;pids[PIDTYPE_SID].pid&lt;/a&gt;中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pidtgidpgidsid总结&#34;&gt;&lt;strong&gt;PID/TGID/PGID/SID&lt;/strong&gt;总结&lt;/h3&gt;
&lt;p&gt;用一幅图来总结 &lt;strong&gt;PID/TGID/PGID/SID&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241603321.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pid&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;进程间关系&#34;&gt;进程间关系&lt;/h2&gt;
&lt;p&gt;内核中所有进程的 &lt;code&gt;task_struct&lt;/code&gt; 会形成多种组织关系。根据进程的创建过程会有亲属关系，进程间的父子关系组织成一个进程树；根据用户登录活动会有会话和进程组关系。&lt;/p&gt;
&lt;h3 id=&#34;亲属关系&#34;&gt;亲属关系&lt;/h3&gt;
&lt;p&gt;进程通过 &lt;code&gt;fork()&lt;/code&gt; 创建出一个子进程，就形成来父子关系，如果创建出多个子进程，那么这些子进程间属于兄弟关系。可以用 &lt;code&gt;pstree&lt;/code&gt; 命令查看当前系统的进程树。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ pstree -p
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;systemd(1)─┬─ModemManager(759)─┬─{ModemManager}(802)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           │                   └─{ModemManager}(806)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           ├─NetworkManager(685)─┬─{NetworkManager}(743)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           │                     └─{NetworkManager}(750)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           ├─acpid(675)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           ├─agetty(814)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           ├─avahi-daemon(679)───avahi-daemon(712)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           ├─bluetoothd(680)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           ├─canonical-livep(754)─┬─{canonical-livep}(1224)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           │                      ├─{canonical-livep}(1225)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           │                      ├─{canonical-livep}(1226)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;进程描述符 &lt;code&gt;task_struct&lt;/code&gt; 的 &lt;code&gt;parent&lt;/code&gt; 指向父进程，&lt;code&gt;children&lt;/code&gt;指向子进程链表的头部，&lt;code&gt;sibling&lt;/code&gt; 把当前进程插入到兄弟链表中。&lt;/p&gt;
&lt;p&gt;通常情况下，&lt;code&gt;real_parent&lt;/code&gt; 和 &lt;code&gt;parent&lt;/code&gt; 是一样的。如果在 &lt;code&gt;bash&lt;/code&gt; 上使用 &lt;code&gt;GDB&lt;/code&gt; 来 debug 一个进程，这时候进程的 &lt;code&gt;parent&lt;/code&gt; 是  &lt;code&gt;GDB&lt;/code&gt; ，进程的 &lt;code&gt;real_parent&lt;/code&gt; 是 &lt;code&gt;bash&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241605683.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pstree&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当一个进程创建了子进程后，它应该通过系统调用 &lt;code&gt;wait()&lt;/code&gt; 或者 &lt;code&gt;waitpid()&lt;/code&gt; 等待子进程结束，回收子进程的资源。而子进程在结束时，会向它的父进程发送 &lt;code&gt;SIGCHLD&lt;/code&gt; 信号。因此父进程还可以注册 &lt;code&gt;SIGCHLD&lt;/code&gt; 信号的处理函数，异步回收资源。&lt;/p&gt;
&lt;p&gt;如果父进程提前结束，那么子进程将把1号进程 &lt;code&gt;init&lt;/code&gt; 作为父进程。总之，进程都有父进程，负责进程结束后的资源回收。在子进程退出且父进程完成回收前，子进程变成僵尸进程。僵尸进程持续的时间通常比较短，在父进程回收它的资源后就会消亡。如果父进程没有处理子进程的终止，那么子进程就会一直处于僵尸状态。&lt;/p&gt;
&lt;h3 id=&#34;会话进程组关系&#34;&gt;会话、进程组关系&lt;/h3&gt;
&lt;p&gt;Linux 系统中可以有多个会话（&lt;strong&gt;session&lt;/strong&gt;），每个会话可以包含多个进程组，每个进程组可以包含多个进程。&lt;/p&gt;
&lt;p&gt;会话是用户登录系统到退出的所有活动，从登录到结束前创建的所有进程都属于这次会话。登录后第一个被创建的进程（通常是 &lt;code&gt;shell&lt;/code&gt;），被称为 &lt;strong&gt;会话 leader&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进程组用于作业控制。一个终端上可以启动多个作业，也就是进程组，并能控制哪个作业在前台，前台作业可以访问终端，哪些作业运行在后台，不能读写终端。&lt;/p&gt;
&lt;p&gt;我们来看一个会话和进程组的例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat | head
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hello
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hello
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;^Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[1]+  已停止               cat | head
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ps j | more
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   1522    1532    1532    1532 pts/0       1762 Ss    1000   0:00 -bash
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   1532    1760    1760    1532 pts/0       1762 T     1000   0:00 cat
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   1532    1761    1760    1532 pts/0       1762 T     1000   0:00 head
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   1532    1762    1762    1532 pts/0       1762 R+    1000   0:00 ps j
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   1532    1763    1762    1532 pts/0       1762 S+    1000   0:00 more
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面的命令通过 &lt;code&gt;cat | head&lt;/code&gt; 创建了第一个进程组，包含 &lt;code&gt;cat&lt;/code&gt; 和 &lt;code&gt;head &lt;/code&gt;两个进程。这时这个作业是前台任务，可以控制终端。当我们按下 &lt;strong&gt;Ctrl + z&lt;/strong&gt;，会发送信号 &lt;strong&gt;SIGTSTP&lt;/strong&gt; 给前台进程组的所有进程，该信号的缺省行为是暂停作业执行。暂停的作业会让出终端，并且进程不会再被调度，直到它们收到 &lt;strong&gt;SIGCONT&lt;/strong&gt; 信号恢复执行。&lt;/p&gt;
&lt;p&gt;然后我们通过 &lt;code&gt;ps j | more&lt;/code&gt; 创建了另一个进程组，包含 &lt;code&gt;ps&lt;/code&gt; 和 &lt;code&gt;more&lt;/code&gt; 两个进程。&lt;code&gt;ps&lt;/code&gt; 的参数 &lt;code&gt;j&lt;/code&gt; 表示用任务格式显示进程。输出中的 &lt;strong&gt;STAT&lt;/strong&gt; 列是进程的状态码，前面的大写字母表示进程状态，我们可以从 &lt;code&gt;ps&lt;/code&gt; 的 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man1/ps.1.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;man page&lt;/a&gt; 查看其含义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;D    uninterruptible sleep (usually IO)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;I    Idle kernel thread
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;R    running or runnable (on run queue)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;S    interruptible sleep (waiting for an event to complete)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;T    stopped by job control signal
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;t    stopped by debugger during the tracing
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;W    paging (not valid since the 2.6.xx kernel)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;X    dead (should never be seen)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Z    defunct (&amp;#34;zombie&amp;#34;) process, terminated but not reaped by its parent
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;某些进程除了大写字母代表的进程状态，还跟着一个附加符号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;s&lt;/strong&gt; ：进程是会话 leader 进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;+&lt;/strong&gt; ：进程位于前台进程组中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从输出可以看出，&lt;code&gt;bash&lt;/code&gt; 是这个会话的 leader 进程，它的 &lt;strong&gt;PID&lt;/strong&gt;、&lt;strong&gt;PGID&lt;/strong&gt; 和 &lt;strong&gt;SID&lt;/strong&gt; 相同，都是&lt;code&gt;1532&lt;/code&gt; 。这个会话其他所有进程的 &lt;strong&gt;SID&lt;/strong&gt; 也都是 &lt;code&gt;1532&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat | head&lt;/code&gt; 进程组的 &lt;strong&gt;PGID&lt;/strong&gt; 是 &lt;code&gt;1760&lt;/code&gt;，&lt;code&gt;ps j | more&lt;/code&gt; 进程组的  &lt;strong&gt;PGID&lt;/strong&gt; 是 &lt;code&gt;1762&lt;/code&gt;。用管道连接的进程包含在同一个进程组中，每个进程组内第一个进程成为 Group Leader，并以 Group Leader 的 &lt;strong&gt;PID&lt;/strong&gt; 作为组内进程的 &lt;strong&gt;PGID&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;会话有一个前台进程组，还可以有一个或多个后台进程组，只有前台作业可以从终端读写数据。示例的进程组关系如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241605195.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;session&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;注意到上图中显示，终端设备可以向进程组发送信号。我们可以在终端输入特殊字符向前台进程发送信号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + c&lt;/strong&gt; 发送 &lt;strong&gt;SIGINT&lt;/strong&gt; 信号，默认行为是终止进程；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + \&lt;/strong&gt; 发送 &lt;strong&gt;SIGQUIT&lt;/strong&gt; 信号，默认行为是终止进程，并进行 &lt;code&gt;core dump&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + z&lt;/strong&gt; 发送 &lt;strong&gt;SIGTSTP&lt;/strong&gt; 信号，暂停进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有前台进程可以从终端接收输入，也只有前台进程才被允许向终端输出。如果一个后台作业中的进程试图进行终端读写操作，终端会向整个作业发送 &lt;strong&gt;SIGTTOU&lt;/strong&gt; 或 &lt;strong&gt;SIGTTIN&lt;/strong&gt; 信号，默认的行为是暂停进程。&lt;/p&gt;
&lt;p&gt;当终端关闭时，会向整个会话发送 &lt;strong&gt;SIGHUP&lt;/strong&gt; 信号，通常情况下，这个会话的所有进程都会被终止。如果想让运用在后台的进程不随着 &lt;strong&gt;session&lt;/strong&gt; 的结束而退出，可以使用 &lt;strong&gt;nohup&lt;/strong&gt; 命令忽略 &lt;strong&gt;SIGHUP&lt;/strong&gt; 信号：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ nohup command &amp;gt;cmd.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;即使 &lt;code&gt;shell&lt;/code&gt; 结束，运行于后台的进程也能无视  &lt;strong&gt;SIGHUP&lt;/strong&gt;  信号继续执行。另外一个方法是可以让进程运行在  &lt;code&gt;screen&lt;/code&gt; 或 &lt;code&gt;tmux&lt;/code&gt; 这种终端多路复用器（&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Terminal_multiplexer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;terminal multiplexer&lt;/a&gt;）中。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>使用PSI（Pressure Stall Information）监控服务器资源</title>
        <link>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8psipressure-stall-information%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90/</link>
        <pubDate>Sun, 01 Aug 2021 11:51:05 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8psipressure-stall-information%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90/</guid>
        <description>&lt;p&gt;我们通常会使用 &lt;strong&gt;load average&lt;/strong&gt; 了解服务器的健康状况，检查服务器的负载是否正常。但 &lt;code&gt;load average&lt;/code&gt; 有几个缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;load average&lt;/code&gt; 的计算包含了 &lt;strong&gt;TASK_RUNNING&lt;/strong&gt; 和 &lt;strong&gt;TASK_UNINTERRUPTIBLE&lt;/strong&gt; 两种状态的进程。&lt;code&gt;TASK_RUNNING&lt;/code&gt; 是进程处于运行、或等待分配 CPU 的准备运行状态。&lt;code&gt;TASK_UNINTERRUPTIBLE&lt;/code&gt; 是进程处于不可中断的等待，一般是等待磁盘的输入输出。因此 &lt;code&gt;load average&lt;/code&gt; 值飙高，可能是因为 CPU 资源不够，让很多处于 &lt;code&gt;TASK_RUNNING&lt;/code&gt; 状态的进程等待 CPU，也可能是由于磁盘 I/O 资源紧张，造成很多进程因为等待 IO 而处于 &lt;code&gt;TASK_UNINTERRUPTIBLE&lt;/code&gt; 状态。你可以通过 &lt;code&gt;load average&lt;/code&gt; 发现系统很忙，但没法区分是因为争夺 CPU 还是 IO 引起的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load average&lt;/code&gt; 最短的时间窗口为1分钟，没法观察更短窗口的负载平均值，例如想了解最近10秒的&lt;code&gt;load average&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load average&lt;/code&gt; 报告的是活跃进程数的原始数据，你还需要知道可用的 CPU 核数，这样 &lt;code&gt;load average&lt;/code&gt; 的值才有意义。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，当用户遇到服务器 &lt;code&gt;load average&lt;/code&gt; 飙高的时候，还需要继续查看 CPU、I/O 和内存等资源的统计数据，才能进一步分析问题。&lt;/p&gt;
&lt;p&gt;于是，Facebook的工程师 Johannes Weiner 发明了一个新的指标 &lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/accounting/psi.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PSI(Pressure Stall Information)&lt;/a&gt;，并向内核提交了这个&lt;a class=&#34;link&#34; href=&#34;https://lwn.net/Articles/763629/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;patch&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;psi-概览&#34;&gt;PSI 概览&lt;/h2&gt;
&lt;p&gt;当 CPU、内存或 IO 设备争夺激烈的时候，系统会出现负载的延迟峰值、吞吐量下降，并可能触发内核的 &lt;code&gt;OOM Killer&lt;/code&gt;。&lt;strong&gt;PSI(Pressure Stall Information)&lt;/strong&gt; 字面意思就是由于资源（CPU、内存和 IO）压力造成的任务执行停顿。&lt;strong&gt;PSI&lt;/strong&gt; 量化了由于硬件资源紧张造成的任务执行中断，统计了系统中任务等待硬件资源的时间。我们可以用 &lt;strong&gt;PSI&lt;/strong&gt; 作为指标，来衡量硬件资源的压力情况。停顿的时间越长，说明资源面临的压力越大。&lt;/p&gt;
&lt;p&gt;如果持续监控 &lt;code&gt;PSI&lt;/code&gt; 指标并绘制变化曲线图，可以发现吞吐量下降与资源短缺的关系，让用户在资源变得紧张前，采取更主动的措施，例如将任务迁移到其他服务器，杀死低优先级的任务等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PSI&lt;/code&gt; 已经包含在 4.20及以上版本的 Linux 内核中。&lt;/p&gt;
&lt;h2 id=&#34;psi-接口文件&#34;&gt;PSI 接口文件&lt;/h2&gt;
&lt;p&gt;CPU、内存和 IO 的压力信息导出到了 &lt;code&gt;/proc/pressure/&lt;/code&gt; 目录下对应的文件，你可以使用 &lt;code&gt;cat&lt;/code&gt; 命令查询资源的压力统计信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat /proc/pressure/cpu 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;some avg10=0.03 avg60=0.07 avg300=0.06 total=8723835
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat /proc/pressure/io 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;some avg10=0.00 avg60=0.00 avg300=0.00 total=56385169
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;full avg10=0.00 avg60=0.00 avg300=0.00 total=54915860
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat /proc/pressure/memory 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;some avg10=0.00 avg60=0.00 avg300=0.00 total=149158
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;full avg10=0.00 avg60=0.00 avg300=0.00 total=34054
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;内存和 IO 显示了两行指标：&lt;strong&gt;some&lt;/strong&gt; 和 &lt;strong&gt;full&lt;/strong&gt;，CPU 只有一行指标 &lt;strong&gt;some&lt;/strong&gt;。关于 some 和 full 的定义下一节解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;avg&lt;/strong&gt; 给出了任务由于硬件资源不可用而被停顿的时间百分比。&lt;strong&gt;avg10&lt;/strong&gt;、&lt;strong&gt;avg60&lt;/strong&gt;和&lt;strong&gt;avg300&lt;/strong&gt;分别是最近10秒、60秒和300秒的停顿时间百分比。&lt;/p&gt;
&lt;p&gt;例如上面 &lt;code&gt;/proc/pressure/cpu&lt;/code&gt; 的输出，&lt;strong&gt;avg10=0.03&lt;/strong&gt; 意思是任务因为CPU资源的不可用，在最近的10秒内，有0.03%的时间停顿等待 CPU。如果 avg 大于 40 ，也就是有 40% 时间在等待硬件资源，就说明这种资源的压力已经比较大了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;total&lt;/strong&gt; 是任务停顿的总时间，以微秒（microseconds）为单位。通过 total 可以检测出停顿持续太短而无法影响平均值的情况。&lt;/p&gt;
&lt;h2 id=&#34;some-和-full-的定义&#34;&gt;some 和 full 的定义&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;some&lt;/strong&gt; 指标说明一个或多个任务由于等待资源而被停顿的时间百分比。在下图的例子中，在最近的60秒内，任务A的运行没有停顿，而由于内存紧张，任务B在运行过程中花了30秒等待内存，则 some 的值为50%。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241153234.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;someCrop&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;some 表明了由于缺乏资源而造成至少一个任务的停顿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;full&lt;/strong&gt; 指标表示所有的任务由于等待资源而被停顿的时间百分比。在下图的例子中，在最近的60秒内，任务 B 等待了 30 秒的内存，任务 A 等待了 10 秒内存，并且和任务 B 的等待时间重合。在这个重合的时间段10秒内，任务 A 和 任务 B 都在等待内存，结果是 some 指标为 50%，full 指标为 &lt;strong&gt;10/60 = 16.66%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241154595.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;FullCrop&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;full&lt;/strong&gt; 表明了总吞吐量的损失，在这种状态下，所有任务都在等待资源，CPU 周期将被浪费。&lt;/p&gt;
&lt;p&gt;请注意，&lt;strong&gt;some&lt;/strong&gt; 和 &lt;strong&gt;full&lt;/strong&gt; 的计算是用整个时间窗口内累计的等待时间，等待时间可以是连续的，也可能是离散的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241154037.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;DiscontinuousCrop&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;理解了 &lt;strong&gt;some&lt;/strong&gt; 和 &lt;strong&gt;full&lt;/strong&gt; 的含义，就明白了 CPU 为什么没有 &lt;strong&gt;full&lt;/strong&gt; 指标，因为不可能所有的任务都同时饿死在 CPU 上，CPU 总是在执行一个任务。&lt;/p&gt;
&lt;h2 id=&#34;psi-阈值监控&#34;&gt;PSI 阈值监控&lt;/h2&gt;
&lt;p&gt;用户可以向 PSI 注册触发器，在资源压力超过自定义的阈值时获得通知。一个触发器定义了特定时间窗口内最大累积停顿时间，例如，在任何 500ms 的窗口内，累计 100ms 的停顿时间会产生一个通知事件。&lt;/p&gt;
&lt;p&gt;如何向 PSI 注册触发器呢？打开 &lt;code&gt;/proc/pressure/&lt;/code&gt; 目录下资源对应的 PSI 接口文件，写入想要的阈值和时间窗口，然后在打开的文件描述符上使用 &lt;code&gt;select()&lt;/code&gt;、&lt;code&gt;poll()&lt;/code&gt; 或 &lt;code&gt;epoll()&lt;/code&gt; 方法等待通知事件。写入 PSI 接口文件的数据格式为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;some|full&amp;gt; &amp;lt;停顿阈值&amp;gt; &amp;lt;时间窗口&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;阈值和时间窗口的单位都是微秒（us）。内核接受的窗口大小范围为500ms到10秒。&lt;/p&gt;
&lt;p&gt;举个例子，向 &lt;code&gt;/proc/pressure/io&lt;/code&gt; 写入 &amp;ldquo;some 500000 1000000&amp;rdquo;，代表着在任何 1 秒的时间窗口内，如果一个或多个进程因为等待 IO 而造成的时间停顿超过了阈值 500ms，将触发通知事件。&lt;/p&gt;
&lt;p&gt;当用于定义触发器的 PSI 接口文件描述符被关闭时，触发器将被取消注册。&lt;/p&gt;
&lt;p&gt;我们通过一个例子演示触发器的使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;poll.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;trig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;some 500000 1000000&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pollfd&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;fds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/proc/pressure/io&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;O_RDWR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;O_NONBLOCK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/proc/pressure/io open error: %s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                      &lt;span class=&#34;n&#34;&gt;strerror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;errno&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;fds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;POLLPRI&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;trig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;trig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/proc/pressure/io write error: %s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                      &lt;span class=&#34;n&#34;&gt;strerror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;errno&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;waiting for events...&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;poll&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                      &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;poll error: %s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strerror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;errno&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;revents&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;POLLERR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                      &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;got POLLERR, event source is gone&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;revents&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;POLLPRI&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                      &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;event triggered!&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                      &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;unknown event received: 0x%x&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;revents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在服务器上编译并运行该程序，如果当前服务器比较空闲，我们会看到程序一直在等待 IO 压力超过阈值的通知：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ./monitor 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;waiting for events...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们为服务器制造点 IO 压力，生成一个5G大小的文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ dd if=/dev/zero of=/home/mazhen/testfile bs=4096 count=1310720
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;再回到示例程序的运行窗口，会发现已经收到事件触发的通知：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ./monitor 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;waiting for events...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;event triggered!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;event triggered!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;event triggered!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;event triggered!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;event triggered!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;psi-应用案例&#34;&gt;PSI 应用案例&lt;/h2&gt;
&lt;p&gt;Facebook 是因为一些实际的需求开发了 PSI。其中一个案例是为了避免内核 OOM(Out-Of-Memory) killer 的触发。&lt;/p&gt;
&lt;p&gt;应用在申请内存的时候，如果没有足够的 free 内存，可以通过回收 &lt;strong&gt;Page Cache&lt;/strong&gt; 释放内存，如果这时 free 内存还是不够，就会触发内核的 OOM Killer，挑选一个进程 kill 掉释放内存。这个过程是同步的，申请分配内存的进程一直被阻塞等待，而且内核选择 kill 掉哪个进程释放内存，用户不可控。因此，Facebook 开发了用户空间的 OOM Killer 工具 &lt;a class=&#34;link&#34; href=&#34;https://github.com/facebookincubator/oomd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;oomd&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/facebookincubator/oomd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;oomd&lt;/a&gt; 使用 PSI 阈值作为触发器，在内存压力增加到一定程度时，执行指定的动作，避免最终 OOM 的发生。oomd 作为第一道防线，确保服务器工作负载的健康，并能自定义复杂的清除策略，这些都是内核做不到的。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cgroup2&lt;/a&gt; 也支持 group 内任务的 PSI 指标追踪，这样就可以知道容器内 CPU、内存和 IO 的真实压力情况，进行更精细化的容器调度，在资源利用率最大化的同时保证任务的延迟和吞吐量。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>理解Linux 终端、终端模拟器和伪终端</title>
        <link>https://mazhen.tech/p/%E7%90%86%E8%A7%A3linux-%E7%BB%88%E7%AB%AF%E7%BB%88%E7%AB%AF%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%92%8C%E4%BC%AA%E7%BB%88%E7%AB%AF/</link>
        <pubDate>Mon, 12 Jul 2021 11:46:39 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E7%90%86%E8%A7%A3linux-%E7%BB%88%E7%AB%AF%E7%BB%88%E7%AB%AF%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%92%8C%E4%BC%AA%E7%BB%88%E7%AB%AF/</guid>
        <description>&lt;p&gt;你可能听说过 &lt;strong&gt;TTY&lt;/strong&gt; 和 &lt;strong&gt;PTY&lt;/strong&gt; 这些缩写，也在 &lt;code&gt;/dev&lt;/code&gt; 目录下看到过 &lt;code&gt;/dev/tty[n]&lt;/code&gt; 设备，大概知道它们和 Linux 终端的概念有关。可是你清楚 &lt;code&gt;TTY&lt;/code&gt;、&lt;code&gt;PTY&lt;/code&gt; 具体指的是什么，它们有什么区别，以及它们和 &lt;code&gt;shell&lt;/code&gt; 又是什么关系呢？为了理解这些，我们需要先回顾一下历史。&lt;/p&gt;
&lt;h2 id=&#34;回顾历史&#34;&gt;回顾历史&lt;/h2&gt;
&lt;p&gt;在计算机诞生之前，人们发明了 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Teleprinter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Teleprinter(电传打字机)&lt;/a&gt;，通过长长的电线点对点连接，发送和接收打印的信息，用于远距离传输电报信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241147437.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Teleprinter&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Teleprinter&lt;/code&gt; 也可以写成 &lt;code&gt;teletypewriter&lt;/code&gt; 或 &lt;code&gt;teletype&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;后来人们将 &lt;code&gt;Teleprinter&lt;/code&gt; 连接到早期的大型计算机上，作为输入和输出设备，将输入的数据发送到计算机，并打印出响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241148337.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Teleprinter&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在今天你很难想象程序的运行结果需要等到打印出来才能看到，&lt;code&gt;Teleprinter&lt;/code&gt; 设备已经进了计算机博物馆。现在我们用 &lt;strong&gt;TTY&lt;/strong&gt; 代表计算机终端（&lt;strong&gt;terminal&lt;/strong&gt;），只是沿用了历史习惯，电传打字机（&lt;strong&gt;teletypewriter&lt;/strong&gt;）曾经是计算机的终端，它的缩写便是 &lt;strong&gt;TTY&lt;/strong&gt;(&lt;strong&gt;T&lt;/strong&gt;ele&lt;strong&gt;TY&lt;/strong&gt;pewriter)。&lt;/p&gt;
&lt;p&gt;为了把不同型号的电传打字机接入计算机，需要在操作系统内核安装驱动，为上层应用屏蔽所有的低层细节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241149559.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;电传打字机通过两根电缆连接：一根用于向计算机发送指令，一根用于接收计算机的输出。这两根电缆插入 &lt;strong&gt;UART&lt;/strong&gt; （Universal Asynchronous Receiver and Transmitter，通用异步接收和发送器）的串行接口连接到计算机。&lt;/p&gt;
&lt;p&gt;操作系统包含一个 &lt;code&gt;UART&lt;/code&gt; 驱动程序，管理字节的物理传输，包括奇偶校验和流量控制。然后输入的字符序列被传递给 &lt;code&gt;TTY&lt;/code&gt; 驱动，该驱动包含一个 &lt;strong&gt;line discipline&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line discipline&lt;/strong&gt; 负责转换特殊字符（如退格、擦除字、清空行），并将收到的内容回传给电传打字机，以便用户可以看到输入的内容。&lt;strong&gt;line discipline&lt;/strong&gt; 还负责对字符进行缓冲，当按下回车键时，缓冲的数据被传递给与 &lt;code&gt;TTY&lt;/code&gt; 相关的前台用户进程。用户可以并行的执行几个进程，但每次只与一个进程交互，其他进程在后台工作。&lt;/p&gt;
&lt;h2 id=&#34;终端模拟器terminal-emulator&#34;&gt;终端模拟器(terminal emulator)&lt;/h2&gt;
&lt;p&gt;今天电传打字机已经进了博物馆，但 Linux/Unix 仍然保留了当初 TTY驱动和 &lt;strong&gt;line discipline&lt;/strong&gt; 的设计和功能。终端不再是一个需要通过 UART 连接到计算机上物理设备。终端成为内核的一个模块，它可以直接向 TTY 驱动发送字符，并从 TTY 驱动读取响应然后打印到屏幕上。也就是说，用内核模块模拟物理终端设备，因此被称为&lt;strong&gt;终端模拟器&lt;/strong&gt;(terminal emulator)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241149126.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图是一个典型的Linux桌面系统。终端模拟器就像过去的物理终端一样，它监听来自键盘的事件将其发送到 TTY 驱动，并从 TTY 驱动读取响应，通过显卡驱动将结果渲染到显示器上。TTY驱动 和 &lt;strong&gt;line discipline&lt;/strong&gt;的行为与原先一样，但不再有 UART 和 物理终端参与。&lt;/p&gt;
&lt;p&gt;如何看到一个终端模拟器呢？在 &lt;code&gt;Ubuntu 20&lt;/code&gt; 桌面系统上，按 &lt;code&gt;Ctrl+Alt+F3&lt;/code&gt; 就会得到一个由内核模拟的 TTY。Linux上这种模拟的文本终端也被称为&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Terminal_emulator#Virtual_consoles&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;虚拟终端（Virtual consoles）&lt;/a&gt;。每个虚拟终端都由一个特殊的设备文件 &lt;code&gt;/dev/tty[n]&lt;/code&gt; 所表示，与这个虚拟终端的交互，是通过对这个设备文件的读写操作，以及使用&lt;code&gt;ioctl&lt;/code&gt;系统调用操作这个设备文件进行的。通过执行 &lt;code&gt;tty&lt;/code&gt; 命令可以查看代表当前虚拟终端的设备文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ tty
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/dev/tty3
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看到，当前终端的设备文件是 &lt;code&gt;/dev/tty3&lt;/code&gt;，也就是通过 &lt;code&gt;Ctrl+Alt+F3&lt;/code&gt; 得到的虚拟终端。&lt;/p&gt;
&lt;p&gt;你可以通过 &lt;code&gt;Ctrl+Alt+F3&lt;/code&gt; 到 &lt;code&gt;Ctrl+Alt+F6&lt;/code&gt; 在几个虚拟终端之间切换。按 &lt;code&gt;Ctrl+Alt+F2&lt;/code&gt; 回到桌面环境。X 系统也是运行在一个终端模拟器上，在 &lt;code&gt;Ubuntu 20&lt;/code&gt; 上它对应的设备是 &lt;code&gt;/dev/tty2&lt;/code&gt;，这也是为什么使用 &lt;code&gt;Ctrl+Alt+F2&lt;/code&gt; 可以切换到 X 系统的原因。&lt;/p&gt;
&lt;p&gt;我们可以看看 X 系统打开的文件中是否包含了设备文件 &lt;code&gt;/dev/tty2&lt;/code&gt;。先查找 X 系统的 PID：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# ps aux | grep Xorg
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mazhen      1404  0.1  0.6 741884 49996 tty2     Sl+  08:07   0:13 /usr/lib/xorg/Xorg vt2 -displayfd 3 -auth /run/user/1000/gdm/Xauthority -background none -noreset -keeptty -verbose 3
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;再看看这个进程(1404)打开了哪些文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# ll /proc/1404/fd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;总用量 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dr-x------ 2 mazhen mazhen  0 7月  10 08:07 ./
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dr-xr-xr-x 9 mazhen mazhen  0 7月  10 08:07 ../
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ 1 mazhen mazhen 64 7月  10 08:07 0 -&amp;gt; /dev/tty2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ 1 mazhen mazhen 64 7月  10 08:07 1 -&amp;gt; &amp;#39;socket:[39965]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;lrwx------ 1 mazhen mazhen 64 7月  10 10:09 10 -&amp;gt; &amp;#39;socket:[34615]&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看到，X 系统确实打开了 &lt;code&gt;/dev/tty2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再做一个有趣的实验，在 tty3 下以 root 用户身份执行 echo 命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# echo &amp;#34;hello from tty3&amp;#34; &amp;gt; /dev/tty4
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;再按 &lt;code&gt;Ctrl+Alt+F4&lt;/code&gt; 切换到 tty4，能看到从 tty3 发送来的信息。&lt;/p&gt;
&lt;h2 id=&#34;伪终端pseudo-terminal-pty&#34;&gt;伪终端（pseudo terminal, PTY）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;终端模拟器(terminal emulator)&lt;/strong&gt; 是运行在内核的模块，我们也可以让终端模拟程序运行在用户区。运行在用户区的终端模拟程序，就被称为&lt;strong&gt;伪终端（pseudo terminal, PTY）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;PTY 运行在用户区，更加安全和灵活，同时仍然保留了 TTY 驱动和 &lt;strong&gt;line discipline&lt;/strong&gt; 的功能。常用的伪终端有 xterm，gnome-terminal，以及远程终端 ssh。我们以 Ubuntu 桌面版提供的 gnome-terminal 为例，介绍伪终端如何与 TTY 驱动交互。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241149477.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;PTY 是通过打开特殊的设备文件 &lt;code&gt;/dev/ptmx&lt;/code&gt; 创建，由一对双向的字符设备构成，称为 &lt;code&gt;PTY master&lt;/code&gt; 和 &lt;code&gt;PTY slave&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;gnome-terminal 持有 &lt;code&gt;PTY master&lt;/code&gt; 的文件描述符 &lt;code&gt;/dev/ptmx&lt;/code&gt;。
gnome-terminal 负责监听键盘事件，通过&lt;code&gt;PTY master&lt;/code&gt;接收或发送字符到 &lt;code&gt;PTY slave&lt;/code&gt;，还会在屏幕上绘制来自&lt;code&gt;PTY master&lt;/code&gt;的字符输出。&lt;/p&gt;
&lt;p&gt;gnome-terminal 会 fork 一个 shell 子进程，并让 shell 持有 &lt;code&gt;PTY slave&lt;/code&gt; 的设备文件 &lt;code&gt;/dev/pts/[n]&lt;/code&gt;，shell 通过 &lt;code&gt;PTY slave&lt;/code&gt; 接收字符，并输出处理结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PTY master&lt;/code&gt; 和 &lt;code&gt;PTY slave&lt;/code&gt; 之间是 TTY 驱动，会在 master 和 slave 之间复制数据，并进行会话管理和提供 &lt;strong&gt;line discipline&lt;/strong&gt; 功能。&lt;/p&gt;
&lt;p&gt;在 gnome-terminal 中执行 tty 命令，可以看到代表&lt;code&gt;PTY slave&lt;/code&gt;的设备文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ tty
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/dev/pts/0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;执行 &lt;code&gt;ps -l&lt;/code&gt; 命令，也可以确认 shell 关联的伪终端是 &lt;code&gt;pts/0&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ps -l
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0 S  1000    1842    1832  0  80   0 -  3423 do_wai pts/0    00:00:00 bash
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0 R  1000    1897    1842  0  80   0 -  3626 -      pts/0    00:00:00 ps
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;注意到 TTY 这一列指出了当前进程的终端是 &lt;code&gt;pts/0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们以实际的例子，看看在 terminal 执行一个命令的全过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们在桌面启动终端程序 &lt;code&gt;gnome-terminal&lt;/code&gt;，它向操作系统请求一个&lt;code&gt;PTY master&lt;/code&gt;，并把 GUI 绘制在显示器上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gnome-terminal&lt;/code&gt; 启动子进程 &lt;code&gt;bash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bash&lt;/code&gt; 的标准输入、标准输出和标准错误都设置为 &lt;code&gt;PTY slave&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gnome-terminal&lt;/code&gt; 监听键盘事件，并将输入的字符发送到&lt;code&gt;PTY master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;line discipline&lt;/strong&gt; 收到字符，进行缓冲。只有当你按下回车键时，它才会把缓冲的字符复制到&lt;code&gt;PTY slave&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;line discipline&lt;/strong&gt; 在接收到字符的同时，也会把字符写回给&lt;code&gt;PTY master&lt;/code&gt;。&lt;code&gt;gnome-terminal&lt;/code&gt; 只会在屏幕上显示来自 &lt;code&gt;PTY master&lt;/code&gt; 的东西。因此，&lt;strong&gt;line discipline&lt;/strong&gt; 需要回传字符，以便让你看到你刚刚输入的内容。&lt;/li&gt;
&lt;li&gt;当你按下回车键时，TTY 驱动负责将缓冲的数据复制到&lt;code&gt;PTY slave&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;bash 从标准输入读取输入的字符（例如 &lt;code&gt;ls -l&lt;/code&gt; ）。注意，bash 在启动时已经将标准输入被设置为了&lt;code&gt;PTY slave&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;bash 解释从输入读取的字符，发现需要运行 &lt;code&gt;ls&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;bash fork 出 ls 进程。bash fork 出的进程拥有和 bash 相同的标准输入、标准输出和标准错误，也就是&lt;code&gt;PTY slave&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ls 运行，结果打印到标准输出，也就是&lt;code&gt;PTY slave&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TTY 驱动将字符复制到&lt;code&gt;PTY master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gnome-terminal&lt;/code&gt; 循环从 &lt;code&gt;PTY master&lt;/code&gt; 读取字节，绘制到用户界面上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;shell&#34;&gt;Shell&lt;/h2&gt;
&lt;p&gt;我们经常不去区分 terminal 和 Shell，会说打开一个 terminal，或打开一个 Shell。从前面介绍的命令执行过程可以看出，Shell 不处理键盘事件，也不负责字符的显示，这是 terminal 要为它处理好的。&lt;/p&gt;
&lt;p&gt;Shell是用户空间的应用程序，通常由 terminal fork出来，是 terminal 的子进程。Shell用来提示用户输入，解释用户输入的字符，然后处理来自底层操作系统的输出。&lt;/p&gt;
&lt;p&gt;通常我们使用较多的 shell 有 Bash、Zsh 和 sh。&lt;/p&gt;
&lt;h2 id=&#34;配置-tty-设备&#34;&gt;配置 TTY 设备&lt;/h2&gt;
&lt;p&gt;内核将使用 TTY 驱动来处理 terminal 和 Shell 之间的通信。&lt;strong&gt;line discipline&lt;/strong&gt; 是 TTY 驱动的一个逻辑组件。&lt;strong&gt;line discipline&lt;/strong&gt; 主要有以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当用户输入时，字符会被回传到&lt;code&gt;PTY master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;line discipline&lt;/strong&gt; 会在内存中缓冲这些字符。当用户按回车键时，它才将这些字符发送到&lt;code&gt;PTY slave&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;line discipline&lt;/strong&gt; 可以拦截处理一些特殊的功能键，例如：
&lt;ul&gt;
&lt;li&gt;当用户按 &lt;code&gt;CTRL+c&lt;/code&gt; 时，它向连接到 &lt;code&gt;PTY slave&lt;/code&gt; 的进程发送 &lt;code&gt;kill -2（SIGINT）&lt;/code&gt; 信号&lt;/li&gt;
&lt;li&gt;当用户按 &lt;code&gt;CTRL+w&lt;/code&gt; 时，它删除用户输入的最后一个字&lt;/li&gt;
&lt;li&gt;当用户按 &lt;code&gt;CTRL+z&lt;/code&gt; 时，它向连接到 &lt;code&gt;PTY slave&lt;/code&gt; 的进程发送 &lt;code&gt;kill -STOP&lt;/code&gt;信号&lt;/li&gt;
&lt;li&gt;当用户按退格键时，它从缓冲区中删除该字符，并向&lt;code&gt;PTY master&lt;/code&gt;发送删除最后一个字符的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以使用命令行工具 &lt;code&gt;stty&lt;/code&gt; 查询和配置 TTY，包括 &lt;strong&gt;line discipline&lt;/strong&gt; 规则。在 terminal 执行 &lt;code&gt;stty -a&lt;/code&gt; 命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ stty -a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;speed 38400 baud; rows 40; columns 80; line = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &amp;lt;undef&amp;gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;eol2 = &amp;lt;undef&amp;gt;; swtch = &amp;lt;undef&amp;gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-iuclc -ixany -imaxbel iutf8
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;echoctl echoke -flusho -extproc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 标志告诉 &lt;code&gt;stty&lt;/code&gt; 返回所有的设置，包括TTY 的特征和 &lt;strong&gt;line discipline&lt;/strong&gt; 规则。&lt;/p&gt;
&lt;p&gt;让我们看一下第一行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;speed&lt;/strong&gt; 表示波特率。当 terminal 和计算机通过物理线路连接时，speed 后的数字表示物理线路的波特率。波特率对 PTY 来说是没有意义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rows, columns&lt;/strong&gt; 表示 terminal 的行数和列数，以字符为单位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;line&lt;/strong&gt; 表示&lt;strong&gt;line discipline&lt;/strong&gt; 的类型。0 是 &lt;code&gt;N_TTY&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;stty&lt;/code&gt; 能够对 terminal 进行设置，让我们做个简单的测试验证一下。在第一个 terminal 中使用 vi 编辑一个文件。vi 在启动时会查询当前 terminal 的大小，以便 vi 能填满整个窗口。这时候我们在另一个 terminal 中输入：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# stty -F /dev/pts/0 rows 20
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这个命令将终端 &lt;code&gt;pts/0&lt;/code&gt; 的行数设置为原来的一半，这将更新内核中 TTY 的数据结构，并向 vi 发送一个 &lt;code&gt;SIGWINCH&lt;/code&gt; 信号，vi 接收到该信号后将根据 TTY 新的行列数重新绘制自己，这时 vi 就只使用了可用窗口区域的上半部分。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stty -a&lt;/code&gt; 输出的第二行给出了 &lt;strong&gt;line discipline&lt;/strong&gt; 能处理的所有特殊字符，包含了键的绑定。例如 &lt;code&gt;intr = ^C&lt;/code&gt; 是指将 &lt;code&gt;CTRL+c&lt;/code&gt; 映射到 &lt;code&gt;kill -2 (SIGINT)&lt;/code&gt; 信号。你也可以更改这个绑定，例如执行 &lt;code&gt;stty intr o&lt;/code&gt; 命令，将发送 &lt;code&gt;SIGINT&lt;/code&gt; 信号的键从 &lt;code&gt;CTRL+c&lt;/code&gt; 换成了字符 &lt;code&gt;o&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后，&lt;code&gt;stty -a&lt;/code&gt; 列出了一系列 &lt;strong&gt;line discipline&lt;/strong&gt; 规则的开关。&lt;code&gt;-&lt;/code&gt; 表示开关是关闭的，否则开关就是打开的。所有的开关在 &lt;code&gt;man stty&lt;/code&gt;中都有解释。我举其中一个简单的例子，&lt;code&gt;echo&lt;/code&gt; 是指示 &lt;strong&gt;line discipline&lt;/strong&gt; 将字符回传的规则，我们可以执行命令关闭 &lt;code&gt;echo&lt;/code&gt; 规则：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ stty -echo
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这时候你再输入一些东西，屏幕上什么也不会出现。&lt;strong&gt;line discipline&lt;/strong&gt; 不会将字符回传给 &lt;code&gt;PTY master&lt;/code&gt;，因此 terminal 不会再显示我们输入的内容。然而其他一切都照常进行。例如你输入 &lt;code&gt;ls&lt;/code&gt;，在输入时看不到字符 &lt;code&gt;ls&lt;/code&gt;，然后你输入回车后，仍然会看到 &lt;code&gt;ls&lt;/code&gt; 的输出。执行命令恢复 &lt;code&gt;echo&lt;/code&gt; 规则：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ stty echo
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以通过 &lt;code&gt;stty raw&lt;/code&gt; 命令来禁用所有的 &lt;strong&gt;line discipline&lt;/strong&gt; 规则，这样的终端被称为 &lt;code&gt;raw terminal&lt;/code&gt;。像 vi 这样的编辑器会将终端设置为 raw ，因为它需要自己处理字符。后面介绍的远程终端也是需要一个 &lt;code&gt;raw terminal&lt;/code&gt;，同样会禁用所有的 &lt;strong&gt;line discipline&lt;/strong&gt; 规则。&lt;/p&gt;
&lt;h2 id=&#34;远程终端&#34;&gt;远程终端&lt;/h2&gt;
&lt;p&gt;我们经常通过 ssh 连接到一个远程主机，这时候远程主机上的 &lt;code&gt;ssh server&lt;/code&gt; 就是一个伪终端 PTY，它同样持有 &lt;code&gt;PTY master&lt;/code&gt;，但 &lt;code&gt;ssh server&lt;/code&gt; 不再监听键盘事件，以及在屏幕上绘制输出结果，而是通过 TCP 连接，向 &lt;code&gt;ssh client&lt;/code&gt; 发送或接收字符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241150827.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我们简单梳理一下远程终端是如何执行命令的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户在客户端的 terminal 中输入 ssh 命令，经过 &lt;code&gt;PTY master&lt;/code&gt;、TTY 驱动，到达 &lt;code&gt;PTY slave&lt;/code&gt;。bash 的标准输入已经设置为了 &lt;code&gt;PTY slave&lt;/code&gt;，它从标准输入读取字符序列并解释执行，发现需要启动 ssh 客户端，并请求和远程服务器建 TCP 连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器端接收客户端的 TCP 连接请求，向内核申请创建 PTY，获得一对设备文件描述符。让 &lt;code&gt;ssh server&lt;/code&gt; 持有 &lt;code&gt;PTY master&lt;/code&gt;，&lt;code&gt;ssh server&lt;/code&gt; fork 出的子进程 bash 持有 &lt;code&gt;PTY slave&lt;/code&gt;。bash 的标准输入、标准输出和标准错误都设置为了&lt;code&gt;PTY slave&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当用户在客户端的 terminal 中输入命令 &lt;code&gt;ls -l&lt;/code&gt; 和回车键，这些字符经过 &lt;code&gt;PTY master&lt;/code&gt; 到达 TTY 驱动。我们需要禁用客户端 &lt;strong&gt;line discipline&lt;/strong&gt; 的所有规则，也就是说客户端的 &lt;strong&gt;line discipline&lt;/strong&gt; 不会对特殊字符回车键做处理，而是让命令 &lt;code&gt;ls -l&lt;/code&gt; 和回车键一起到达 &lt;code&gt;PTY slave&lt;/code&gt;。&lt;code&gt;ssh client&lt;/code&gt; 从 &lt;code&gt;PTY slave&lt;/code&gt; 读取字符序列，通过网络，发送给 &lt;code&gt;ssh server&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ssh server&lt;/code&gt; 将从 TCP 连接上接收到的字节写入&lt;code&gt;PTY master&lt;/code&gt;。TTY 驱动对字节进行缓冲，直到收到特殊字符回车键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于服务器端的 &lt;strong&gt;line discipline&lt;/strong&gt; 没有禁用 &lt;code&gt;echo&lt;/code&gt; 规则，所以 TTY 驱动还会将收到的字符写回&lt;code&gt;PTY master&lt;/code&gt;，&lt;code&gt;ssh server&lt;/code&gt; 从 &lt;code&gt;PTY master&lt;/code&gt; 读取字符，将这些字符通过 TCP 连接发回客户端。注意，这是发回的字符不是 &lt;code&gt;ls -l&lt;/code&gt; 命令的执行结果，而是 &lt;code&gt;ls -l&lt;/code&gt; 本身的回显，让客户端能看到自己的输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在服务器端 TTY 驱动将字符序列传送给 &lt;code&gt;PTY slave&lt;/code&gt;，bash 从 &lt;code&gt;PTY slave&lt;/code&gt;读取字符，解释并执行命令 &lt;code&gt;ls -l&lt;/code&gt;。bash fork 出 &lt;code&gt;ls&lt;/code&gt; 子进程，该子进程的标准输入、标准输出和标准错误同样设置为了 &lt;code&gt;PTY slave&lt;/code&gt;。&lt;code&gt;ls -l&lt;/code&gt; 命令的执行结果写入标准输出 &lt;code&gt;PTY slave&lt;/code&gt;，然后执行结果通过 TTY 驱动到达 &lt;code&gt;PTY master&lt;/code&gt;，再由 &lt;code&gt;ssh server&lt;/code&gt; 通过 TCP 连接发送给 &lt;code&gt;ssh client&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意在客户端，我们在屏幕上看到的所有字符都来自于远程服务器。包括我们输入的内容，也是远程服务器上的 &lt;strong&gt;line discipline&lt;/strong&gt; 应用 &lt;code&gt;echo&lt;/code&gt; 规则的结果，将这些字符回显了回来。表面看似简单的在远程终端上执行了一条命令，实际上底下确是波涛汹涌。&lt;/p&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;简单回顾总结一下本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电传打字机（TTY）是物理设备，最初是为电报设计的，后来被连接到计算机上，发送输入和获取输出。&lt;/li&gt;
&lt;li&gt;电传打字机（TTY）现在被运行在内核中的模块所模拟，被称为&lt;strong&gt;终端模拟器(terminal emulator)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;伪终端（pseudo terminal, PTY）&lt;/strong&gt; 是运行在用户区的终端模拟程序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shell&lt;/code&gt; 由 &lt;code&gt;terminal&lt;/code&gt; fork 出来，是 &lt;code&gt;terminal&lt;/code&gt; 的子进程。&lt;code&gt;Shell&lt;/code&gt; 不处理键盘事件，也不负责字符的显示，这些是由 &lt;code&gt;terminal&lt;/code&gt; 处理。&lt;code&gt;Shell&lt;/code&gt; 负责解释执行用户输入的字符。&lt;/li&gt;
&lt;li&gt;可以使用 &lt;code&gt;stty&lt;/code&gt; 命令对 TTY 设备进行配置。&lt;/li&gt;
&lt;li&gt;远程终端 &lt;code&gt;ssh&lt;/code&gt; 也是一种&lt;strong&gt;伪终端 PTY&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相信通过这篇文章，你已经能够理解终端、终端模拟器和伪终端的区别和联系。如果想进一步探究低层实现，可以阅读 TTY 驱动的源码 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/master/drivers/tty/tty_io.c&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;drivers/tty/tty_io.c&lt;/a&gt;和 &lt;code&gt;line discipline&lt;/code&gt; 的源码 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/master/drivers/tty/n_tty.c&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;drivers/tty/n_tty.c&lt;/a&gt;。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>从Ftrace开始内核探索之旅</title>
        <link>https://mazhen.tech/p/%E4%BB%8Eftrace%E5%BC%80%E5%A7%8B%E5%86%85%E6%A0%B8%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85/</link>
        <pubDate>Mon, 21 Jun 2021 11:44:02 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E4%BB%8Eftrace%E5%BC%80%E5%A7%8B%E5%86%85%E6%A0%B8%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85/</guid>
        <description>&lt;p&gt;操作系统内核对应用开发工程师来说就像一个黑盒，似乎很难窥探到其内部的运行机制。其实Linux内核很早就内置了一个强大的tracing工具：&lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/trace/ftrace.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ftrace&lt;/a&gt;，它几乎可以跟踪内核的所有函数，不仅可以用于调试和分析，还可以用于观察学习Linux内核的内部运行。虽然&lt;code&gt;Ftrace&lt;/code&gt;在&lt;a class=&#34;link&#34; href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=16444a8a40d4c7b4f6de34af0cae1f76a4f6c901&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2008年就加入了内核&lt;/a&gt;，但很多应用开发工程师仍然不知道它的存在。本文就给你介绍一下&lt;code&gt;Ftrace&lt;/code&gt;的基本使用。&lt;/p&gt;
&lt;h2 id=&#34;ftrace初体验&#34;&gt;Ftrace初体验&lt;/h2&gt;
&lt;p&gt;先用一个例子体验一下&lt;code&gt;Ftrace&lt;/code&gt;的使用简单，且功能强大。使用 root 用户进入&lt;code&gt;/sys/kernel/debug/tracing&lt;/code&gt;目录，执行 &lt;code&gt;echo&lt;/code&gt; 和 &lt;code&gt;cat&lt;/code&gt; 命令：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;我们使用&lt;code&gt;Ftrace&lt;/code&gt;的&lt;code&gt;function_graph&lt;/code&gt;功能显示了内核函数 &lt;code&gt;_do_fork()&lt;/code&gt; 所有子函数调用。左边的第一列是执行函数的 CPU，第二列 &lt;code&gt;DURATION&lt;/code&gt; 显示在相应函数中花费的时间。我们注意到最后一行的耗时之前有个 &lt;code&gt;+&lt;/code&gt; 号，提示用户注意延迟高的函数。&lt;code&gt;+&lt;/code&gt; 代表耗时大于 &lt;code&gt;10 μs&lt;/code&gt;。如果耗时大于 &lt;code&gt;100 μs&lt;/code&gt;，则显示 &lt;code&gt;!&lt;/code&gt; 号。&lt;/p&gt;
&lt;p&gt;我们知道，&lt;code&gt;fork&lt;/code&gt; 是建立父进程的一个完整副本，然后作为子进程执行。那么&lt;code&gt;_do_fork()&lt;/code&gt;的第一件大事就是调用 &lt;code&gt;copy_process()&lt;/code&gt; 复制父进程的数据结构，从上面输出的调用链信息也验证了这一点。&lt;/p&gt;
&lt;p&gt;使用完后执行下面的命令关闭&lt;code&gt;function_graph&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# echo nop &amp;gt; current_tracer
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# echo &amp;gt; set_graph_function
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用 &lt;code&gt;Ftrace&lt;/code&gt; 的 &lt;code&gt;function_graph&lt;/code&gt; 功能，可以查看内核函数的子函数调用链，帮助我们理解复杂的代码流程，而这只是 &lt;code&gt;Ftrace&lt;/code&gt; 的功能之一。这么强大的功能，我们不必安装额外的用户空间工具，只要使用 &lt;code&gt;echo&lt;/code&gt; 和 &lt;code&gt;cat&lt;/code&gt; 命令访问特定的文件就能实现。&lt;code&gt;Ftrace&lt;/code&gt; 对用户的使用接口正是&lt;strong&gt;tracefs&lt;/strong&gt;文件系统。&lt;/p&gt;
&lt;h2 id=&#34;tracefs-文件系统&#34;&gt;tracefs 文件系统&lt;/h2&gt;
&lt;p&gt;用户通过&lt;strong&gt;tracefs&lt;/strong&gt;文件系统使用&lt;code&gt;Ftrace&lt;/code&gt;，这很符合一切皆文件的Linux哲学。&lt;strong&gt;tracefs&lt;/strong&gt;文件系统一般挂载在&lt;code&gt;/sys/kernel/tracing&lt;/code&gt;目录。由于&lt;code&gt;Ftrace&lt;/code&gt;最初是&lt;code&gt;debugfs&lt;/code&gt;文件系统的一部分，后来才被拆分为自己的&lt;code&gt;tracefs&lt;/code&gt;。所以如果系统已经挂载了&lt;code&gt;debugfs&lt;/code&gt;，那么仍然会保留原来的目录结构，将&lt;code&gt;tracefs&lt;/code&gt;挂载到&lt;code&gt;debugfs&lt;/code&gt;的子目录下。我们可以使用 &lt;code&gt;mount&lt;/code&gt; 命令查看当前系统&lt;code&gt;debugfs&lt;/code&gt;和&lt;code&gt;tracefs&lt;/code&gt;挂载点：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# mount -t debugfs,tracefs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;debugfs on /sys/kernel/debug type debugfs (rw,nosuid,nodev,noexec,relatime)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tracefs on /sys/kernel/tracing type tracefs (rw,nosuid,nodev,noexec,relatime)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tracefs on /sys/kernel/debug/tracing type tracefs (rw,nosuid,nodev,noexec,relatime)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我使用的系统是&lt;code&gt;Ubuntu 20.04.2 LTS&lt;/code&gt;，可以看到，为了保持兼容，&lt;code&gt;tracefs&lt;/code&gt;同时挂载到了&lt;code&gt;/sys/kernel/tracing&lt;/code&gt;和&lt;code&gt;/sys/kernel/debug/tracing&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tracefs&lt;/code&gt;下的文件主要分两类：控制文件和输出文件。这些文件的名字都很直观，像前面例子通过 &lt;code&gt;current_tracer&lt;/code&gt; 设置当前要使用的 tracer，然后从 &lt;code&gt;trace&lt;/code&gt;中读取结果。还有像 &lt;code&gt;available_tracers&lt;/code&gt; 包含了当前内核可用的 tracer，可以设置 &lt;code&gt;trace_options&lt;/code&gt; 自定义输出。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;本文后面的示例假定你已经处在了&lt;code&gt;/sys/kernel/tracing&lt;/code&gt;或&lt;code&gt;/sys/kernel/debug/tracing&lt;/code&gt;目录下。&lt;/p&gt;
&lt;h2 id=&#34;函数跟踪&#34;&gt;函数跟踪&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Ftrace&lt;/code&gt; 实际上代表的就是&lt;code&gt;function trace&lt;/code&gt;（函数跟踪），因此函数追踪是&lt;code&gt;Ftrace&lt;/code&gt;最初的一个主要功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ftrace&lt;/code&gt; 可以跟踪几乎所有内核函数调用的详细信息，这是怎么做到的呢？简单来说，在编译内核的时候使用了 &lt;code&gt;gcc&lt;/code&gt; 的 &lt;code&gt;-pg&lt;/code&gt; 选项，编译器会在每个内核函数的入口处调用一个特殊的汇编函数“&lt;strong&gt;mcount&lt;/strong&gt;” 或 “&lt;strong&gt;__fentry__&lt;/strong&gt;”，如果跟踪功能被打开，&lt;code&gt;mcount/fentry&lt;/code&gt; 会调用当前设置的 &lt;code&gt;tracer&lt;/code&gt;，&lt;code&gt;tracer&lt;/code&gt;将不同的数据写入&lt;strong&gt;ring buffer&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241145662.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ftrace&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，&lt;code&gt;Ftrace&lt;/code&gt; 提供的 &lt;code&gt;function hooks&lt;/code&gt; 机制在内核函数入口处埋点，根据配置调用特定的 &lt;code&gt;tracer&lt;/code&gt;， &lt;code&gt;tracer&lt;/code&gt;将数据写入&lt;strong&gt;ring buffer&lt;/strong&gt;。&lt;code&gt;Ftrace&lt;/code&gt;实现了一个无锁的&lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/trace/ring-buffer-design.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ring buffer&lt;/a&gt;，所有的跟踪信息都存储在&lt;strong&gt;ring buffer&lt;/strong&gt;中。用户通过 &lt;code&gt;tracefs&lt;/code&gt; 文件系统接口访问函数跟踪的输出结果。&lt;/p&gt;
&lt;p&gt;你可能已经意识到，如果每个内核函数入口都加入跟踪代码，必然会非常影响内核的性能，幸好&lt;code&gt;Ftrace&lt;/code&gt;支持动态跟踪功能。如果启用了&lt;strong&gt;CONFIG_DYNAMIC_FTRACE&lt;/strong&gt;选项，编译内核时所有的&lt;code&gt;mcount/fentry&lt;/code&gt;调用点都会被收集记录。在内核的初始化启动过程中，会根据编译期记录的列表，将&lt;code&gt;mcount/fentry&lt;/code&gt;调用点替换为&lt;strong&gt;NOP&lt;/strong&gt;指令。&lt;strong&gt;NOP&lt;/strong&gt;就是 &lt;code&gt;no-operation&lt;/code&gt;，不做任何事，直接转到下一条指令。因此在没有开启跟踪功能的情况下，&lt;code&gt;Ftrace&lt;/code&gt;不会对内核性能产生任何影响。在开启追踪功能时，&lt;code&gt;Ftrace&lt;/code&gt;才会将&lt;strong&gt;NOP&lt;/strong&gt;指令替换为&lt;code&gt;mcount/fentry&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;启用函数追踪功能，只需要将 &lt;code&gt;current_tracer&lt;/code&gt; 文件的内容设置为 &amp;ldquo;function&amp;rdquo;：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;文件头已经很好的解释了每一列的含义。前两项是被追踪的任务名称和 PID，大括号内是执行跟踪的CPU。&lt;code&gt;TIMESTAMP&lt;/code&gt; 是启动后的时间，后面是被追踪的函数，它的调用者在 &lt;code&gt;&amp;lt;-&lt;/code&gt; 之后。&lt;/p&gt;
&lt;p&gt;我们可以设置 &lt;code&gt;set_ftrace_filter&lt;/code&gt; 选择想要跟踪的函数：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;code&gt;trace_pipe&lt;/code&gt; 包含了与 &lt;code&gt;trace&lt;/code&gt; 相同的输出，从这个文件的读取会返回一个无尽的事件流，它也会消耗事件，所以在读取一次后，它们就不再在跟踪缓冲区中了。&lt;/p&gt;
&lt;p&gt;也许你只想跟踪一个特定的进程，可以通过设置 &lt;code&gt;set_ftrace_pid&lt;/code&gt; 内容为PID指定想追踪的特定进程。让 tracer 只追踪PID列在这个文件中的线程：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如果设置了 &lt;code&gt;function-fork&lt;/code&gt; 选项，那么当一个 PID 被列在 &lt;code&gt;set_ftrace_pid&lt;/code&gt; 这个文件中时，其子任务的 PID 将被自动添加到这个文件中，并且子任务也将被 tracer 追踪。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;取消&lt;code&gt;function-fork&lt;/code&gt; 选项：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;取消 &lt;code&gt;set_ftrace_pid&lt;/code&gt; 的设置：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;ftrace-function_graph&#34;&gt;Ftrace function_graph&lt;/h2&gt;
&lt;p&gt;文章开始例子已经展示过，&lt;code&gt;function_graph&lt;/code&gt; 可以打印出函数的调用图，揭示代码的流程。&lt;code&gt;function_graph&lt;/code&gt; 不仅跟踪函数的输入，而且跟踪函数的返回，这使得 tracer 能够知道被调用的函数的深度。&lt;code&gt;function_graph&lt;/code&gt; 可以让人更容易跟踪内核的执行流程。&lt;/p&gt;
&lt;p&gt;我们再看一个例子：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;前面提到过，函数耗时大于 10 μs，前面会有 + 号提醒用户注意，其他的符号还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;$&lt;/strong&gt; ：延迟大于1秒&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@&lt;/strong&gt; ：延迟大于 100 ms&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;*&lt;/strong&gt; ：延迟大于 10 ms&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;#&lt;/strong&gt; ：延迟大于 1 ms&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;!&lt;/strong&gt; ：延迟大于 100 μs&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;+&lt;/strong&gt; ：延迟大于 10 μs&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数profiler&#34;&gt;函数Profiler&lt;/h2&gt;
&lt;p&gt;函数Profiler提供了内核函数调用的统计数据，可以观察哪些内核函数正在被使用，并能发现哪些函数的执行耗时最长。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;这里有一个要注意的地方，确保使用的是 &lt;code&gt;0 &amp;gt;&lt;/code&gt;，而不是 &lt;code&gt;0&amp;gt;&lt;/code&gt;。这两者的含义不一样，&lt;code&gt;0&amp;gt;&lt;/code&gt;是对文件描述符 &lt;code&gt;0&lt;/code&gt; 的重定向。同样要避免使用 &lt;code&gt;1&amp;gt;&lt;/code&gt;，因为这是对文件描述符 &lt;code&gt;1&lt;/code&gt; 的重定向。&lt;/p&gt;
&lt;p&gt;现在可以从 &lt;code&gt;trace_stat&lt;/code&gt; 目录中读取 profile 的统计数据。在这个目录中，profile 数据按照 CPU 保存在名为 function[n] 文件中。我使用的4核CPU，看一下profile 结果：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;第一行是每一列的名称，分别是函数名称（Function），调用次数（Hit），函数的总时间（Time）、平均函数时间（Avg）和标准差（s^2）。输出结果显示，&lt;code&gt;tcp_sendmsg()&lt;/code&gt; 在3个 CPU 上都是最频繁的，&lt;code&gt;tcp_v4_rcv()&lt;/code&gt; 在 CPU2 上被调用了1618次，平均延迟为 &lt;code&gt;17.218 us&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后要注意一点，在使用 Ftrace Profiler 时，尽量通过 &lt;code&gt;set_ftrace_filter&lt;/code&gt; 限制 profile 的范围，避免对所有的内核函数都进行 profile。&lt;/p&gt;
&lt;h2 id=&#34;追踪点-tracepoints&#34;&gt;追踪点 Tracepoints&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Tracepoints&lt;/strong&gt;是内核的静态埋点。内核维护者在他认为重要的位置放置静态 tracepoints 记录上下文信息，方便后续排查问题。例如系统调用的开始和结束，中断被触发，网络数据包发送等等。&lt;/p&gt;
&lt;p&gt;在Linux的早期，内核维护者就一直想在内核中加入静态 tracepoints，尝试过各种策略。Ftrace 创造了&lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/trace/events.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Event Tracing&lt;/a&gt; 基础设施，让开发者使用 &lt;a class=&#34;link&#34; href=&#34;https://lwn.net/Articles/379903/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TRACE_EVENT() 宏添加内核 tracepoints&lt;/a&gt;，不用创建自定义内核模块，使用 &lt;code&gt;Event Tracing&lt;/code&gt; 基础设施来注册埋点函数。&lt;/p&gt;
&lt;p&gt;现在内核中的&lt;strong&gt;Tracepoints&lt;/strong&gt;都使用了 &lt;code&gt;TRACE_EVENT()&lt;/code&gt; 宏来定义，tracepoints 记录的上下文信息作为 &lt;strong&gt;Trace events&lt;/strong&gt; 进入 &lt;code&gt;Event Tracing&lt;/code&gt; 基础设施，这样我们就可以复用 Ftrace 的 tracefs ，通过文件接口来配置 tracepoint events，并使用 trace 或 trace_pipe 文件查看事件输出。&lt;/p&gt;
&lt;p&gt;所有的 tracepoint events 的控制文件都在 events 目录下，按照类别以子目录形式组织：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;我们以 &lt;code&gt;events/sched/sched_process_fork&lt;/code&gt; 事件为例，该事件是在 &lt;code&gt;include/trace/events/sched.h&lt;/code&gt; 中由 &lt;code&gt;TRACE_EVENT&lt;/code&gt; 宏所&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/bcf876870b95592b52519ed4aafcf9d95999bc9c/include/trace/events/sched.h#L287&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;定义&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * Tracepoint for do_fork:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;TRACE_EVENT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sched_process_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;TP_PROTO&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;TP_ARGS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;TRACE_EVENT&lt;/code&gt; 宏会根据事件名称 &lt;code&gt;sched_process_fork&lt;/code&gt; 生成 tracepoint 方法 &lt;code&gt;trace_sched_process_fork()&lt;/code&gt;。你会在 &lt;code&gt;kernel/fork.c&lt;/code&gt; 的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/bcf876870b95592b52519ed4aafcf9d95999bc9c/kernel/fork.c#L2453&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;_do_fork()&lt;/a&gt; 中看到调用这个 tracepoint 方法。&lt;code&gt;_do_fork()&lt;/code&gt; 是进程 fork 的主流程，在这里放置 tracepoint 是一个合适的位置，&lt;code&gt;trace_sched_process_fork(current, p)&lt;/code&gt; 记录当前进程和 fork 出的子进程信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *  Ok, this is the main fork-routine.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * It copies the process, and if successful kick-starts
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * it and waits for it to finish using the VM if required.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * args-&amp;gt;exit_signal is expected to be checked for sanity by the caller.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_do_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel_clone_args&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;copy_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;trace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NUMA_NO_NODE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;add_latent_entropy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;	 * Do this prior waking up the new thread - the thread pointer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;	 * might get invalid after that point, if the thread exits quickly.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;	 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;trace_sched_process_fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_task_pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PIDTYPE_PID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;events/sched/sched_process_fork&lt;/code&gt; 目录下，有这个事件的控制文件：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;我们演示如何通过 &lt;code&gt;enable&lt;/code&gt; 文件开启和关闭这个 tracepoint 事件：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;前五列分别是进程名称，PID，CPU ID，irqs-off 等标志位，timestamp 和 tracepoint 事件名称。其余部分是 tracepoint 格式字符串，包含当前这个 tracepoint 记录的重要信息。格式字符串可以在 &lt;code&gt;events/sched/sched_process_fork/format&lt;/code&gt; 文件中查看：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;通过这个 format 文件，我们可以了解这个 tracepoint 事件每个字段的含义。&lt;/p&gt;
&lt;p&gt;我们再演示一个使用 &lt;code&gt;trigger&lt;/code&gt; 控制文件的例子：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;这个例子使用了 hist triggers，通过 sched_process_fork 事件来统计 _do_fork 的次数，并按照进程ID生成直方图。输出显示了 PID 24493 在追踪期间 fork 了24个子进程，最后几行显示了统计数据。&lt;/p&gt;
&lt;p&gt;关于 Hist Triggers 的详细介绍可以参考文档 &lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/trace/histogram.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Event Histograms&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我的系统内核版本是 &lt;code&gt;5.8.0-59-generic&lt;/code&gt;，当前可用的 tracepoints events 有2547个：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/html/latest/trace/events.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Event Tracing&lt;/a&gt; 基础设施应该是 Ftrace 的另一大贡献，它提供的 &lt;code&gt;TRACE_EVENT&lt;/code&gt; 宏统一了内核 tracepoint 的实现方式，为 tracepoint events 提供了基础支持。&lt;a class=&#34;link&#34; href=&#34;https://perf.wiki.kernel.org/index.php/Main_Page&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;perf&lt;/a&gt; 的 tracepoint events 也是基于 Ftrace 实现的。&lt;/p&gt;
&lt;h2 id=&#34;利用-tracepoints-理解内核代码&#34;&gt;利用 Tracepoints 理解内核代码&lt;/h2&gt;
&lt;p&gt;由于 tracepoints 是内核维护者在流程重要位置设置的埋点，因此我们可以从 tracepoints 入手来学习内核代码。所有的 tracepoints 都定义在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/tree/master/include/trace/events&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;include/trace/events/&lt;/a&gt; 目录下的头文件中，例如进程调度相关的 tracepoints 定义在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/master/include/trace/events/sched.h&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;include/trace/events/sched.h&lt;/a&gt;中，我们以 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/bcf876870b95592b52519ed4aafcf9d95999bc9c/include/trace/events/sched.h#L138&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;sched_switch&lt;/a&gt; 为例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * Tracepoint for task switches, performed by the scheduler:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;TRACE_EVENT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sched_switch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;TP_PROTO&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preempt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		 &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		 &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;TP_ARGS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;preempt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;TRACE_EVENT&lt;/code&gt; 宏会根据事件名称 &lt;code&gt;sched_switch&lt;/code&gt; 生成 tracepoint 方法 &lt;code&gt;trace_sched_switch()&lt;/code&gt;，在源码中查找该方法，发现在 &lt;code&gt;kernel/sched/core.c&lt;/code&gt; 的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/blob/bcf876870b95592b52519ed4aafcf9d95999bc9c/kernel/sched/core.c#L4216&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;__schedule()&lt;/a&gt;中调用了&lt;code&gt;trace_sched_switch()&lt;/code&gt; ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * __schedule() is the main scheduler function.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__sched&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;notrace&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;__schedule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preempt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;likely&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;rq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nr_switches&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;trace_sched_switch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;preempt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;balance_callback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样我们就找到了 scheduler 的主流程，可以从这里开始阅读进程调度的源码。&lt;/p&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;Ftrace 就包含在内核源码中 &lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/tree/master/kernel/trace&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;kernel/trace&lt;/a&gt;，理解了 Ftrace 内核不再是黑箱，你会有豁然开朗的感觉，内核源码忽然有条理了起来。让我们从 Ftrace 开始内核探索之旅吧。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>使用GDB调试Linux内核</title>
        <link>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95linux%E5%86%85%E6%A0%B8/</link>
        <pubDate>Fri, 21 May 2021 11:37:22 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95linux%E5%86%85%E6%A0%B8/</guid>
        <description>&lt;p&gt;&lt;strong&gt;GDB&lt;/strong&gt;（GNU Debugger）是Linux上的调试程序，可用于&lt;code&gt;C/C++&lt;/code&gt;、&lt;code&gt;Go&lt;/code&gt;、&lt;code&gt;Rust&lt;/code&gt;等多种语言。&lt;strong&gt;GDB&lt;/strong&gt;可以让你在被调试程序执行时看到它的”内部“情况，观察程序在特定断点上的状态，并逐行运行代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GDB&lt;/strong&gt;还提供了“远程”模式，使用&lt;strong&gt;GDB协议&lt;/strong&gt;通过网络或串行设备与被调试程序进行通信。程序需要链接&lt;strong&gt;GDB&lt;/strong&gt;提供的&lt;strong&gt;stub&lt;/strong&gt;，这个&lt;strong&gt;stub&lt;/strong&gt;实现了&lt;strong&gt;GDB协议&lt;/strong&gt;。或者可以使用&lt;code&gt;GDBserver&lt;/code&gt;，这时程序不需要进行任何更改。&lt;/p&gt;
&lt;p&gt;类似的，Linux内核开发者可以使用&lt;strong&gt;GDB&lt;/strong&gt;的远程模式，与调试应用程序几乎相同的方式来调试Linux内核。&lt;strong&gt;KGDB&lt;/strong&gt;是Linux内核的源代码级调试器，你可以使用&lt;strong&gt;GDB&lt;/strong&gt;作为&lt;strong&gt;KGDB&lt;/strong&gt;的前端，在我们熟悉且功能强大的&lt;strong&gt;GDB&lt;/strong&gt;调试界面中调试内核。&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;KGDB&lt;/strong&gt;需要两台机器，一台作为开发机，另一台是目标机器，要调试的内核在目标机器上运行。在开发机上使用&lt;code&gt;gdb&lt;/code&gt;运行包含符号信息的&lt;code&gt;vmlinux&lt;/code&gt;，然后通过指定网络地址和端口，连接到目标机器的&lt;strong&gt;KGDB&lt;/strong&gt;。我们也可以使用&lt;a class=&#34;link&#34; href=&#34;https://www.qemu.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;QEMU/KVM&lt;/a&gt;虚拟机作为目标机器，让待调试的内核运行在虚拟机中，然后在宿主机上运行&lt;code&gt;gdb&lt;/code&gt;，连接到虚拟机中的&lt;strong&gt;KGDB&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241138851.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;kgdb.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍如何在本机搭建Linux内核调试环境，步骤比较繁琐，还会涉及到编译内核。作为内核小白，我会尽量写的详细些，毕竟我折腾了很久才成功。&lt;/p&gt;
&lt;h2 id=&#34;本机环境&#34;&gt;本机环境&lt;/h2&gt;
&lt;p&gt;我使用的&lt;code&gt;Ubuntu 20.04.2 LTS&lt;/code&gt;，&lt;code&gt;gdb&lt;/code&gt;版本为9.2。&lt;/p&gt;
&lt;h2 id=&#34;安装qemukvm和virsh&#34;&gt;安装QEMU/KVM和Virsh&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Virsh&lt;/strong&gt;是&lt;code&gt;Virtual Shell&lt;/code&gt;的缩写，是一个用于管理虚拟机的命令行工具。你可以使用&lt;strong&gt;Virsh&lt;/strong&gt;创建、编辑、启动、停止、关闭和删除&lt;strong&gt;VM&lt;/strong&gt;。&lt;strong&gt;Virsh&lt;/strong&gt;目前支持&lt;code&gt;KVM&lt;/code&gt;，&lt;code&gt;LXC&lt;/code&gt;，&lt;code&gt;Xen&lt;/code&gt;，&lt;code&gt;QEMU&lt;/code&gt;，&lt;code&gt;OpenVZ&lt;/code&gt;，&lt;code&gt;VirtualBox&lt;/code&gt;和&lt;code&gt;VMware ESX&lt;/code&gt;。这里我们使用&lt;strong&gt;Virsh&lt;/strong&gt;管理&lt;strong&gt;QEMU/KVM&lt;/strong&gt;虚拟机。&lt;/p&gt;
&lt;p&gt;在安装之前，首先要确认你的&lt;code&gt;CPU&lt;/code&gt;是否支持虚拟化技术。使用&lt;code&gt;grep&lt;/code&gt;查看&lt;code&gt;cpuinfo&lt;/code&gt;是否有&amp;quot;&lt;strong&gt;vmx&lt;/strong&gt;&amp;quot;(Intel-VT 技术)或&amp;quot;&lt;strong&gt;svm&lt;/strong&gt;&amp;quot;(AMD-V 支持)输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;egrep &amp;#34;(svm|vmx)&amp;#34; /proc/cpuinfo
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;某些&lt;code&gt;CPU&lt;/code&gt;型号在默认情况下，&lt;code&gt;BIOS&lt;/code&gt;中可能禁用了&lt;code&gt;VT&lt;/code&gt;支持。我们需要再检查&lt;code&gt;BIOS&lt;/code&gt;设置是否启用了&lt;code&gt;VT&lt;/code&gt;的支持。使用&lt;strong&gt;kvm-ok&lt;/strong&gt;命令进行检查：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo apt install cpu-checker
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kvm-ok
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果输出为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;INFO: /dev/kvm exists
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;KVM acceleration can be used
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;证明&lt;code&gt;CPU&lt;/code&gt;的虚拟化支持已经在&lt;code&gt;BIOS&lt;/code&gt;中启用。&lt;/p&gt;
&lt;p&gt;运行下面的命令安装&lt;strong&gt;QEMU/KVM&lt;/strong&gt;和&lt;strong&gt;Virsh&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;检查&lt;code&gt;libvirt&lt;/code&gt;守护程序是否已经启动：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo systemctl is-active libvirtd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;active
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果没有输出&lt;strong&gt;active&lt;/strong&gt;，运行下面的命令启动&lt;code&gt;libvertd&lt;/code&gt;服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo systemctl enable libvirtd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo systemctl start libvirtd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;创建虚拟机镜像&#34;&gt;创建虚拟机镜像&lt;/h2&gt;
&lt;p&gt;创建一个虚拟机镜像，大小为40G，&lt;strong&gt;qcow2&lt;/strong&gt; 格式为动态分配磁盘占用空间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;qemu-img create -f qcow2 ubuntutest.img 40G
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;创建虚拟机安装操作系统&#34;&gt;创建虚拟机，安装操作系统&lt;/h2&gt;
&lt;p&gt;使用下面的命令启动虚拟机，&lt;strong&gt;-cdrom&lt;/strong&gt;参数为虚拟机挂载了&lt;code&gt;Ubuntu&lt;/code&gt;的安装光盘：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;qemu-system-x86_64 -enable-kvm -name ubuntutest  -m 4096 -hda ubuntutest.img -cdrom ubuntu-20.04.2-live-server-amd64.iso -boot d -vnc :19
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们使用&lt;code&gt;VNC&lt;/code&gt;客户端连接进虚拟机，完成&lt;code&gt;Ubuntu&lt;/code&gt;的安装。注意上面的命令通过&lt;code&gt;-vnc :19&lt;/code&gt;设置了虚拟机的VNC监听端口为&lt;code&gt;5919&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241139692.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;connection.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241140106.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;vnc-viewer.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我使用的&lt;code&gt;VNC&lt;/code&gt;客户端是&lt;a class=&#34;link&#34; href=&#34;https://www.realvnc.com/en/connect/download/viewer/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;VNC Viewer&lt;/a&gt;，支持Windows、macOS和Linux等主流平台。按照正常步骤，完成Ubuntu在虚拟机上的安装。&lt;/p&gt;
&lt;p&gt;安装完成后，可以用&lt;code&gt;ctrl+c&lt;/code&gt;退出&lt;code&gt;qemu-system-x86_64&lt;/code&gt;命令的执行来停止虚拟机。再次启动虚拟机，需要把 &lt;strong&gt;-cdrom&lt;/strong&gt; 参数去掉。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;qemu-system-x86_64 -enable-kvm -name ubuntutest  -m 4096 -hda ubuntutest.img -boot d -vnc :19
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;配置虚拟机网络&#34;&gt;配置虚拟机网络&lt;/h2&gt;
&lt;p&gt;为了让虚拟机能访问外部网络，我们需要形成下面的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241140591.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;networking.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在宿主机上创建网桥&lt;strong&gt;br0&lt;/strong&gt;，并设置一个IP地址：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo brctl addbr br0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link set br0 up
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ifconfig br0 192.168.57.1/24
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;编辑宿主机的&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;文件，设置IP转发生效：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;net.ipv4.ip_forward=1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用&lt;strong&gt;sysctl -p&lt;/strong&gt;重新加载&lt;code&gt;sysctl.conf&lt;/code&gt;配置使其生效。&lt;/p&gt;
&lt;p&gt;在宿主机上增加&lt;strong&gt;SNAT&lt;/strong&gt;规则。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo iptables -t nat -A POSTROUTING -o wlp2s0 -j MASQUERADE
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;虚拟机的&lt;code&gt;IP&lt;/code&gt;地址外部并不认识，如果它要访问外网，需要在数据包离开前将源地址替换为宿主机的IP，这样外部主机才能用宿主机的IP作为目的地址发回响应。&lt;/p&gt;
&lt;p&gt;上面的命令的含义是：在&lt;code&gt;nat&lt;/code&gt;表的&lt;code&gt;POSTROUTING&lt;/code&gt;链增加规则，出口设备为&lt;code&gt;wlp2s0&lt;/code&gt;时，就执行&lt;code&gt;MASQUERADE&lt;/code&gt;动作。&lt;code&gt;MASQUERADE&lt;/code&gt;是一种源地址转换动作，它会动态选择宿主机的一个&lt;code&gt;IP&lt;/code&gt;做源地址转换。&lt;/p&gt;
&lt;p&gt;注意上面命令中的 &lt;strong&gt;-o&lt;/strong&gt; 参数，指定了数据包的出口设备为&lt;strong&gt;wlp2s0&lt;/strong&gt;。你需要使用&lt;code&gt;ip link&lt;/code&gt;命令在你的机器上查看具体设备的名称：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241141409.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ip_link.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果想进一步了解&lt;strong&gt;iptables&lt;/strong&gt;，可以参见我的另一篇文章&lt;a class=&#34;link&#34; href=&#34;https://mazhen.tech/docker-network-bridge/&#34; &gt;《Docker单机网络模型动手实验》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;接着我们需要将虚拟机的网卡连接到网桥&lt;strong&gt;br0&lt;/strong&gt;。后面我们使用&lt;strong&gt;libvirt&lt;/strong&gt;来管理&lt;strong&gt;QEMU/KVM&lt;/strong&gt;虚拟机，这样可以把虚拟机的配置参数记录在XML文件中，易于维护。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;domain type=&amp;#39;kvm&amp;#39; xmlns:qemu=&amp;#39;http://libvirt.org/schemas/domain/qemu/1.0&amp;#39;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;name&amp;gt;ubuntutest&amp;lt;/name&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;uuid&amp;gt;0f0806ab-531d-6134-5def-c5b4955292aa&amp;lt;/uuid&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;memory unit=&amp;#39;GiB&amp;#39;&amp;gt;4&amp;lt;/memory&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;currentMemory unit=&amp;#39;GiB&amp;#39;&amp;gt;4&amp;lt;/currentMemory&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;vcpu placement=&amp;#39;static&amp;#39;&amp;gt;2&amp;lt;/vcpu&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;os&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;type arch=&amp;#39;x86_64&amp;#39; machine=&amp;#39;pc-i440fx-trusty&amp;#39;&amp;gt;hvm&amp;lt;/type&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;boot dev=&amp;#39;hd&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;/os&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;features&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;acpi/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;apic/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;pae/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;/features&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;clock offset=&amp;#39;utc&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;on_poweroff&amp;gt;destroy&amp;lt;/on_poweroff&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;on_reboot&amp;gt;restart&amp;lt;/on_reboot&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;on_crash&amp;gt;restart&amp;lt;/on_crash&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &amp;lt;devices&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;emulator&amp;gt;/usr/bin/kvm&amp;lt;/emulator&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;disk type=&amp;#39;file&amp;#39; device=&amp;#39;disk&amp;#39;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &amp;lt;driver name=&amp;#39;qemu&amp;#39; type=&amp;#39;qcow2&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &amp;lt;source file=&amp;#39;/home/mazhen/works/ubuntutest.img&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &amp;lt;target dev=&amp;#39;vda&amp;#39; bus=&amp;#39;virtio&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;/disk&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;controller type=&amp;#39;pci&amp;#39; index=&amp;#39;0&amp;#39; model=&amp;#39;pci-root&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;interface type=&amp;#39;bridge&amp;#39;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &amp;lt;mac address=&amp;#39;fa:16:3e:6e:89:ce&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &amp;lt;source bridge=&amp;#39;br0&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &amp;lt;target dev=&amp;#39;tap1&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &amp;lt;model type=&amp;#39;virtio&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;/interface&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;serial type=&amp;#39;pty&amp;#39;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &amp;lt;target port=&amp;#39;0&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;/serial&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;console type=&amp;#39;pty&amp;#39;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &amp;lt;target type=&amp;#39;serial&amp;#39; port=&amp;#39;0&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;/console&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;graphics type=&amp;#39;vnc&amp;#39; port=&amp;#39;5919&amp;#39; autoport=&amp;#39;no&amp;#39; listen=&amp;#39;0.0.0.0&amp;#39;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &amp;lt;listen type=&amp;#39;address&amp;#39; address=&amp;#39;0.0.0.0&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;/graphics&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;video&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &amp;lt;model type=&amp;#39;cirrus&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;/video&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;/devices&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;qemu:commandline&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;qemu:arg value=&amp;#39;-s&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;/qemu:commandline&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/domain&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们可以看到，&lt;code&gt;source file&lt;/code&gt;指定的文件&lt;code&gt;/home/mazhen/works/ubuntutest.img&lt;/code&gt;就是虚拟机镜像。&lt;code&gt;devices&lt;/code&gt;中的&lt;code&gt;interface&lt;/code&gt;定义了虚拟网卡，&lt;code&gt;br0&lt;/code&gt;是我们前面创建的网桥，&lt;code&gt;libvirt&lt;/code&gt;帮我们创建的虚拟网卡会连接到网桥&lt;code&gt;br0&lt;/code&gt;上。&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;XML&lt;/code&gt;文件保存为&lt;code&gt;domain.xml&lt;/code&gt;，然后在&lt;code&gt;libvirt&lt;/code&gt;定义虚拟机：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ virsh define domain.xml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接着我们可以使用&lt;code&gt;virsh list --all&lt;/code&gt;查看虚拟机列表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ virsh list --all
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Id   Name         State
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-----------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; -    ubuntutest   shut off
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用命令&lt;code&gt;virsh start ubuntutest&lt;/code&gt;启动虚拟机：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ virsh start ubuntutest
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Domain ubuntutest started
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ virsh list
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Id   Name         State
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;----------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 1    ubuntutest   running
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这时我们使用&lt;strong&gt;VNC Viewer&lt;/strong&gt;连接进行虚拟机，为虚拟机配置IP地址。虚拟机安装的是&lt;code&gt;ubuntu-20.04.2&lt;/code&gt;，编辑&lt;code&gt;/etc/netplan/00-installer-config.yaml&lt;/code&gt;文件配置&lt;code&gt;IP&lt;/code&gt;地址。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;network:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ethernets:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ens3:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            addresses: [192.168.57.100/24]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            gateway4: 192.168.57.1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            dhcp4: no
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            nameservers:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    addresses: [114.114.114.114]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            optional: true
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  version: 2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们可以看到，网关配置的就是&lt;strong&gt;br0&lt;/strong&gt;的&lt;code&gt;IP&lt;/code&gt;地址。然后，使用命令 &lt;strong&gt;netplan apply&lt;/strong&gt;让配置生效。这样，虚拟机的网络就配置好了，可以在虚拟机里访问到外网。这时我们就可以在宿主机上使用&lt;strong&gt;ssh&lt;/strong&gt;登录虚拟机，这样比使用&lt;strong&gt;VNC Viewer&lt;/strong&gt;操作更方便一些。&lt;/p&gt;
&lt;h2 id=&#34;下载linux内核源码&#34;&gt;下载Linux内核源码&lt;/h2&gt;
&lt;p&gt;在虚拟机上下载Linux内核源码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo apt install linux-source-5.4.0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;ubuntu-20.04.2&lt;/code&gt;对应的内核版本是&lt;code&gt;5.4&lt;/code&gt;。可以使用&lt;code&gt;uname -srm&lt;/code&gt;查看内核版本。&lt;/p&gt;
&lt;p&gt;源码被下载到来&lt;code&gt;/usr/src/&lt;/code&gt;目录下，使用下面的命令解压缩：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo tar vjxkf linux-source-5.4.0.tar.bz2 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;内核源码被解压缩到了&lt;code&gt;/usr/src/linux-source-5.4.0&lt;/code&gt;目录下。&lt;/p&gt;
&lt;h2 id=&#34;编译linux内核&#34;&gt;编译Linux内核&lt;/h2&gt;
&lt;p&gt;首先我们需要安装编译内核用到的依赖包：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo apt install libncurses5-dev libssl-dev bison flex libelf-dev gcc make openssl libc6-dev
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;编译前要定义内核编译选项。进入&lt;code&gt;/usr/src/linux-source-5.4.0&lt;/code&gt;目录，运行下面的命令，会进入内核参数配置界面：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo make menuconfig
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241142022.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;menuconfig.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;为了构建能够调试的内核，我们需要配置以下几个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CONFIG_DEBUG_INFO&lt;/strong&gt; 在内核和内核模块中包含调试信息，这个选项在幕后为gcc使用的编译器参数增加了&lt;code&gt;-g&lt;/code&gt;选项。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个选项的菜单路径为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Kernel hacking  ---&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Compile-time checks and compiler options  ---&amp;gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; [*] Compile the kernel with debug info   
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;实际上通过菜单进行设置比较麻烦。我们保存设置退出后，配置会保存在&lt;code&gt;.config&lt;/code&gt;文件中。直接编辑这个文件会更方便一些。在&lt;code&gt;.config&lt;/code&gt;中确认&lt;code&gt;CONFIG_DEBUG_INFO&lt;/code&gt;的设置正确。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CONFIG_DEBUG_INFO=y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CONFIG_FRAME_POINTER&lt;/strong&gt; 这个选项会将调用帧信息保存在寄存器或堆栈上的不同位置，使&lt;code&gt;gdb&lt;/code&gt;在调试内核时可以更准确地构造堆栈回溯跟踪（stack back traces）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;.config&lt;/code&gt;中设置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CONFIG_FRAME_POINTER=y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;启用&lt;strong&gt;CONFIG_GDB_SCRIPTS&lt;/strong&gt;，但要关闭&lt;strong&gt;CONFIG_DEBUG_INFO_REDUCED&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CONFIG_GDB_SCRIPTS=y
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CONFIG_DEBUG_INFO_REDUCED=n
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CONFIG_KGDB&lt;/strong&gt; 启用内置的内核调试器，该调试器允许进行远程调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CONFIG_KGDB=y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;关闭&lt;strong&gt;CONFIG_RANDOMIZE_BASE&lt;/strong&gt;设置&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CONFIG_RANDOMIZE_BASE=n
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;KASLR&lt;/code&gt;会更改引导时放置内核代码的基地址。如果你在内核配置中启用了&lt;code&gt;KASLR&lt;/code&gt;（&lt;code&gt;CONFIG_RANDOMIZE_BASE=y&lt;/code&gt;），则无法从&lt;code&gt;gdb&lt;/code&gt;设置断点。&lt;/p&gt;
&lt;p&gt;设置完必要的内核参数后，我们开始编译内核：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make -j8 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make modules_install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;编译的过程很漫长，可能需要数小时。当编译完毕之后，新内核的选项已经增加到了&lt;code&gt;grub&lt;/code&gt;的配置中。我们可以查看配置文件&lt;code&gt;/boot/grub/grub.cfg&lt;/code&gt;确认：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;submenu &amp;#39;Advanced options for Ubuntu&amp;#39; $menuentry_id_option &amp;#39;gnulinux-advanced-5506d28f-c9e7-46d4-a12e-42555d491eec&amp;#39; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        menuentry &amp;#39;Ubuntu, with Linux 5.4.106&amp;#39; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &amp;#39;gnulinux-5.4.106-advanced-5506d28f-c9e7-46d4-a12e-42555d491eec&amp;#39; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                recordfail
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                load_video
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                gfxmode $linux_gfx_mode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                insmod gzio
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                insmod part_gpt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                insmod ext2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                if [ x$feature_platform_search_hint = xy ]; then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  search --no-floppy --fs-uuid --set=root  5506d28f-c9e7-46d4-a12e-42555d491eec
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  search --no-floppy --fs-uuid --set=root 5506d28f-c9e7-46d4-a12e-42555d491eec
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                fi
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                echo    &amp;#39;Loading Linux 5.4.106 ...&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                linux   /boot/vmlinuz-5.4.106 root=UUID=5506d28f-c9e7-46d4-a12e-42555d491eec ro maybe-ubiquity
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                echo    &amp;#39;Loading initial ramdisk ...&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                initrd  /boot/initrd.img-5.4.106
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;vmlinuz-5.4.106&lt;/code&gt;就是我们新编译的内核。&lt;/p&gt;
&lt;p&gt;重启虚拟机。在&lt;code&gt;GRUB&lt;/code&gt;界面选择 &lt;code&gt;Ubuntu 高级选项&lt;/code&gt;，选择第一项进去，就进入了新的内核。&lt;/p&gt;
&lt;h2 id=&#34;启用gdb监听端口&#34;&gt;启用gdb监听端口&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;QEMU&lt;/strong&gt;有个命令行参数&lt;code&gt;-s&lt;/code&gt;，它代表参数&lt;code&gt;-gdb tcp::1234&lt;/code&gt;，意思是&lt;strong&gt;QEMU&lt;/strong&gt;监听 1234端口，这样&lt;code&gt;gdb&lt;/code&gt; 可以 &lt;code&gt;attach&lt;/code&gt; 到这个端口上，调试&lt;strong&gt;QEMU&lt;/strong&gt;里面的内核。&lt;/p&gt;
&lt;p&gt;实际上在前面的&lt;code&gt;domain.xml&lt;/code&gt;中我们已经为&lt;strong&gt;QEMU&lt;/strong&gt;加了&lt;code&gt;-s&lt;/code&gt;参数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;domain type=&amp;#39;kvm&amp;#39; xmlns:qemu=&amp;#39;http://libvirt.org/schemas/domain/qemu/1.0&amp;#39;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;qemu:commandline&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;qemu:arg value=&amp;#39;-s&amp;#39;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;/qemu:commandline&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/domain&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;所以这时运行在虚拟机里的内核已经可以被调试了。&lt;/p&gt;
&lt;h2 id=&#34;调试内核&#34;&gt;调试内核&lt;/h2&gt;
&lt;p&gt;在宿主机上运行&lt;code&gt;gdb&lt;/code&gt;需要内核的二进制文件，这个文件就是在虚拟机&lt;code&gt;GRUB&lt;/code&gt;里配置的&lt;code&gt;/boot/vmlinuz-5.4.106&lt;/code&gt;。为了方便在调试过程中查看源代码，我们可以将虚拟机的&lt;code&gt;/usr/src/linux-source-5.4.0&lt;/code&gt;整个目录都拷贝到宿主机上来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ scp -r mazhen@virtual-node:/usr/src/linux-source-5.4.0 ./
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在&lt;code&gt;/usr/src/linux-source-5.4.0&lt;/code&gt;目录下面的&lt;strong&gt;vmlinux&lt;/strong&gt;文件也是内核的二进制文件。&lt;/p&gt;
&lt;p&gt;为了能让&lt;code&gt;gdb&lt;/code&gt;在启动时能够加载&lt;code&gt;Linux helper脚本&lt;/code&gt;，需要在&lt;code&gt;~/.gdbinit&lt;/code&gt;文件中添加如下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;add-auto-load-safe-path /path/to/linux-build
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;/path/to/linux-build&lt;/code&gt;就是上面从虚拟机拷贝过来的Linux源码目录。&lt;/p&gt;
&lt;p&gt;必要的配置完成后，就可以启动&lt;code&gt;gdb&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;在宿主机的&lt;code&gt;./linux-source-5.4.0&lt;/code&gt;目录下执行&lt;code&gt;gdb vmlinux&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后在gdb的交互环境下使用&lt;code&gt;target remote :1234&lt;/code&gt;命令attach到虚拟机的内核。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ gdb vmlinux
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Reading symbols from vmlinux...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) target remote :1234
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Remote debugging using :1234
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0xffffffff81ade35e in native_safe_halt () at ./arch/x86/include/asm/irqflags.h:60
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果我们想调试进程&lt;code&gt;fork&lt;/code&gt;的过程，可以用&lt;code&gt;b _do_fork&lt;/code&gt;设置断点：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) b _do_fork
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Breakpoint 1 at 0xffffffff81098450: file kernel/fork.c, line 2362.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们可以看到，断点设置成功。如果你不确认fork的具体方法名，可以使用&lt;code&gt;info functions&lt;/code&gt;命令搜索符号表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) info function do_fork
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;All functions matching regular expression &amp;#34;do_fork&amp;#34;:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;File kernel/fork.c:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2361:	long _do_fork(struct kernel_clone_args *);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用命令&lt;code&gt;c&lt;/code&gt;让内核继续执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Continuing.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这时在虚拟机里执行任意命令，例如&lt;code&gt;ls&lt;/code&gt;，断点将被触发：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Continuing.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Thread 1 hit Breakpoint 1, _do_fork (args=0xffffc9000095fee0) at kernel/fork.c:2362
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2362	{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们可以使用&lt;code&gt;n&lt;/code&gt;执行下一条语句：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) n
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2376		if (!(clone_flags &amp;amp; CLONE_UNTRACED)) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) n
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2377			if (clone_flags &amp;amp; CLONE_VFORK)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) n
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2379			else if (args-&amp;gt;exit_signal != SIGCHLD)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;l&lt;/code&gt;显示多行源码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) l
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2374		 * for the type of forking is enabled.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2375		 */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2376		if (!(clone_flags &amp;amp; CLONE_UNTRACED)) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2377			if (clone_flags &amp;amp; CLONE_VFORK)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2378				trace = PTRACE_EVENT_VFORK;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2379			else if (args-&amp;gt;exit_signal != SIGCHLD)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2380				trace = PTRACE_EVENT_CLONE;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2381			else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2382				trace = PTRACE_EVENT_FORK;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2383	
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;bt&lt;/code&gt;查看函数调用信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) bt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#0  _do_fork (args=0xffffc9000095fee0) at kernel/fork.c:2379
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#1  0xffffffff810989f4 in __do_sys_clone (tls=&amp;lt;optimized out&amp;gt;, child_tidptr=&amp;lt;optimized out&amp;gt;, parent_tidptr=&amp;lt;optimized out&amp;gt;, newsp=&amp;lt;optimized out&amp;gt;, 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    clone_flags=&amp;lt;optimized out&amp;gt;) at kernel/fork.c:2544
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#2  __se_sys_clone (tls=&amp;lt;optimized out&amp;gt;, child_tidptr=&amp;lt;optimized out&amp;gt;, parent_tidptr=&amp;lt;optimized out&amp;gt;, newsp=&amp;lt;optimized out&amp;gt;, clone_flags=&amp;lt;optimized out&amp;gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    at kernel/fork.c:2525
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#3  __x64_sys_clone (regs=&amp;lt;optimized out&amp;gt;) at kernel/fork.c:2525
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#4  0xffffffff81003fd7 in do_syscall_64 (nr=&amp;lt;optimized out&amp;gt;, regs=0xffffc9000095ff58) at arch/x86/entry/common.c:290
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#5  0xffffffff81c0008c in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:175
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#6  0x00005621191e2da0 in ?? ()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#7  0x000056211a7de450 in ?? ()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#8  0x00007ffc9f31a3e0 in ?? ()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#9  0x0000000000000000 in ?? ()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;p&lt;/code&gt;用于打印内部变量值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) p clone_flags
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$1 = 18874368
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;你现在可以像调试普通应用程序一样，调试Linux内核了！&lt;/p&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;在本机搭建Linux内核调试环境的步骤有点繁杂，但使用&lt;code&gt;GDB&lt;/code&gt;能调试内核，会成为我们学习内核的利器，进程管理、内存管理、文件系统，对源码有什么困惑就可以debug一下。
Enjoy it!&lt;/p&gt;
</description>
        </item>
        <item>
        <title>使用火焰图进行Java性能分析</title>
        <link>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8%E7%81%AB%E7%84%B0%E5%9B%BE%E8%BF%9B%E8%A1%8Cjava%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
        <pubDate>Mon, 23 Mar 2020 11:01:58 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8%E7%81%AB%E7%84%B0%E5%9B%BE%E8%BF%9B%E8%A1%8Cjava%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
        <description>&lt;h2 id=&#34;性能分析工具的分类&#34;&gt;性能分析工具的分类&lt;/h2&gt;
&lt;p&gt;性能分析的技术和工具可以分为以下几类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Counters&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内核维护着各种统计信息，被称为&lt;code&gt;Counters&lt;/code&gt;，用于对事件进行计数。例如，接收的网络数据包数量，发出的磁盘I/O请求，执行的系统调用次数。常见的这类工具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vmstat: 虚拟和物理内存统计&lt;/li&gt;
&lt;li&gt;mpstat: CPU使用率统计&lt;/li&gt;
&lt;li&gt;iostat：磁盘的I/O使用情况&lt;/li&gt;
&lt;li&gt;netstat：网络接口统计信息，TCP/IP协议栈统计信息，连接统计信息&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Tracing&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Tracing&lt;/strong&gt;是收集每个事件的数据进行分析。&lt;strong&gt;Tracing&lt;/strong&gt;会捕获所有的事件，因此有比较大的CPU开销，并且可能需要大量存储来保存数据。&lt;/p&gt;
&lt;p&gt;常见的&lt;strong&gt;Tracing&lt;/strong&gt;工具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tcpdump: network packet tracing&lt;/li&gt;
&lt;li&gt;blktrace: block I/O tracing&lt;/li&gt;
&lt;li&gt;perf: Linux Performance Events, 跟踪静态和动态探针&lt;/li&gt;
&lt;li&gt;strace: 系统调用tracing&lt;/li&gt;
&lt;li&gt;gdb: 源代码级调试器&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;Profiling&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Profiling&lt;/strong&gt; 是通过收集目标行为的样本或快照，来了解目标的特征。&lt;strong&gt;Profiling&lt;/strong&gt;可以从多个方面对程序进行动态分析，如&lt;code&gt;CPU&lt;/code&gt;、&lt;code&gt;Memory&lt;/code&gt;、&lt;code&gt;Thread&lt;/code&gt;、&lt;code&gt;I/O&lt;/code&gt;等，其中对&lt;code&gt;CPU&lt;/code&gt;进行&lt;code&gt;Profiling&lt;/code&gt;的应用最为广泛。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CPU Profiling&lt;/code&gt;原理是基于一定频率对运行的程序进行采样，来分析消耗CPU时间的代码路径。可以基于固定的时间间隔进行采样，例如每10毫秒采样一次。也可以设置固定速率采样，例如每秒采集100个样本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CPU Profiling&lt;/code&gt;经常被用于分析代码的热点，比如“哪个方法占用CPU的执行时间最长”、“每个方法占用CPU的比例是多少”等等，然后我们就可以针对热点瓶颈进行分析和性能优化。&lt;/p&gt;
&lt;p&gt;Linux上常用的&lt;strong&gt;CPU Profiling&lt;/strong&gt;工具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://perf.wiki.kernel.org/index.php/Main_Page&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;perf&lt;/a&gt;的 &lt;a class=&#34;link&#34; href=&#34;https://perf.wiki.kernel.org/index.php/Tutorial#Sampling_with_perf_record&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;record&lt;/a&gt; 子命令&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc/blob/master/tools/profile.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BPF profile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;Monitoring&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;系统性能监控会记录一段时间内的性能统计信息，以便能够基于时间周期进行比较。这对于容量规划，了解高峰期的使用情况都很有帮助。历史值还为我们理解当前的性能指标提供了上下文。&lt;/p&gt;
&lt;p&gt;监控单个操作系统最常用工具是&lt;strong&gt;sar&lt;/strong&gt;（system activity reporter，系统活动报告）命令。&lt;code&gt;sar&lt;/code&gt;通过一个定期执行的agent来记录系统计数器的状态，并可以使用&lt;code&gt;sar&lt;/code&gt;命令查看它们，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sar
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Linux 4.15.0-88-generic (mazhen) 	03/19/2020 	_x86_64_	(4 CPU)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:53:08 PM       LINUX RESTART
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:55:01 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;01:05:01 PM     all     14.06      0.00     10.97      0.11      0.00     74.87
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;01:15:01 PM     all      9.60      0.00      7.49      0.09      0.00     82.83
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;01:25:01 PM     all      0.04      0.00      0.02      0.02      0.00     99.92
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;01:35:01 PM     all      0.03      0.00      0.02      0.01      0.00     99.94
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;本文主要讨论如何使用&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;BPF&lt;/code&gt;进行&lt;code&gt;CPU Profiling&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;perf&#34;&gt;perf&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;perf&lt;/strong&gt;最初是使用&lt;code&gt;Linux&lt;/code&gt;性能计数器子系统的工具，因此&lt;code&gt;perf&lt;/code&gt;开始的名称是&lt;code&gt;Performance Counters for Linux&lt;/code&gt;(PCL)。&lt;code&gt;perf&lt;/code&gt;在Linux&lt;code&gt;2.6.31&lt;/code&gt;合并进内核，位于&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux/tree/master/tools/perf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tools/perf&lt;/a&gt;目录下。&lt;/p&gt;
&lt;p&gt;随后&lt;code&gt;perf&lt;/code&gt;进行了各种增强，增加了&lt;code&gt;tracing&lt;/code&gt;、&lt;code&gt;profiling&lt;/code&gt;等能力，可用于性能瓶颈的查找和热点代码的定位。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;是一个面向事件（event-oriented）的性能剖析工具，因此它也被称为&lt;code&gt;Linux perf events (LPE)&lt;/code&gt;，或&lt;code&gt;perf_events&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;的整体架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241109248.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;perf&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt; 由两部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;perf Tools&lt;/strong&gt;：perf用户态命令，为用户提供了一系列工具集，用于收集、分析性能数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;perf Event Subsystem&lt;/strong&gt;：Perf Events是内核的子系统之一，和用户态工具共同完成数据的采集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核依赖的硬件，比如说&lt;code&gt;CPU&lt;/code&gt;，一般会内置一些性能统计方面的寄存器（&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Hardware_performance_counter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hardware Performance Counter&lt;/a&gt;），通过软件读取这些特殊寄存器里的信息，我们也可以得到很多直接关于硬件的信息。&lt;code&gt;perf&lt;/code&gt;最初就是用来监测&lt;code&gt;CPU&lt;/code&gt;的性能监控单元（performance monitoring unit, PMU）的。&lt;/p&gt;
&lt;h3 id=&#34;perf-events分类&#34;&gt;perf Events分类&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;支持多种性能事件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241110166.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;event sources&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这些性能事件分类为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hardware Events&lt;/strong&gt;: CPU性能监控计数器performance monitoring counters（PMC），也被称为performance monitoring unit（PMU）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Software Events&lt;/strong&gt;: 基于内核计数器的底层事件。例如，CPU迁移，minor faults，major faults等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kernel Tracepoint Events&lt;/strong&gt;: 内核的静态&lt;code&gt;Tracepoint&lt;/code&gt;，已经硬编码在内核需要收集信息的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User Statically-Defined Tracing (USDT)&lt;/strong&gt;: 用户级程序的静态&lt;code&gt;Tracepoint&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic Tracing&lt;/strong&gt;: 用户自定义事件，可以动态的插入到内核或正在运行中的程序。&lt;code&gt;Dynamic Tracing&lt;/code&gt;技术分为两类：
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://lwn.net/Articles/132196/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;kprobes&lt;/a&gt;：对于kernel的动态追踪技术，可以动态地在指定的内核函数的入口和出口等位置上放置探针，并定义自己的探针处理程序。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://lwn.net/Articles/499190/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;uprobes&lt;/a&gt;：对于用户态软件的动态追踪技术，可以安全地在用户态函数的入口等位置设置动态探针，并执行自己的探针处理程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用perf的&lt;code&gt;list&lt;/code&gt;子命令查看当前可用的事件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo perf list
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;List of pre-defined events (to be used in -e):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  branch-instructions OR branches                    [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  branch-misses                                      [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  bus-cycles                                         [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cache-misses                                       [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cache-references                                   [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cpu-cycles OR cycles                               [Hardware event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  alignment-faults                                   [Software event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  bpf-output                                         [Software event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  context-switches OR cs                             [Software event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cpu-clock                                          [Software event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cpu-migrations OR migrations                       [Software event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  alarmtimer:alarmtimer_cancel                       [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  alarmtimer:alarmtimer_fired                        [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  alarmtimer:alarmtimer_start                        [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  alarmtimer:alarmtimer_suspend                      [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  block:block_bio_backmerge                          [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  block:block_bio_bounce                             [Tracepoint event]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;perf的使用&#34;&gt;perf的使用&lt;/h3&gt;
&lt;p&gt;如果还没有安装&lt;code&gt;perf&lt;/code&gt;，可以使用&lt;code&gt;apt&lt;/code&gt;或&lt;code&gt;yum&lt;/code&gt;进行安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install linux-tools-$(uname -r) linux-tools-generic
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;的功能强大，支持硬件计数器统计，定时采样，静态和动态tracing等。本文只介绍几个常用的使用场景，如果想全面的了解&lt;code&gt;perf&lt;/code&gt;的使用，可以参考&lt;a class=&#34;link&#34; href=&#34;https://perf.wiki.kernel.org/index.php/Main_Page&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;perf.wiki&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CPU Statistics&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用&lt;code&gt;perf&lt;/code&gt;的&lt;code&gt;stat&lt;/code&gt;命令可以收集性能计数器统计信息，精确统计一段时间内 CPU 相关硬件计数器数值的变化。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-&amp;gt; % sudo perf stat  dd if=/dev/zero of=/dev/null count=10000000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10000000+0 records in
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10000000+0 records out
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5120000000 bytes (5.1 GB, 4.8 GiB) copied, 12.2795 s, 417 MB/s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Performance counter stats for &amp;#39;dd if=/dev/zero of=/dev/null count=10000000&amp;#39;:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      12280.299325      task-clock (msec)         #    1.000 CPUs utilized          
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                16      context-switches          #    0.001 K/sec                  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 0      cpu-migrations            #    0.000 K/sec                  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                70      page-faults               #    0.006 K/sec                  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    41,610,802,323      cycles                    #    3.388 GHz                    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    20,195,746,887      instructions              #    0.49  insn per cycle         
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     3,972,723,471      branches                  #  323.504 M/sec                  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        90,061,565      branch-misses             #    2.27% of all branches        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      12.280445133 seconds time elapsed
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;CPU Profiling&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以使用&lt;code&gt;perf record&lt;/code&gt;以任意频率收集快照。这通常用于CPU使用情况的分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo perf record -F 99 -a -g  sleep 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对所有CPU（&lt;strong&gt;-a&lt;/strong&gt;）进行&lt;code&gt;call stacks&lt;/code&gt;（&lt;strong&gt;-g&lt;/strong&gt;）采样，采样频率为&lt;code&gt;99 Hertz&lt;/code&gt;（&lt;strong&gt;-F 99&lt;/strong&gt;），即每秒99次，持续10秒（&lt;strong&gt;sleep 10&lt;/strong&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo perf record -F 99 -a -g  -p PID sleep 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对指定进程（&lt;strong&gt;-p PID&lt;/strong&gt;）进行采样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo perf record -F 99 -a -g -e context-switches -p PID sleep 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;可以和各种&lt;code&gt;instrumentation points&lt;/code&gt;一起使用，以跟踪内核调度程序（&lt;code&gt;scheduler&lt;/code&gt;）的活动。其中包括&lt;code&gt;software events&lt;/code&gt;和&lt;code&gt;tracepoint event&lt;/code&gt;（静态探针）。&lt;/p&gt;
&lt;p&gt;上面的例子对指定进程的上下文切换（&lt;strong&gt;-e context-switches&lt;/strong&gt;）进行采样。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;report&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;perf record&lt;/code&gt;的运行结果保存在当前目录的&lt;code&gt;perf.data&lt;/code&gt;文件中，采样结束后，我们使用&lt;code&gt;perf report&lt;/code&gt;查看结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;交互式查看模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo perf report
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241111810.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;perf report&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;+&lt;/code&gt;开头的行可以回车，展开详细信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用&lt;code&gt;--stdio&lt;/code&gt;选项打印所有输出&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo perf report --stdio
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241111875.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;perf report &amp;ndash;stdio&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;context-switches&lt;/code&gt;的采样报告：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241112884.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;perf-report-context-switches&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;后面我们会介绍&lt;strong&gt;火焰图&lt;/strong&gt;，以可视化的方式展示&lt;code&gt;stack traces&lt;/code&gt;，比&lt;code&gt;perf report&lt;/code&gt;更加直观。&lt;/p&gt;
&lt;h2 id=&#34;bpf&#34;&gt;BPF&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;BPF&lt;/strong&gt;是&lt;strong&gt;Berkeley Packet Filter&lt;/strong&gt;的缩写，最初是为BSD开发，第一个版本于1992年发布，&lt;a class=&#34;link&#34; href=&#34;https://www.tcpdump.org/papers/bpf-usenix93.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;用于改进网络数据包捕获的性能&lt;/a&gt;。&lt;code&gt;BPF&lt;/code&gt;是在内核级别进行过滤，不必将每个数据包拷贝到用户空间，从而提高了数据包过滤的性能。&lt;code&gt;tcpdump&lt;/code&gt;使用的就是&lt;code&gt;BPF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241113910.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;2013年&lt;code&gt;BPF&lt;/code&gt;被重写，被称为&lt;strong&gt;Extended BPF (eBPF)&lt;/strong&gt;，于2014年包含进&lt;code&gt;Linux&lt;/code&gt;内核中。改进后的&lt;code&gt;BPF&lt;/code&gt;成为了通用执行引擎，可用于多种用途，包括创建高级性能分析工具。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BPF&lt;/code&gt;允许在内核中运行&lt;code&gt;mini programs&lt;/code&gt;，来响应系统和应用程序事件（例如磁盘I/O事件）。这种运作机制和&lt;code&gt;JavaScript&lt;/code&gt;类似：&lt;code&gt;JavaScript&lt;/code&gt;是运行在浏览器引擎中的&lt;code&gt;mini programs&lt;/code&gt;，响应鼠标点击等事件。&lt;code&gt;BPF&lt;/code&gt;使内核可编程化，使用户（包括非内核开发人员）能够自定义和控制他们的系统，以解决实际问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BPF&lt;/code&gt;可以被认为是一个&lt;strong&gt;虚拟机&lt;/strong&gt;，由指令集，存储对象和helper函数三部分组成。&lt;code&gt;BPF&lt;/code&gt;指令集由位于Linux内核的&lt;code&gt;BPF runtime&lt;/code&gt;执行，&lt;code&gt;BPF runtime&lt;/code&gt;包括了&lt;strong&gt;解释器&lt;/strong&gt;和&lt;strong&gt;JIT编译器&lt;/strong&gt;。&lt;code&gt;BPF&lt;/code&gt;是一种灵活高效的技术，可以用于&lt;code&gt;networking&lt;/code&gt;，&lt;code&gt;tracing&lt;/code&gt;和安全等领域。我们重点关注它作为系统监测工具方面的应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241114773.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;linux_ebpf_internals&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;perf&lt;/code&gt;一样，&lt;code&gt;BPF&lt;/code&gt;能够监测多种性能事件源，同时可以通过调用&lt;code&gt;perf_events&lt;/code&gt;，使用&lt;code&gt;perf&lt;/code&gt;已有的功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241114535.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;linux_ebpf_support&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BPF&lt;/code&gt;可以在内核运行计算和统计汇总，这样大大减少了复制到用户空间的数据量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241115194.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;before_and_after_using_BPF&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BPF&lt;/code&gt;已经内置在Linux内核中，因此你无需再安装任何新的内核组件，就可以在生产环境中使用BPF。&lt;/p&gt;
&lt;h2 id=&#34;bcc和bpftrace&#34;&gt;BCC和bpftrace&lt;/h2&gt;
&lt;p&gt;直接使用&lt;code&gt;BPF&lt;/code&gt;指令进行编程非常繁琐，因此很有必要提供高级语言前端方便用户使用，于是就出现了&lt;code&gt;BCC&lt;/code&gt;和&lt;code&gt;bpftrace&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241116502.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;bcc-bpftrace&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BCC（BPF Compiler Collection）&lt;/strong&gt; 提供了一个C编程环境，使用&lt;code&gt;LLVM&lt;/code&gt;工具链来把 C 代码编译为&lt;code&gt;BPF&lt;/code&gt;虚拟机所接受的字节码。此外它还支持&lt;code&gt;Python&lt;/code&gt;，&lt;code&gt;Lua&lt;/code&gt;和&lt;code&gt;C++&lt;/code&gt;作为用户接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bpftrace&lt;/strong&gt; 是一个比较新的前端，它为开发&lt;code&gt;BPF&lt;/code&gt;工具提供了一种专用的高级语言。&lt;code&gt;bpftrace&lt;/code&gt;适合单行代码和自定义短脚本，而&lt;code&gt;BCC&lt;/code&gt;更适合复杂的脚本和守护程序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BCC&lt;/code&gt;和&lt;code&gt;bpftrace&lt;/code&gt;没有在内核代码库，它们存放在GitHub上名为&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;IO Visor&lt;/a&gt;的&lt;code&gt;Linux Foundation&lt;/code&gt;项目中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;iovisor/bcc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;iovisor/bpftrace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bcc的安装&#34;&gt;BCC的安装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;BCC&lt;/code&gt;可以参考官方的&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc/blob/master/INSTALL.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;安装文档&lt;/a&gt;。以&lt;code&gt;Ubuntu 18.04 LTS&lt;/code&gt;为例，建议从源码build安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装build依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get -y install bison build-essential cmake flex git libedit-dev \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  libllvm6.0 llvm-6.0-dev libclang-6.0-dev python zlib1g-dev libelf-dev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get -y install luajit luajit-5.1-dev
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;编译和安装&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/iovisor/bcc.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir bcc/build; cd bcc/build
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake ..
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;build python3 binding&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake -DPYTHON_CMD=python3 .. 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pushd src/python/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;popd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;make install&lt;/code&gt;完成后，&lt;code&gt;BCC&lt;/code&gt;自带的工具都安装在了&lt;code&gt;/usr/share/bcc/tools&lt;/code&gt;目录下。&lt;code&gt;BCC&lt;/code&gt;已经包含70多个&lt;code&gt;BPF&lt;/code&gt;工具，用于性能分析和故障排查。这些工具都可以直接使用，无需编写任何&lt;code&gt;BCC&lt;/code&gt;代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241116881.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;bcc_tracing_tools&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我们试用其中一个工具&lt;code&gt;biolatency&lt;/code&gt;，跟踪磁盘&lt;code&gt;I/O&lt;/code&gt;延迟：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-&amp;gt; % sudo /usr/share/bcc/tools/biolatency
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tracing block device I/O... Hit Ctrl-C to end.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;^C
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     usecs               : count     distribution
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         0 -&amp;gt; 1          : 0        |                                        |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         2 -&amp;gt; 3          : 0        |                                        |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         4 -&amp;gt; 7          : 0        |                                        |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         8 -&amp;gt; 15         : 0        |                                        |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        16 -&amp;gt; 31         : 2        |***                                     |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        32 -&amp;gt; 63         : 0        |                                        |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        64 -&amp;gt; 127        : 3        |*****                                   |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       128 -&amp;gt; 255        : 7        |***********                             |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       256 -&amp;gt; 511        : 6        |**********                              |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       512 -&amp;gt; 1023       : 11       |******************                      |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      1024 -&amp;gt; 2047       : 16       |**************************              |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      2048 -&amp;gt; 4095       : 24       |****************************************|
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      4096 -&amp;gt; 8191       : 1        |*                                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      8192 -&amp;gt; 16383      : 6        |**********                              |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     16384 -&amp;gt; 32767      : 3        |*****                                   |
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;biolatency&lt;/code&gt;展示的直方图比&lt;code&gt;iostat&lt;/code&gt;的平均值能更好的理解磁盘&lt;code&gt;I/O&lt;/code&gt;性能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BCC&lt;/code&gt;已经自带了&lt;code&gt;CPU profiling&lt;/code&gt;工具：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc/blob/master/tools/profile.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tools/profile&lt;/a&gt;: Profile CPU usage by sampling stack traces at a timed interval.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，&lt;code&gt;BCC&lt;/code&gt;还提供了&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/offcpuanalysis.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Off-CPU&lt;/a&gt;的分析工具：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bcc/blob/master/tools/offcputime.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tools/offcputime&lt;/a&gt;: Summarize off-CPU time by kernel stack trace&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般的&lt;code&gt;CPU profiling&lt;/code&gt;都是分析&lt;code&gt;on-CPU&lt;/code&gt;，即CPU时间都花费在了哪些代码路径。&lt;code&gt;off-CPU&lt;/code&gt;是指进程不在CPU上运行时所花费的时间，进程因为某种原因处于休眠状态，比如说等待锁，或者被进程调度器（scheduler）剥夺了 CPU 的使用。这些情况都会导致这个进程无法运行在 CPU 上，但是仍然花费了时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241117655.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;thread_states&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;off-CPU&lt;/code&gt;分析是对&lt;code&gt;on-CPU&lt;/code&gt;的补充，让我们知道线程所有的时间花费，更全面的了解程序的运行情况。&lt;/p&gt;
&lt;p&gt;后面会介绍&lt;code&gt;profile&lt;/code&gt;，&lt;code&gt;offcputime&lt;/code&gt;如何生成火焰图进行可视化分析。&lt;/p&gt;
&lt;h3 id=&#34;bpftrace的安装&#34;&gt;bpftrace的安装&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;bpftrace&lt;/a&gt; 建议运行在Linux 4.9 kernel或更高版本。根据&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace/blob/master/INSTALL.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;安装文档&lt;/a&gt;的说明，是因为&lt;code&gt;kprobes&lt;/code&gt;、&lt;code&gt;uprobes&lt;/code&gt;、&lt;code&gt;tracepoints&lt;/code&gt;等主要特性是在&lt;code&gt;4.x&lt;/code&gt;以上加入内核的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;4.1 - kprobes&lt;/li&gt;
&lt;li&gt;4.3 - uprobes&lt;/li&gt;
&lt;li&gt;4.6 - stack traces, count and hist builtins (use PERCPU maps for accuracy and efficiency)&lt;/li&gt;
&lt;li&gt;4.7 - tracepoints&lt;/li&gt;
&lt;li&gt;4.9 - timers/profiling&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以运行&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace/blob/master/scripts/check_kernel_features.sh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;scripts/check_kernel_features.sh&lt;/a&gt;脚本进行验证：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ./scripts/check_kernel_features.sh 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;All required features present!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;bpftrace&lt;/code&gt;对Linux的版本要求较高，以&lt;code&gt;Ubuntu&lt;/code&gt;为例，&lt;code&gt;19.04&lt;/code&gt;及以上才支持&lt;code&gt;apt&lt;/code&gt;安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install -y libbpfcc-dev
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;18.04&lt;/code&gt;和&lt;code&gt;18.10&lt;/code&gt;可以从源码build，但需要先build好&lt;code&gt;BCC&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install -y bison cmake flex g++ git libelf-dev zlib1g-dev libfl-dev systemtap-sdt-dev binutils-dev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install -y llvm-7-dev llvm-7-runtime libclang-7-dev clang-7
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;编译和安装&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/iovisor/bpftrace
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir bpftrace/build; cd bpftrace/build;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake -DCMAKE_BUILD_TYPE=Release ..
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make -j8
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;make install&lt;/code&gt;完成后，&lt;code&gt;bpftrace&lt;/code&gt;自带的工具安装在&lt;code&gt;/usr/local/share/bpftrace/tools&lt;/code&gt;目录下，这些工具的说明文档可以在&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;项目主页&lt;/a&gt;找到。&lt;/p&gt;
&lt;p&gt;我们同样试用查看&lt;code&gt;Block I/O&lt;/code&gt;延迟直方图的工具：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-&amp;gt; % sudo bpftrace /usr/local/share/bpftrace/tools/biolatency.bt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Attaching 4 probes...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tracing block device I/O... Hit Ctrl-C to end.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;^C
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@usecs: 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[128, 256)             6 |@@@@@@@@@@                                          |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[256, 512)             4 |@@@@@@                                              |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[512, 1K)              8 |@@@@@@@@@@@@@                                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[1K, 2K)              20 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[2K, 4K)              30 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[4K, 8K)               1 |@                                                   |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[8K, 16K)              3 |@@@@@                                               |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[16K, 32K)             0 |                                                    |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[32K, 64K)             2 |@@@                                                 |
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;关于&lt;code&gt;bpftrace&lt;/code&gt;脚本编写不在本文的讨论范围，感兴趣的可以参考&lt;a class=&#34;link&#34; href=&#34;https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;reference_guide&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;火焰图&#34;&gt;火焰图&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;火焰图&lt;/a&gt;是&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Brendan Gregg&lt;/a&gt;发明的将&lt;code&gt;stack traces&lt;/code&gt;可视化展示的方法。火焰图把时间和空间两个维度上的信息融合在一张图上，将频繁执行的代码路径以可视化的形式，非常直观的展现了出来。&lt;/p&gt;
&lt;p&gt;火焰图可以用于可视化来自任何&lt;code&gt;profiler&lt;/code&gt;工具的记录的&lt;code&gt;stack traces&lt;/code&gt;信息，除了用来&lt;code&gt;CPU profiling&lt;/code&gt;，还适用于&lt;code&gt;off-CPU&lt;/code&gt;，&lt;code&gt;page faults&lt;/code&gt;等多种场景的分析。本文只讨论 &lt;code&gt;on-CPU&lt;/code&gt; 和 &lt;code&gt;off-CPU&lt;/code&gt; 火焰图的生成。&lt;/p&gt;
&lt;p&gt;要理解火焰图，先从理解&lt;code&gt;Stack Trace&lt;/code&gt;开始。&lt;/p&gt;
&lt;h3 id=&#34;stack-trace&#34;&gt;Stack Trace&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Stack Trace&lt;/code&gt;是程序执行过程中，在特定时间点的函数调用列表。例如，&lt;code&gt;func_a()&lt;/code&gt;调用&lt;code&gt;func_b()&lt;/code&gt;，&lt;code&gt;func_b()&lt;/code&gt;调用&lt;code&gt;func_c()&lt;/code&gt;，此时的&lt;code&gt;Stack Trace&lt;/code&gt;可写为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_b
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_a
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;profiling-stack-traces&#34;&gt;Profiling Stack Traces&lt;/h3&gt;
&lt;p&gt;我们做&lt;code&gt;CPU profiling&lt;/code&gt;时，会使用perf或bcc定时采样&lt;code&gt;Stack Trace&lt;/code&gt;，这样会收集到非常多的&lt;code&gt;Stack Trace&lt;/code&gt;。前面介绍了&lt;code&gt;perf report&lt;/code&gt;会将&lt;code&gt;Stack Trace&lt;/code&gt;样本汇总为调用树，并显示每个路径的百分比。火焰图是怎么展示的呢？&lt;/p&gt;
&lt;p&gt;考虑下面的示例，我们用perf定时采样收集了多个&lt;code&gt;Stack Trace&lt;/code&gt;，然后将相同的&lt;code&gt;Stack Trace&lt;/code&gt;归纳合并，统计出次数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_e
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_b
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_b
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_b
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func_a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看到，总共收集了10个样本，其中代码路径&lt;code&gt;func_a-&amp;gt;func_b-&amp;gt;func_c&lt;/code&gt;有7次，该路径上的&lt;code&gt;func_c&lt;/code&gt;在CPU上运行。 &lt;code&gt;func_a-&amp;gt;func_b&lt;/code&gt;进行了两次采样，&lt;code&gt;func_b&lt;/code&gt;在CPU上运行。&lt;code&gt;func_a-&amp;gt;func_b-&amp;gt;func_d-&amp;gt;func_e&lt;/code&gt;一次采样，&lt;code&gt;func_e&lt;/code&gt;在CPU上运行。&lt;/p&gt;
&lt;h3 id=&#34;火焰图-1&#34;&gt;火焰图&lt;/h3&gt;
&lt;p&gt;根据前面对&lt;code&gt;Stack Trace&lt;/code&gt;的统计信息，可以绘制出如下的火焰图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241117302.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;flame-graph-demo&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;火焰图具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个长方块代表了函数调用栈中的一个函数&lt;/li&gt;
&lt;li&gt;Y 轴显示堆栈的深度（堆栈中的帧数）。调用栈越深，火焰就越高。顶层方块表示 CPU 上正在运行的函数，下面的函数即为它的祖先。&lt;/li&gt;
&lt;li&gt;X 轴的宽度代表被采集的样本数量，越宽表示采集到的越多，即执行的时间长。需要注意的是，X轴从左到右不代表时间，而是所有的调用栈合并后，按字母顺序排列的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拿到火焰图，寻找最宽的塔并首先了解它们。顶层的哪个函数占据的宽度最大，说明它可能存在性能问题。&lt;/p&gt;
&lt;p&gt;可以使用Brendan Gregg开发的开源项目&lt;a class=&#34;link&#34; href=&#34;https://github.com/brendangregg/FlameGraph&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;FlameGraph&lt;/a&gt;生成交互式的SVG火焰图。该项目提供了脚本，可以将采集的样本归纳合并，统计出&lt;code&gt;Stack Trace&lt;/code&gt;出现的频率，然后使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/brendangregg/FlameGraph/blob/master/flamegraph.pl&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;flamegraph.pl&lt;/a&gt;生成SVG火焰图。&lt;/p&gt;
&lt;p&gt;我们先把FlameGraph项目clone下来，后面会用到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/brendangregg/FlameGraph.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;java-cpu-profiling&#34;&gt;Java CPU Profiling&lt;/h2&gt;
&lt;p&gt;虽然有很多Java专用的&lt;code&gt;profiler&lt;/code&gt;工具，但这些工具一般只能看到Java方法的执行，缺少了&lt;code&gt;GC&lt;/code&gt;，&lt;code&gt;JVM&lt;/code&gt;的CPU时间消耗，并且有些工具的&lt;code&gt;Method tracing&lt;/code&gt;性能损耗比较大。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;BCC profile&lt;/code&gt;的优点是它很高效，在内核上下文中对堆栈进行计数，并能完整显示用户态和内核态的CPU使用，能看到native libraries（例如libc），JVM（libjvm），Java方法和内核中花费的时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241118729.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;java-profilers&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;但是，&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;BCC profile&lt;/code&gt;这种系统级的profiler不能很好地与Java配合使用，它们识别不了Java方法和&lt;code&gt;stack traces&lt;/code&gt;。这是因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM的&lt;code&gt;JIT（just-in-time）&lt;/code&gt;没有给系统级profiler公开符号表&lt;/li&gt;
&lt;li&gt;JVM还使用帧指针寄存器（frame pointer register，x86-64上的RBP）作为通用寄存器，打破了传统的堆栈遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了能生成包含Java栈与Native栈的火焰图，目前有两种解决方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;JVMTI&lt;/code&gt; agent &lt;a class=&#34;link&#34; href=&#34;https://github.com/jvm-profiling-tools/perf-map-agent&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;perf-map-agent&lt;/a&gt;，生成Java符号表，供&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;bcc&lt;/code&gt;读取（/tmp/perf-PID.map）。同时要加上&lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt; JVM 参数，让&lt;code&gt;perf&lt;/code&gt;可以遍历基于帧指针（frame pointer）的堆栈。&lt;/li&gt;
&lt;li&gt;使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/jvm-profiling-tools/async-profiler&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;async-profiler&lt;/a&gt;，该项目将&lt;code&gt;perf&lt;/code&gt;的堆栈追踪和JDK提供的&lt;a class=&#34;link&#34; href=&#34;http://psy-lob-saw.blogspot.com/2016/06/the-pros-and-cons-of-agct.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AsyncGetCallTrace&lt;/a&gt;结合了起来，同样能够获得mixed-mode火焰图。同时，此方法不需要启用帧指针，所以不用加上&lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt;参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们就分别演示这两种方式。&lt;/p&gt;
&lt;h3 id=&#34;perf-map-agent&#34;&gt;perf-map-agent&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt;期望能从&lt;code&gt;/tmp/perf-&amp;lt;pid&amp;gt;.map&lt;/code&gt;中获得在未知内存区域执行的代码的符号表。&lt;code&gt;perf-map-agent&lt;/code&gt;可以为&lt;code&gt;JIT&lt;/code&gt;编译的方法生成&lt;code&gt;/tmp/perf-&amp;lt;pid&amp;gt;.map&lt;/code&gt;文件，以满足&lt;code&gt;perf&lt;/code&gt;的要求。&lt;/p&gt;
&lt;p&gt;首先下载并编译&lt;code&gt;perf-map-agent&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/jvm-profiling-tools/perf-map-agent.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cd perf-map-agent
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;配合perf使用&#34;&gt;配合&lt;code&gt;perf&lt;/code&gt;使用&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;perf-map-agent&lt;/code&gt;提供了&lt;a class=&#34;link&#34; href=&#34;https://github.com/jvm-profiling-tools/perf-map-agent/blob/master/bin/perf-java-flames&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;perf-java-flames&lt;/a&gt;脚本，可以一步生成火焰图。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf-java-flames&lt;/code&gt;接收&lt;code&gt;perf record&lt;/code&gt;命令参数，它会调用&lt;code&gt;perf&lt;/code&gt;进行采样，然后使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/brendangregg/FlameGraph&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;FlameGraph&lt;/a&gt;生成火焰图，一步完成，非常方便。&lt;/p&gt;
&lt;p&gt;注意，记得要给被&lt;code&gt;profiling&lt;/code&gt;的Java进程加上&lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt; JVM 参数。&lt;/p&gt;
&lt;p&gt;设置必要的环境变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;export FLAMEGRAPH_DIR=[FlameGraph 所在的目录]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;export PERF_RECORD_SECONDS=[采样时间]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./bin/perf-java-flames  [PID] -F 99 -a -g -p [PID]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对指定进程（&lt;strong&gt;-p PID&lt;/strong&gt;），在所有CPU（&lt;strong&gt;-a&lt;/strong&gt;）上进行call stacks（&lt;strong&gt;-g&lt;/strong&gt;）采样，采样频率为99 Hertz （&lt;strong&gt;-F 99&lt;/strong&gt;），持续时间为&lt;code&gt;PERF_RECORD_SECONDS&lt;/code&gt;秒。命令运行完成后，会在当前目录生成名为&lt;code&gt;flamegraph-pid.svg&lt;/code&gt;的火焰图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241119221.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;java-flamegraph&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./bin/perf-java-flames  [PID] -F 99 -g -a -e context-switches -p [PID]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对指定进程的上下文切换（&lt;strong&gt;-e context-switches&lt;/strong&gt;）进行采样，并生成火焰图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当然也可以只为&lt;code&gt;perf&lt;/code&gt;生成Java符号表，然后直接使用perf采样&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./bin/create-java-perf-map.sh [PID]; sudo perf record -F 99 -p [PID] -a -g -- sleep 15
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./bin/create-java-perf-map.sh [PID]; sudo perf record -g -a -e context-switches -p [PID] sleep 15
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 查看报告
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo perf report --stdio
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;配合bcc-profile使用&#34;&gt;配合&lt;code&gt;bcc profile&lt;/code&gt;使用&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;FlameGraph&lt;/code&gt;项目提供了&lt;a class=&#34;link&#34; href=&#34;https://github.com/brendangregg/FlameGraph/blob/master/jmaps&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;jmaps&lt;/a&gt;脚本，它会调用&lt;code&gt;perf-map-agent&lt;/code&gt;为当前运行的所有Java进程生成符号表。&lt;/p&gt;
&lt;p&gt;首先为&lt;code&gt;jmaps&lt;/code&gt;脚本设置好&lt;code&gt;JAVA_HOME&lt;/code&gt;和&lt;code&gt;perf-map-agent&lt;/code&gt;的正确位置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;JAVA_HOME=${JAVA_HOME:-/usr/lib/jvm/java-8-oracle}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;AGENT_HOME=${AGENT_HOME:-/usr/lib/jvm/perf-map-agent} # from https://github.com/jvm-profiling-tools/perf-map-agent
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行&lt;code&gt;jmaps&lt;/code&gt;，可以看到它会为当前所有的Java进程生成符号表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ./jmaps
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Fetching maps for all java processes...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Mapping PID 30711 (user adp):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wc(1):   3486  10896 214413 /tmp/perf-30711.map
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们在做任何&lt;code&gt;profiling&lt;/code&gt;之前，都需要调用&lt;code&gt;jmaps&lt;/code&gt;，保持符号表是最新的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU Profiling火焰图&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Profiling
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ./jmaps ; sudo /usr/share/bcc/tools/profile -dF 99 -afp [PID] 10 &amp;gt; out.profile01.txt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 生成火焰图
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./flamegraph.pl --color=java --hash &amp;lt;out.profile01.txt &amp;gt; flamegraph.svg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;off-CPU火焰图&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Profiling
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ./jmaps ; sudo /usr/share/bcc/tools/offcputime -fp [PID] 10 &amp;gt; out.offcpu01.txt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 生成火焰图
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./flamegraph.pl --color=java --bgcolor=blue --hash --countname=us --width=1024 --title=&amp;#34;Off-CPU Time Flame Graph&amp;#34; &amp;lt; out.offcpu01.txt &amp;gt; out.offcpu01.svg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;off-CPU，并过滤指定的进程状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux的进程状态有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TASK_RUNNING&lt;/td&gt;
&lt;td&gt;意味着进程处于可运行状态。这并不意味着已经实际分配了CPU。进程可能会一直等到调度器选中它。该状态确保进程可以立即运行，而无需等待外部事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TASK_INTERRUPTIBLE&lt;/td&gt;
&lt;td&gt;可中断的等待状态，主要为恢复时间无法预测的长时间等待。例如等待来自用户的输入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TASK_UNINTERRUPTIBLE&lt;/td&gt;
&lt;td&gt;不可中断的等待状态。用于因内核指示而停用的睡眠进程。它们不能由外部信号唤醒，只能由内核亲自唤醒。例如磁盘输入输出等待。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TASK_STOPPED&lt;/td&gt;
&lt;td&gt;响应暂停信号而运行中断的状态。直到恢复前都不会被调度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TASK_ZOMBIE&lt;/td&gt;
&lt;td&gt;僵尸状态，子进程已经终止，但父进程尚未执行wait()，因此该进程的资源没有被系统释放。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在状态&lt;code&gt;TASK_RUNNING&lt;/code&gt;（0）会发生非自愿上下文切换，而我们通常感兴趣的阻塞事件是&lt;code&gt;TASK_INTERRUPTIBLE&lt;/code&gt;（1）或&lt;code&gt;TASK_UNINTERRUPTIBLE&lt;/code&gt;（2），&lt;code&gt;offcputime&lt;/code&gt;可以用&lt;code&gt;--state&lt;/code&gt;过滤指定的进程状态：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Profiling
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ./jmaps ; sudo /usr/share/bcc/tools/offcputime -K --state 2 -f 30 &amp;gt; out.offcpu01.txt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 生成火焰图
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./flamegraph.pl --color=io --countname=ms &amp;lt; out.offcpu01.txt &amp;gt; out.offcpu01.svg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;async-profiler&#34;&gt;async-profiler&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jvm-profiling-tools/async-profiler&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;async-profiler&lt;/a&gt;将&lt;code&gt;perf&lt;/code&gt;的堆栈追踪和JDK提供的&lt;a class=&#34;link&#34; href=&#34;http://psy-lob-saw.blogspot.com/2016/06/the-pros-and-cons-of-agct.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AsyncGetCallTrace&lt;/a&gt;结合了起来，做到同时采样Java栈与Native栈，因此也就可以同时分析Java代码和Native代码中存在的性能热点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AsyncGetCallTrace&lt;/code&gt;是JDK内部提供的一个函数，它的原型如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;typedef struct {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  jint lineno;         // BCI in the source file
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  jmethodID method_id; // method executed in this frame
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;} ASGCT_CallFrame;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;typedef struct {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  JNIEnv *env_id   //Env where trace was recorded
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  jint num_frames; // number of frames in this trace
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ASGCT_CallFrame *frames;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;} ASGCT_CallTrace; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void AsyncGetCallTrace(ASGCT_CallTrace *trace, // pre-allocated trace to fill
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                       jint depth,             // max number of frames to walk up the stack
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                       void* ucontext)         // signal context
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看出，该函数直接通过&lt;code&gt;ucontext&lt;/code&gt;就能获取到完整的Java调用栈。&lt;/p&gt;
&lt;h4 id=&#34;async-profiler的使用&#34;&gt;async-profiler的使用&lt;/h4&gt;
&lt;p&gt;下载并解压好&lt;code&gt;async-profiler&lt;/code&gt;安装包。&lt;/p&gt;
&lt;p&gt;从Linux 4.6开始，从&lt;code&gt;non-root&lt;/code&gt;进程使用&lt;code&gt;perf&lt;/code&gt;捕获内核的&lt;code&gt;call stacks&lt;/code&gt;，需要设置如下两个内核参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# echo 1 &amp;gt; /proc/sys/kernel/perf_event_paranoid
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# echo 0 &amp;gt; /proc/sys/kernel/kptr_restrict
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;async-profiler&lt;/code&gt;的使用非常简单，一步就能生成火焰图。另外，也不需要为被&lt;code&gt;profiling&lt;/code&gt;的Java进程设置&lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt;参数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./profiler.sh -d 30 -f /tmp/flamegraph.svg [PID]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241119380.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;async-profiler&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;为Java生成&lt;code&gt;CPU profiling&lt;/code&gt;火焰图，基本的流程都是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用工具采集样本&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;FlameGraph&lt;/code&gt;项目提供的脚本，将采集的样本归纳合并，统计出&lt;code&gt;Stack Trace&lt;/code&gt;出现的频率&lt;/li&gt;
&lt;li&gt;最后使用&lt;code&gt;flamegraph.pl&lt;/code&gt;利用上一步的输出，绘制SVG火焰图&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了能够生成&lt;code&gt;Java stacks&lt;/code&gt;和&lt;code&gt;native stacks&lt;/code&gt;完整的火焰图，解决&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;bcc profile&lt;/code&gt;不能识别Java符号和Java &lt;code&gt;stack traces&lt;/code&gt;的问题，目前有以下两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;perf-map-agent&lt;/code&gt; 加上 &lt;code&gt;perf&lt;/code&gt;或&lt;code&gt;bcc profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;async-profiler&lt;/code&gt;（内部会使用到&lt;code&gt;perf&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果只是对Java进程做&lt;code&gt;on-CPU&lt;/code&gt;分析，&lt;code&gt;async-profiler&lt;/code&gt;更加方便好用。如果需要更全面的了解Java进程的运行情况，例如分析系统锁的开销，阻塞的 I/O 操作，以及进程调度器（&lt;code&gt;scheduler&lt;/code&gt;）的工作，那么还是需要使用功能更强大的&lt;code&gt;perf&lt;/code&gt;和&lt;code&gt;bcc&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/perf.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;perf Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/ebpf.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux Extended BPF (eBPF) Tracing Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/bpf-performance-tools-book.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BPF Performance Tools (book)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/offcpuanalysis.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Off-CPU Analysis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Flame Graphs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Linux TCP队列相关参数的总结</title>
        <link>https://mazhen.tech/p/linux-tcp%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93/</link>
        <pubDate>Sat, 16 Aug 2014 11:11:24 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/linux-tcp%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93/</guid>
        <description>&lt;p&gt;在Linux上做网络应用的性能优化时，一般都会对TCP相关的内核参数进行调节，特别是和缓冲、队列有关的参数。网上搜到的文章会告诉你需要修改哪些参数，但我们经常是知其然而不知其所以然，每次照抄过来后，可能很快就忘记或混淆了它们的含义。本文尝试总结TCP队列缓冲相关的内核参数，从协议栈的角度梳理它们，希望可以更容易的理解和记忆。注意，本文内容均来源于参考文档，没有去读相关的内核源码做验证，不能保证内容严谨正确。作为Java程序员没读过内核源码是硬伤。&lt;/p&gt;
&lt;p&gt;下面我以server端为视角，从&lt;strong&gt;连接建立&lt;/strong&gt;、&lt;strong&gt;数据包接收&lt;/strong&gt;和&lt;strong&gt;数据包发送&lt;/strong&gt;这3条路径对参数进行归类梳理。&lt;/p&gt;
&lt;h3 id=&#34;一连接建立&#34;&gt;一、连接建立&lt;/h3&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;简单看下连接的建立过程，客户端向server发送&lt;code&gt;SYN&lt;/code&gt;包，server回复&lt;code&gt;SYN＋ACK&lt;/code&gt;，同时将这个处于&lt;code&gt;SYN_RECV&lt;/code&gt;状态的连接保存到半连接队列。客户端返回&lt;code&gt;ACK&lt;/code&gt;包完成三次握手，server将&lt;code&gt;ESTABLISHED&lt;/code&gt;状态的连接移入&lt;code&gt;accept&lt;/code&gt;队列，等待应用调用&lt;code&gt;accept()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以看到建立连接涉及两个队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;半连接队列&lt;/strong&gt;，保存&lt;code&gt;SYN_RECV&lt;/code&gt;状态的连接。队列长度由&lt;code&gt;net.ipv4.tcp_max_syn_backlog&lt;/code&gt;设置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;accept队列&lt;/strong&gt;，保存&lt;code&gt;ESTABLISHED&lt;/code&gt;状态的连接。队列长度为&lt;code&gt;min(net.core.somaxconn, backlog)&lt;/code&gt;。其中&lt;code&gt;backlog&lt;/code&gt;是我们创建&lt;code&gt;ServerSocket(int port,int backlog)&lt;/code&gt;时指定的参数，最终会传递给&lt;code&gt;listen&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;#include &amp;lt;sys/socket.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int listen(int sockfd, int backlog);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们设置的&lt;code&gt;backlog&lt;/code&gt;大于&lt;code&gt;net.core.somaxconn&lt;/code&gt;，&lt;code&gt;accept&lt;/code&gt;队列的长度将被设置为&lt;code&gt;net.core.somaxconn&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外，为了应对&lt;code&gt;SYN flooding&lt;/code&gt;（即客户端只发送SYN包发起握手而不回应ACK完成连接建立，填满server端的半连接队列，让它无法处理正常的握手请求），Linux实现了一种称为&lt;code&gt;SYN cookie&lt;/code&gt;的机制，通过&lt;code&gt;net.ipv4.tcp_syncookies&lt;/code&gt;控制，设置为1表示开启。简单说&lt;code&gt;SYN cookie&lt;/code&gt;就是将连接信息编码在&lt;code&gt;ISN&lt;/code&gt;(initial sequence number)中返回给客户端，这时server不需要将半连接保存在队列中，而是利用客户端随后发来的ACK带回的&lt;code&gt;ISN&lt;/code&gt;还原连接信息，以完成连接的建立，避免了半连接队列被攻击&lt;code&gt;SYN&lt;/code&gt;包填满。对于一去不复返的客户端握手，不理它就是了。&lt;/p&gt;
&lt;h3 id=&#34;二数据包的接收&#34;&gt;二、数据包的接收&lt;/h3&gt;
&lt;p&gt;先看看接收数据包经过的路径：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;数据包的接收，从下往上经过了三层：网卡驱动、系统内核空间，最后到用户态空间的应用。Linux内核使用&lt;code&gt;sk_buff&lt;/code&gt;(&lt;a class=&#34;link&#34; href=&#34;http://vger.kernel.org/~davem/skb.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;socket kernel buffers&lt;/a&gt;)数据结构描述一个数据包。当一个新的数据包到达，&lt;code&gt;NIC&lt;/code&gt;（network interface controller）调用&lt;code&gt;DMA engine&lt;/code&gt;，通过&lt;code&gt;Ring Buffer&lt;/code&gt;将数据包放置到内核内存区。&lt;code&gt;Ring Buffer&lt;/code&gt;的大小固定，它不包含实际的数据包，而是包含了指向&lt;code&gt;sk_buff&lt;/code&gt;的描述符。当&lt;code&gt;Ring Buffer&lt;/code&gt;满的时候，新来的数据包将给丢弃。一旦数据包被成功接收，&lt;code&gt;NIC&lt;/code&gt;发起中断，由内核的中断处理程序将数据包传递给IP层。经过IP层的处理，数据包被放入队列等待TCP层处理。每个数据包经过TCP层一系列复杂的步骤，更新TCP状态机，最终到达&lt;code&gt;recv Buffer&lt;/code&gt;，等待被应用接收处理。有一点需要注意，数据包到达&lt;code&gt;recv Buffer&lt;/code&gt;，TCP就会回&lt;code&gt;ACK&lt;/code&gt;确认，既TCP的&lt;code&gt;ACK&lt;/code&gt;表示数据包已经被操作系统内核收到，但并不确保应用层一定收到数据（例如这个时候系统crash），因此一般建议应用协议层也要设计自己的&lt;code&gt;ACK&lt;/code&gt;确认机制。&lt;/p&gt;
&lt;p&gt;上面就是一个相当简化的数据包接收流程，让我们逐层看看队列缓冲有关的参数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;网卡Bonding模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当主机有1个以上的网卡时，Linux会将多个网卡绑定为一个虚拟的bonded网络接口，对TCP/IP而言只存在一个bonded网卡。多网卡绑定一方面能够提高网络吞吐量，另一方面也可以增强网络高可用。Linux支持7种Bonding模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- `Mode 0 (balance-rr)` Round-robin策略，这个模式具备负载均衡和容错能力
- `Mode 1 (active-backup)` 主备策略，在绑定中只有一个网卡被激活，其他处于备份状态
- `Mode 2 (balance-xor)` XOR策略，通过源MAC地址与目的MAC地址做异或操作选择slave网卡
- `Mode 3 (broadcast)` 广播，在所有的网卡上传送所有的报文
- `Mode 4 (802.3ad)`  IEEE 802.3ad 动态链路聚合。创建共享相同的速率和双工模式的聚合组
- `Mode 5 (balance-tlb)` Adaptive transmit load balancing
- `Mode 6 (balance-alb)` Adaptive load balancing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;详细的说明参考内核文档&lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/Documentation/networking/bonding.txt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux Ethernet Bonding Driver HOWTO&lt;/a&gt;。我们可以通过&lt;code&gt;cat /proc/net/bonding/bond0&lt;/code&gt;查看本机的Bonding模式：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;一般很少需要开发去设置网卡Bonding模式，自己实验的话可以参考&lt;a class=&#34;link&#34; href=&#34;http://linux.cloudibee.com/2009/10/linux-network-bonding-setup-guide/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这篇文档&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;网卡多队列及中断绑定&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;随着网络的带宽的不断提升，单核CPU已经不能满足网卡的需求，这时通过多队列网卡驱动的支持，可以将每个队列通过中断绑定到不同的CPU核上，充分利用多核提升数据包的处理能力。&lt;/p&gt;
&lt;p&gt;首先查看网卡是否支持多队列，使用&lt;code&gt;lspci -vvv&lt;/code&gt;命令，找到&lt;code&gt;Ethernet controller&lt;/code&gt;项：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如果有MSI-X， Enable+ 并且Count &amp;gt; 1，则该网卡是多队列网卡。&lt;/p&gt;
&lt;p&gt;然后查看是否打开了网卡多队列。使用命令&lt;code&gt;cat /proc/interrupts&lt;/code&gt;，如果看到eth0-TxRx-0表明多队列支持已经打开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011115744.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;最后确认每个队列是否绑定到不同的CPU。&lt;code&gt;cat /proc/interrupts&lt;/code&gt;查询到每个队列的中断号，对应的文件&lt;code&gt;/proc/irq/${IRQ_NUM}/smp_affinity&lt;/code&gt;为中断号&lt;code&gt;IRQ_NUM&lt;/code&gt;绑定的CPU核的情况。以十六进制表示，每一位代表一个CPU核：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```
（00000001）代表CPU0
（00000010）代表CPU1
（00000011）代表CPU0和CPU1
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果绑定的不均衡，可以手工设置，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```
echo &amp;quot;1&amp;quot; &amp;gt; /proc/irq/99/smp_affinity  
echo &amp;quot;2&amp;quot; &amp;gt; /proc/irq/100/smp_affinity  
echo &amp;quot;4&amp;quot; &amp;gt; /proc/irq/101/smp_affinity  
echo &amp;quot;8&amp;quot; &amp;gt; /proc/irq/102/smp_affinity  
echo &amp;quot;10&amp;quot; &amp;gt; /proc/irq/103/smp_affinity  
echo &amp;quot;20&amp;quot; &amp;gt; /proc/irq/104/smp_affinity  
echo &amp;quot;40&amp;quot; &amp;gt; /proc/irq/105/smp_affinity  
echo &amp;quot;80&amp;quot; &amp;gt; /proc/irq/106/smp_affinity  
```
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ring Buffer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ring Buffer&lt;/code&gt;位于NIC和IP层之间，是一个典型的FIFO（先进先出）&lt;a class=&#34;link&#34; href=&#34;http://en.wikipedia.org/wiki/Circular_buffer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;环形队列&lt;/a&gt;。&lt;code&gt;Ring Buffer&lt;/code&gt;没有包含数据本身，而是包含了指向&lt;code&gt;sk_buff&lt;/code&gt;（&lt;a class=&#34;link&#34; href=&#34;http://vger.kernel.org/~davem/skb.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;socket kernel buffers&lt;/a&gt;）的描述符。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以使用&lt;code&gt;ethtool -g eth0&lt;/code&gt;查看当前&lt;code&gt;Ring Buffer&lt;/code&gt;的设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011116458.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上面的例子接收队列为4096，传输队列为256。可以通过&lt;code&gt;ifconfig&lt;/code&gt;观察接收和传输队列的运行状况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011116204.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RX errors&lt;/strong&gt;：收包总的错误数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RX dropped&lt;/strong&gt;: 表示数据包已经进入了&lt;code&gt;Ring Buffer&lt;/code&gt;，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RX overruns&lt;/strong&gt;: &lt;code&gt;overruns&lt;/code&gt;意味着数据包没到&lt;code&gt;Ring Buffer&lt;/code&gt;就被网卡物理层给丢弃了，而CPU无法及时的处理中断是造成&lt;code&gt;Ring Buffer&lt;/code&gt;满的原因之一，例如中断分配的不均匀。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;dropped&lt;/code&gt;数量持续增加，建议增大&lt;code&gt;Ring Buffer&lt;/code&gt;，使用&lt;code&gt;ethtool -G&lt;/code&gt;进行设置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;Input Packet Queue(数据包接收队列)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当接收数据包的速率大于内核TCP处理包的速率，数据包将会缓冲在TCP层之前的队列中。接收队列的长度由参数&lt;code&gt;net.core.netdev_max_backlog&lt;/code&gt;设置。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;recv Buffer&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;recv buffer&lt;/code&gt;是调节TCP性能的关键参数。&lt;code&gt;BDP&lt;/code&gt;(Bandwidth-delay product，带宽延迟积) 是网络的带宽和与&lt;code&gt;RTT&lt;/code&gt;(round trip time)的乘积，&lt;code&gt;BDP&lt;/code&gt;的含义是任意时刻处于在途未确认的最大数据量。&lt;code&gt;RTT&lt;/code&gt;使用&lt;code&gt;ping&lt;/code&gt;命令可以很容易的得到。为了达到最大的吞吐量，&lt;code&gt;recv Buffer&lt;/code&gt;的设置应该大于&lt;code&gt;BDP&lt;/code&gt;，即&lt;code&gt;recv Buffer &amp;gt;= bandwidth * RTT&lt;/code&gt;。假设带宽是100Mbps，&lt;code&gt;RTT&lt;/code&gt;是100ms，那么&lt;code&gt;BDP&lt;/code&gt;的计算如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;BDP = 100Mbps * 100ms = (100 / 8) * (100 / 1000) = 1.25MB
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Linux在2.6.17以后增加了&lt;code&gt;recv Buffer&lt;/code&gt;自动调节机制，&lt;code&gt;recv buffer&lt;/code&gt;的实际大小会自动在最小值和最大值之间浮动，以期找到性能和资源的平衡点，因此大多数情况下不建议将&lt;code&gt;recv buffer&lt;/code&gt;手工设置成固定值。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;net.ipv4.tcp_moderate_rcvbuf&lt;/code&gt;设置为1时，自动调节机制生效，每个TCP连接的recv Buffer由下面的3元数组指定：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;net.ipv4.tcp_rmem = &amp;lt;MIN&amp;gt; &amp;lt;DEFAULT&amp;gt; &amp;lt;MAX&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最初&lt;code&gt;recv buffer&lt;/code&gt;被设置为&lt;!-- raw HTML omitted --&gt;，同时这个缺省值会覆盖&lt;code&gt;net.core.rmem_default&lt;/code&gt;的设置。随后&lt;code&gt;recv buffer&lt;/code&gt;根据实际情况在最大值和最小值之间动态调节。在缓冲的动态调优机制开启的情况下，我们将&lt;code&gt;net.ipv4.tcp_rmem&lt;/code&gt;的最大值设置为&lt;code&gt;BDP&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;net.ipv4.tcp_moderate_rcvbuf&lt;/code&gt;被设置为0，或者设置了socket选项&lt;code&gt;SO_RCVBUF&lt;/code&gt;，缓冲的动态调节机制被关闭。&lt;code&gt;recv buffer&lt;/code&gt;的缺省值由&lt;code&gt;net.core.rmem_default&lt;/code&gt;设置，但如果设置了&lt;code&gt;net.ipv4.tcp_rmem&lt;/code&gt;，缺省值则被&lt;code&gt;&amp;lt;DEFAULT&amp;gt;&lt;/code&gt;覆盖。可以通过系统调用&lt;code&gt;setsockopt()&lt;/code&gt;设置&lt;code&gt;recv buffer&lt;/code&gt;的最大值为&lt;code&gt;net.core.rmem_max&lt;/code&gt;。在缓冲动态调节机制关闭的情况下，建议把缓冲的缺省值设置为&lt;code&gt;BDP&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意这里还有一个细节，缓冲除了保存接收的数据本身，还需要一部分空间保存socket数据结构等额外信息。因此上面讨论的&lt;code&gt;recv buffer&lt;/code&gt;最佳值仅仅等于&lt;code&gt;BDP&lt;/code&gt;是不够的，还需要考虑保存socket等额外信息的开销。Linux根据参数&lt;code&gt;net.ipv4.tcp_adv_win_scale&lt;/code&gt;计算额外开销的大小：&lt;/p&gt;
&lt;p&gt;Buffer / 2&lt;!-- raw HTML omitted --&gt;tcp_adv_win_scale&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;net.ipv4.tcp_adv_win_scale&lt;/code&gt;的值为1，则二分之一的缓冲空间用来做额外开销，如果为2的话，则四分之一缓冲空间用来做额外开销。因此&lt;code&gt;recv buffer&lt;/code&gt;的最佳值应该设置为：&lt;/p&gt;
&lt;p&gt;BDP / (1 – 1 / 2&lt;!-- raw HTML omitted --&gt;tcp_adv_win_scale&lt;!-- raw HTML omitted --&gt;)&lt;/p&gt;
&lt;h3 id=&#34;三数据包的发送&#34;&gt;三、数据包的发送&lt;/h3&gt;
&lt;p&gt;发送数据包经过的路径：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;和接收数据的路径相反，数据包的发送从上往下也经过了三层：用户态空间的应用、系统内核空间、最后到网卡驱动。应用先将数据写入TCP &lt;code&gt;send buffer&lt;/code&gt;，TCP层将&lt;code&gt;send buffer&lt;/code&gt;中的数据构建成数据包转交给IP层。IP层会将待发送的数据包放入队列&lt;code&gt;QDisc&lt;/code&gt;(queueing discipline)。数据包成功放入&lt;code&gt;QDisc&lt;/code&gt;后，指向数据包的描述符&lt;code&gt;sk_buff&lt;/code&gt;被放入&lt;code&gt;Ring Buffer&lt;/code&gt;输出队列，随后网卡驱动调用&lt;code&gt;DMA engine&lt;/code&gt;将数据发送到网络链路上。&lt;/p&gt;
&lt;p&gt;同样我们逐层来梳理队列缓冲有关的参数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;send Buffer&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同&lt;code&gt;recv Buffer&lt;/code&gt;类似，和&lt;code&gt;send Buffer&lt;/code&gt;有关的参数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;net.ipv4.tcp_wmem = &amp;lt;MIN&amp;gt; &amp;lt;DEFAULT&amp;gt; &amp;lt;MAX&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;net.core.wmem_default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;net.core.wmem_max
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;发送端缓冲的自动调节机制很早就已经实现，并且是无条件开启，没有参数去设置。如果指定了&lt;code&gt;tcp_wmem&lt;/code&gt;，则&lt;code&gt;net.core.wmem_default&lt;/code&gt;被&lt;code&gt;tcp_wmem&lt;/code&gt;的&lt;!-- raw HTML omitted --&gt;覆盖。&lt;code&gt;send Buffer&lt;/code&gt;在&lt;code&gt;tcp_wmem&lt;/code&gt;的最小值和最大值之间自动调节。如果调用&lt;code&gt;setsockopt()&lt;/code&gt;设置了socket选项&lt;code&gt;SO_SNDBUF&lt;/code&gt;，将关闭发送端缓冲的自动调节机制，&lt;code&gt;tcp_wmem&lt;/code&gt;将被忽略，&lt;code&gt;SO_SNDBUF&lt;/code&gt;的最大值由&lt;code&gt;net.core.wmem_max&lt;/code&gt;限制。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;QDisc&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;QDisc&lt;/code&gt;（queueing discipline ）位于IP层和网卡的&lt;code&gt;ring buffer&lt;/code&gt;之间。我们已经知道，&lt;code&gt;ring buffer&lt;/code&gt;是一个简单的FIFO队列，这种设计使网卡的驱动层保持简单和快速。而&lt;code&gt;QDisc&lt;/code&gt;实现了流量管理的高级功能，包括流量分类，优先级和流量整形（rate-shaping）。可以使用&lt;code&gt;tc&lt;/code&gt;命令配置&lt;code&gt;QDisc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QDisc&lt;/code&gt;的队列长度由&lt;code&gt;txqueuelen&lt;/code&gt;设置，和接收数据包的队列长度由内核参数&lt;code&gt;net.core.netdev_max_backlog&lt;/code&gt;控制所不同，&lt;code&gt;txqueuelen&lt;/code&gt;是和网卡关联，可以用&lt;code&gt;ifconfig&lt;/code&gt;命令查看当前的大小：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011117299.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;ifconfig&lt;/code&gt;调整&lt;code&gt;txqueuelen&lt;/code&gt;的大小：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ifconfig eth0 txqueuelen 2000
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;Ring Buffer&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和数据包的接收一样，发送数据包也要经过&lt;code&gt;Ring Buffer&lt;/code&gt;，使用&lt;code&gt;ethtool -g eth0&lt;/code&gt;查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011118456.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;TX&lt;/code&gt;项是&lt;code&gt;Ring Buffer&lt;/code&gt;的传输队列，也就是发送队列的长度。设置也是使用命令&lt;code&gt;ethtool -G&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;TCP Segmentation和Checksum Offloading&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作系统可以把一些TCP/IP的功能转交给网卡去完成，特别是Segmentation(分片)和checksum的计算，这样可以节省CPU资源，并且由硬件代替&lt;code&gt;OS&lt;/code&gt;执行这些操作会带来性能的提升。&lt;/p&gt;
&lt;p&gt;一般以太网的&lt;code&gt;MTU&lt;/code&gt;（Maximum Transmission Unit）为1500 bytes，假设应用要发送数据包的大小为7300bytes，&lt;code&gt;MTU&lt;/code&gt;1500字节 － IP头部20字节 － TCP头部20字节＝有效负载为1460字节，因此7300字节需要拆分成5个segment：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011118576.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Segmentation&lt;/code&gt;(分片)操作可以由操作系统移交给网卡完成，虽然最终线路上仍然是传输5个包，但这样节省了CPU资源并带来性能的提升：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011118473.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;ethtool -k eth0&lt;/code&gt;查看网卡当前的offloading情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011119505.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上面这个例子&lt;code&gt;checksum&lt;/code&gt;和&lt;code&gt;tcp segmentation&lt;/code&gt;的&lt;code&gt;offloading&lt;/code&gt;都是打开的。如果想设置网卡的&lt;code&gt;offloading&lt;/code&gt;开关，可以使用&lt;code&gt;ethtool -K&lt;/code&gt;(注意K是大写)命令，例如下面的命令关闭了tcp segmentation offload：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ethtool -K eth0 tso off
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;网卡多队列和网卡Bonding模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在数据包的接收过程中已经介绍过了。&lt;/p&gt;
&lt;p&gt;至此，终于梳理完毕。整理TCP队列相关参数的起因是最近在排查一个网络超时问题，原因还没有找到，产生的“副作用”就是这篇文档。再想深入解决这个问题可能需要做TCP协议代码的profile，需要继续学习，希望不久的将来就可以再写文档和大家分享了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文档&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.linuxjournal.com/content/queueing-linux-network-stack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Queueing in the Linux Network Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.ece.virginia.edu/cheetah/documents/papers/TCPlinux.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TCP Implementation in Linux: A Brief Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://sandilands.info/sgordon/impact-of-bandwidth-delay-product-on-tcp-throughput&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Impact of Bandwidth Delay Product on TCP Throughput&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://hellojava.info/?p=292&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java程序员也应该知道的系统知识系列之网卡&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Linux内核参数的配置方法</title>
        <link>https://mazhen.tech/p/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</link>
        <pubDate>Fri, 30 May 2014 20:21:08 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</guid>
        <description>&lt;p&gt;&lt;code&gt;/proc&lt;/code&gt;是一个伪文件系统，可以像访问普通文件系统一样访问系统内部的数据结构，获取当前运行的进程、统计和硬件等各种信息。例如可以使用&lt;code&gt;cat /proc/cpuinfo&lt;/code&gt;获取CPU信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc/sys/&lt;/code&gt;下的文件和子目录比较特别，它们对应的是系统内核参数，更改文件内容就意味着修改了相应的内核参数，可以简单的使用&lt;code&gt;echo&lt;/code&gt;命令来完成修改：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/tcp_syncookies
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面这个命令启用了&lt;code&gt;TCP SYN Cookie&lt;/code&gt;保护。使用&lt;code&gt;echo&lt;/code&gt;修改内核参数很方便，但是系统重启后这些修改都会消失，而且不方便配置参数的集中管理。&lt;code&gt;/sbin/sysctl&lt;/code&gt;命令就是用来查看和修改内核参数的工具。&lt;code&gt;sysctl -a&lt;/code&gt;会列出所有内核参数当前的配置信息，比遍历目录&lt;code&gt;/proc/sys/&lt;/code&gt;方便多了。&lt;code&gt;sysctl -w&lt;/code&gt;修改单个参数的配置，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sysctl -w net.ipv4.tcp_syncookies=1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;和上面&lt;code&gt;echo&lt;/code&gt;命令的效果一样。需要注意的是，要把目录分隔符斜杠&lt;code&gt;/&lt;/code&gt;替换为点&lt;code&gt;.&lt;/code&gt;，并省略&lt;code&gt;proc.sys&lt;/code&gt;部分。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;sysctl -w&lt;/code&gt;修改，还是没有解决重启后修改失效的问题。更常用的方式是，把需要修改的配置集中放在&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;文件中，使用&lt;code&gt;sysctl -p&lt;/code&gt;重新加载配置使其生效。在系统启动阶段，&lt;code&gt;init&lt;/code&gt;程序会运行&lt;code&gt;/etc/rc.d/rc.sysinit&lt;/code&gt;脚本，其中包含了执行&lt;code&gt;sysctl&lt;/code&gt;命令，并使用了&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;中的配置信息。因此放在&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;中的系统参数设置在重启后也同样生效，同时也便于集中管理修改过了哪些内核参数。&lt;/p&gt;
&lt;p&gt;最后，哪里有比较完整的内核参数说明文档？我觉得&lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/Documentation/sysctl/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;kernel.org&lt;/a&gt;的文档比较全。例如我们常会遇到的网络内核参数，&lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/Documentation/sysctl/net.txt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;net.core&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;net.ipv4&lt;/a&gt; 。TCP相关的参数，也可以通过&lt;a class=&#34;link&#34; href=&#34;http://man7.org/linux/man-pages/man7/tcp.7.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;man文档&lt;/a&gt;了解。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
