<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Perf on mazhen.tech</title>
        <link>https://mazhen.tech/tags/perf/</link>
        <description>Recent content in Perf on mazhen.tech</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 19 Sep 2025 09:47:41 +0800</lastBuildDate><atom:link href="https://mazhen.tech/tags/perf/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>使用 DWARF 还原完整的 glibc 调用堆栈</title>
        <link>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8-dwarf-%E8%BF%98%E5%8E%9F%E5%AE%8C%E6%95%B4%E7%9A%84-glibc-%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/</link>
        <pubDate>Fri, 19 Sep 2025 09:47:41 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E4%BD%BF%E7%94%A8-dwarf-%E8%BF%98%E5%8E%9F%E5%AE%8C%E6%95%B4%E7%9A%84-glibc-%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/</guid>
        <description>&lt;p&gt;在上一篇文章&lt;a class=&#34;link&#34; href=&#34;https://mazhen.tech/p/%E8%BF%BD%E8%B8%AA%E5%AE%9A%E4%BD%8D-java-%E8%BF%9B%E7%A8%8B%E7%9A%84-socket-%E5%88%9B%E5%BB%BA/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;追踪定位 Java 进程的 Socket 创建&lt;/a&gt;中，我们使用 BCC 脚本成功捕获了 Java 进程在启动阶段对 &lt;code&gt;Unix socket&lt;/code&gt; 的创建。其中，对于一个由 JVM 原生代码触发的 &lt;code&gt;socket&lt;/code&gt; 调用，我们得到了如下调用堆栈：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;12:23:13.184181&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;socket&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;AF_UNIX&lt;span class=&#34;o&#34;&gt;)]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;PPID&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;177932&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;PID&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;177961&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;FD&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;4&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&lt;span class=&#34;s1&#34;&gt;&amp;#39;socket+0xb [libc.so.6]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&lt;span class=&#34;s1&#34;&gt;&amp;#39;__nscd_get_mapping+0xbd [libc.so.6]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&lt;span class=&#34;s1&#34;&gt;&amp;#39;__nscd_get_map_ref+0xcf [libc.so.6]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b&lt;span class=&#34;s1&#34;&gt;&amp;#39;[unknown]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;虽然我们根据堆栈中的 &lt;code&gt;__nscd_get_mapping&lt;/code&gt; 等函数名推断出其行为与名称服务查询有关，但这个结果留下了一个明显的问题：调用堆栈在 &lt;code&gt;__nscd_get_map_ref&lt;/code&gt; 函数之后就中断了，最后一行显示为 &lt;code&gt;[unknown]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__nscd_get_map_ref&lt;/code&gt; 这个函数名表明它是一个内部实现函数，而非供外部程序直接调用的公共 API。因此，调用它的函数极有可能仍然位于 &lt;code&gt;glibc&lt;/code&gt; 库的内部。这就引出了一个疑问：&lt;strong&gt;为什么堆栈会在 &lt;code&gt;glibc&lt;/code&gt; 库的内部中断？&lt;code&gt;[unknown]&lt;/code&gt; 的背后究竟隐藏着哪个函数？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文将深入分析这个现象的底层原因，并提供一个能获取完整原生调用堆栈的方法。&lt;/p&gt;
&lt;h2 id=&#34;丢失的帧指针-frame-pointers&#34;&gt;
    &lt;a href=&#34;#%e4%b8%a2%e5%a4%b1%e7%9a%84%e5%b8%a7%e6%8c%87%e9%92%88-frame-pointers&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    丢失的帧指针 (Frame Pointers)
&lt;/h2&gt;&lt;p&gt;要理解堆栈为什么会中断，我们首先需要了解 BCC 默认是如何获取调用堆栈的。它使用的是一种名为“&lt;strong&gt;帧指针回溯&lt;/strong&gt;”（Frame Pointer Walking）的技术。&lt;/p&gt;
&lt;p&gt;简单来说，当一个函数被调用时，它会在自己的&lt;strong&gt;栈帧&lt;/strong&gt;（&lt;strong&gt;Stack Frame&lt;/strong&gt;）中保存上一个函数栈帧的基地址。这个基地址通常存储在一个专用的寄存器中（在 x86-64 架构上是 &lt;code&gt;%rbp&lt;/code&gt;），这个寄存器就被称为&lt;strong&gt;帧指针&lt;/strong&gt;（&lt;strong&gt;Frame Pointer&lt;/strong&gt;）。通过当前函数的帧指针，可以找到上一个函数的帧指针，如此层层递进，形成一个类似链表的结构。BCC 正是依赖这条“指针链”来快速地回溯出完整的函数调用关系。&lt;/p&gt;
&lt;p&gt;这种方法的优点是速度快、性能开销很低。但它的缺点是，它严重依赖于被追踪的程序在编译时保留了帧指针。如果编译器为了性能优化（例如，使用 &lt;code&gt;-fomit-frame-pointer&lt;/code&gt; 标志），决定不使用 &lt;code&gt;%rbp&lt;/code&gt; 寄存器作为帧指针，而是将其当作一个通用寄存器来使用，那么这个函数栈帧中就不会包含保存上一个帧指针的操作。当堆栈回溯到这个函数时，指针链就会在此处断裂。&lt;/p&gt;
&lt;p&gt;基于以上原理，我们可以做出一个合理的推测：BCC 的堆栈追踪之所以在 &lt;code&gt;glibc&lt;/code&gt; 内部中断，是因为调用链中的某个函数在编译时被优化，省略了帧指针，导致回溯链条在此处断裂。&lt;/p&gt;
&lt;h2 id=&#34;历史回顾为何帧指针会丢失&#34;&gt;
    &lt;a href=&#34;#%e5%8e%86%e5%8f%b2%e5%9b%9e%e9%a1%be%e4%b8%ba%e4%bd%95%e5%b8%a7%e6%8c%87%e9%92%88%e4%bc%9a%e4%b8%a2%e5%a4%b1&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    历史回顾，为何帧指针会“丢失”？
&lt;/h2&gt;&lt;p&gt;前面我们推测堆栈中断是由于 glibc 中的某些函数在编译时省略了帧指针。但为什么编译器会做出这样的优化呢？&lt;/p&gt;
&lt;p&gt;知名性能专家 &lt;a class=&#34;link&#34; href=&#34;https://www.brendangregg.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Brendan Gregg&lt;/a&gt; 在他的文章 &lt;a class=&#34;link&#34; href=&#34;https://www.brendangregg.com/blog/2024-03-17/the-return-of-the-frame-pointers.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The Return of the Frame Pointers&lt;/a&gt; 中详细阐述了这个问题。在过去的 32 位 CPU 架构（如 x86）时代，CPU 可用的通用寄存器数量非常有限。为了尽可能地提升性能，编译器开发者无所不用其极。其中一项广为采用的优化就是通过 &lt;code&gt;-fomit-frame-pointer&lt;/code&gt; 编译标志，不再将 &lt;code&gt;%ebp&lt;/code&gt; 寄存器固定用作帧指针，而是将其解放出来，作为一个通用的寄存器参与数据计算。&lt;/p&gt;
&lt;p&gt;这个优化的理论收益是：可以减少函数调用时的指令数，并多出一个可用的寄存器，从而生成体积更小、执行速度可能更快的代码。代价则是牺牲了程序的调试性和可分析性，使得基于帧指针的堆栈回溯变得不可靠。在那个年代，这个选择被认为是值得的，并逐渐成为了 GCC 等主流编译器的默认行为。&lt;/p&gt;
&lt;p&gt;在现代的 64 位 CPU (x86-64) 上，寄存器数量已经大大增加，省略帧指针带来的性能优势已经微乎其微，但这个编译默认选项却作为一种“历史惯例”被长期保留了下来。因此，我们当前系统上使用的 &lt;code&gt;glibc&lt;/code&gt; 库，其二进制文件很可能就是遵循这一惯例构建的产物。&lt;/p&gt;
&lt;p&gt;业界已经重新认识到帧指针对于系统可观测性的重要性。现在，主流的 Linux 发行版（如 Ubuntu 24.04 和 Fedora 38）已经开始在其软件包的编译选项中重新默认启用帧指针。但在那之前，我们仍然需要处理这些“历史遗留”的二进制文件。&lt;/p&gt;
&lt;h2 id=&#34;使用-gdb-验证猜想&#34;&gt;
    &lt;a href=&#34;#%e4%bd%bf%e7%94%a8-gdb-%e9%aa%8c%e8%af%81%e7%8c%9c%e6%83%b3&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    使用 GDB 验证猜想
&lt;/h2&gt;&lt;p&gt;现在我们使用 GDB (GNU Debugger) 直接检查相关函数的汇编代码，验证 &lt;code&gt;glibc&lt;/code&gt; 内部的某些函数可能省略了帧指针的推测。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加载 &lt;code&gt;libc.so.6&lt;/code&gt; 到 GDB&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们首先启动 GDB，并将 &lt;code&gt;glibc&lt;/code&gt; 库作为分析目标加载进来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ gdb /usr/lib/x86_64-linux-gnu/libc.so.6
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;检查导致回溯失败的函数 &lt;code&gt;__nscd_get_map_ref&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据 BCC 的输出，&lt;code&gt;__nscd_get_map_ref&lt;/code&gt; 是堆栈中可见的最后一个函数名。回溯正是在尝试寻找&lt;strong&gt;它的调用者&lt;/strong&gt;时失败的。因此，我们首先来检查这个函数的汇编代码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) disassemble __nscd_get_map_ref
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输出结果会类似下面这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Dump of assembler code for function __nscd_get_map_ref:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   0x0000000000171670 &amp;lt;+0&amp;gt;:	endbr64 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   0x0000000000171674 &amp;lt;+4&amp;gt;:	push   %r15
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   0x0000000000171676 &amp;lt;+6&amp;gt;:	push   %r14
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   0x0000000000171678 &amp;lt;+8&amp;gt;:	push   %r13
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   0x000000000017167a &amp;lt;+10&amp;gt;:	push   %r12
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   0x000000000017167c &amp;lt;+12&amp;gt;:	push   %rbp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   0x000000000017167d &amp;lt;+13&amp;gt;:	push   %rbx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   0x000000000017167e &amp;lt;+14&amp;gt;:	sub    $0x28,%rsp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们看到，这个函数的序言&lt;strong&gt;没有&lt;/strong&gt; &lt;code&gt;push %rbp&lt;/code&gt; 和 &lt;code&gt;mov %rsp,%rbp&lt;/code&gt;。它直接通过 &lt;code&gt;sub&lt;/code&gt; 指令来操作栈顶指针 &lt;code&gt;%rsp&lt;/code&gt; 以分配栈空间。这明确地证明了 &lt;code&gt;__nscd_get_map_ref&lt;/code&gt; 这个函数在编译时&lt;strong&gt;省略了帧指针&lt;/strong&gt;。正是因为缺少这个关键的“路标”，BCC 无法找到其调用者的栈帧，导致回溯在此中断，下一行只能显示为 &lt;code&gt;[unknown]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检查被成功“穿越”的函数 &lt;code&gt;__nscd_get_mapping&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们再来检查一下堆栈中的前一个函数 &lt;code&gt;__nscd_get_mapping&lt;/code&gt;。BCC 成功地从这个函数回溯到了 &lt;code&gt;__nscd_get_map_ref&lt;/code&gt;，这说明 &lt;code&gt;__nscd_get_mapping&lt;/code&gt; 自身应该保留了帧指针。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(gdb) disassemble __nscd_get_mapping
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这一次，输出结果证实了我们的推断：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Dump of assembler code for function __nscd_get_mapping:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   0x0000000000171210 &amp;lt;+0&amp;gt;:	endbr64 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   0x0000000000171214 &amp;lt;+4&amp;gt;:	push   %rbp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   0x0000000000171215 &amp;lt;+5&amp;gt;:	mov    %rsp,%rbp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;头两行指令 &lt;code&gt;push %rbp&lt;/code&gt; 和 &lt;code&gt;mov %rsp,%rbp&lt;/code&gt; 是设置帧指针的标准操作。这证明了 &lt;code&gt;__nscd_get_mapping&lt;/code&gt; &lt;strong&gt;确实保留了帧指针&lt;/strong&gt;，BCC 正是利用了这一点，才得以成功地从它回溯到上一层。&lt;/p&gt;
&lt;p&gt;至此，证据确凿。BCC 的帧指针回溯之旅在成功经过 &lt;code&gt;__nscd_get_mapping&lt;/code&gt; 之后，到达了 &lt;code&gt;__nscd_get_map_ref&lt;/code&gt; 这一站。由于 &lt;code&gt;__nscd_get_map_ref&lt;/code&gt; 函数本身缺少帧指针，导致 BCC 无法定位其调用者的信息，回溯过程被迫中断。我们的猜想得到了验证。&lt;/p&gt;
&lt;h2 id=&#34;使用-dwarf-堆栈回溯&#34;&gt;
    &lt;a href=&#34;#%e4%bd%bf%e7%94%a8-dwarf-%e5%a0%86%e6%a0%88%e5%9b%9e%e6%ba%af&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    使用 DWARF 堆栈回溯
&lt;/h2&gt;&lt;p&gt;既然基于帧指针的“快捷方式”因为道路中断而无法走通，我们就需要启用一种更可靠的回溯方法。这个方法就是基于 &lt;strong&gt;DWARF&lt;/strong&gt; 调试信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DWARF&lt;/code&gt; 是一种被广泛使用的调试信息格式。当程序以 &lt;code&gt;-g&lt;/code&gt; 等标志编译时，编译器会生成丰富的 &lt;code&gt;DWARF&lt;/code&gt; 信息，并将其存储在可执行文件中，或者是一个独立的符号文件。这些信息详尽地描述了程序的结构，包括函数、变量、类型，以及如何在任何指令点精确地重建调用堆栈的规则。&lt;/p&gt;
&lt;p&gt;与依赖运行时指针链的帧指针回溯不同，&lt;code&gt;DWARF&lt;/code&gt; 回溯更像是拿着一张由编译器绘制的“代码地图”和“堆栈布局说明书”。性能分析工具（如 &lt;code&gt;perf&lt;/code&gt;）可以利用这份“地图”，即使在函数省略了帧指针的情况下，也能通过分析当前的指令指针和栈内容，精确地计算出调用者的位置。&lt;/p&gt;
&lt;p&gt;要成功使用 &lt;code&gt;DWARF&lt;/code&gt; 回溯，我们必须满足两个前提条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安装必要的依赖&lt;/strong&gt;：&lt;code&gt;perf&lt;/code&gt; 的 &lt;code&gt;DWARF&lt;/code&gt; 回溯功能依赖于一些系统库（如 &lt;code&gt;libunwind&lt;/code&gt;, &lt;code&gt;libdw&lt;/code&gt;）。我们需要确保这些库已经安装，以保证 &lt;code&gt;perf&lt;/code&gt; 的核心引擎能够正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调试信息必须存在&lt;/strong&gt;：被追踪的程序库（在我们的案例中是 &lt;code&gt;glibc&lt;/code&gt;）必须有对应的调试信息包（在 Ubuntu 上通常是 &lt;code&gt;dbgsym&lt;/code&gt; 或 &lt;code&gt;dbg&lt;/code&gt; 包）。这些包包含了 &lt;code&gt;perf&lt;/code&gt; 解读堆栈所需的 &lt;code&gt;DWARF&lt;/code&gt; 地图。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;满足这两个条件后，我们就可以指示 &lt;code&gt;perf&lt;/code&gt; 工具使用 &lt;code&gt;DWARF&lt;/code&gt; 模式来捕获调用堆栈，从而绕过帧指针缺失的问题。&lt;/p&gt;
&lt;h2 id=&#34;还原完整的调用堆栈&#34;&gt;
    &lt;a href=&#34;#%e8%bf%98%e5%8e%9f%e5%ae%8c%e6%95%b4%e7%9a%84%e8%b0%83%e7%94%a8%e5%a0%86%e6%a0%88&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    还原完整的调用堆栈
&lt;/h2&gt;&lt;p&gt;现在，来捕获之前中断的完整调用堆栈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在开始追踪之前，我们需要确保 &lt;code&gt;perf&lt;/code&gt; 的 &lt;code&gt;DWARF&lt;/code&gt; 引擎及其依赖是完整的，并且 &lt;code&gt;glibc&lt;/code&gt; 的调试信息也已经就绪。&lt;/p&gt;
&lt;p&gt;在 Ubuntu 系统上，可以通过以下命令安装所有必要的软件包：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装 perf 进行 DWARF 回溯所需的核心依赖库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install libunwind-dev libdw-dev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装 glibc 的调试符号包&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install libc6-dbg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;使用 &lt;code&gt;perf&lt;/code&gt; 捕获数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;环境准备就绪后，我们就可以使用 &lt;code&gt;perf record&lt;/code&gt; 命令来启动 Java 应用并捕获系统调用事件。这次，我们将明确要求 &lt;code&gt;perf&lt;/code&gt; 使用 &lt;code&gt;DWARF&lt;/code&gt; 模式进行堆栈回溯。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 放宽内核对 perf 的安全限制，允许追踪用户空间&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; -1 &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo tee /proc/sys/kernel/perf_event_paranoid
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用 --call-graph dwarf 参数启动追踪&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo perf record -e syscalls:sys_enter_socket --call-graph dwarf -- java Main
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--call-graph dwarf&lt;/code&gt;：这是最关键的参数。它指示 &lt;code&gt;perf&lt;/code&gt; 在捕获事件时，必须使用 &lt;code&gt;DWARF&lt;/code&gt; 信息来回溯并记录完整的调用堆栈。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-- java Main&lt;/code&gt;：&lt;code&gt;--&lt;/code&gt; 符号告诉 &lt;code&gt;perf&lt;/code&gt;，后面的所有内容都是要执行的命令。请将其替换为您实际的 Java 应用启动命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;perf&lt;/code&gt; 会启动 Java 应用，并从进程开始到结束持续追踪。应用退出后，追踪数据会自动保存在当前目录下的 &lt;code&gt;perf.data&lt;/code&gt; 文件中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，我们使用 &lt;code&gt;perf script&lt;/code&gt; 命令来读取 &lt;code&gt;perf.data&lt;/code&gt; 文件，并将其中的原始数据翻译成人类可读的调用堆栈。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo perf script
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这一次，输出的结果将不再有 &lt;code&gt;[unknown]&lt;/code&gt;。您会看到一份类似下面这样完整、清晰的调用堆栈：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;java 391724 [003] 952479.264820: syscalls:sys_enter_socket: family: 0x00000001, type: 0x00080801, protocol: 0x00000000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c96feb3b __GI_socket+0xb (inlined)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c9747c4f open_socket+0x3f (/usr/lib/x86_64-linux-gnu/libc.so.6)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c97482cc __nscd_get_mapping+0xbc (/usr/lib/x86_64-linux-gnu/libc.so.6)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c974873e __nscd_get_map_ref+0xce (/usr/lib/x86_64-linux-gnu/libc.so.6)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c97449c6 nscd_getpw_r+0x66 (/usr/lib/x86_64-linux-gnu/libc.so.6)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c9744e45 __nscd_getpwuid_r+0x65 (/usr/lib/x86_64-linux-gnu/libc.so.6)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c96c0e3f __getpwuid_r+0x1bf (inlined)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c8aaba99 get_user_name+0x59 (/usr/lib/jvm/java-17-openjdk-amd64/lib/server/libjvm.so)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c8aad1e3 PerfMemory::create_memory_region+0x93 (/usr/lib/jvm/java-17-openjdk-amd64/lib/server/libjvm.so)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c8aab773 perfMemory_init+0x73 (/usr/lib/jvm/java-17-openjdk-amd64/lib/server/libjvm.so)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c863b3c6 vm_init_globals+0x26 (/usr/lib/jvm/java-17-openjdk-amd64/lib/server/libjvm.so)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c8cfa409 Threads::create_vm+0x249 (/usr/lib/jvm/java-17-openjdk-amd64/lib/server/libjvm.so)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c8709c6d JNI_CreateJavaVM+0x4d (/usr/lib/jvm/java-17-openjdk-amd64/lib/server/libjvm.so)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c98050f0 JavaMain+0x90 (/usr/lib/jvm/java-17-openjdk-amd64/lib/libjli.so)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c9809a38 ThreadJavaMain+0x8 (/usr/lib/jvm/java-17-openjdk-amd64/lib/libjli.so)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c966bac2 start_thread+0x2f2 (/usr/lib/x86_64-linux-gnu/libc.so.6)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            7fb4c96fd84f __clone3+0x2f (inlined)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过与 BCC 的输出进行对比，我们可以清晰地看到，之前中断的堆栈已经被完美地补充完整了。&lt;code&gt;[unknown]&lt;/code&gt; 的真实身份——&lt;code&gt;nscd_getpw_r&lt;/code&gt;、&lt;code&gt;__getpwuid_r&lt;/code&gt; 等函数——以及更上层的 &lt;code&gt;libjvm.so&lt;/code&gt; 内部调用，现在都已一目了然。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;perf&lt;/code&gt; 捕获的这份完整调用堆栈，为我们揭示了 &lt;code&gt;Unix socket&lt;/code&gt; 创建的完整路径：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事件的起点&lt;/strong&gt;：在 JVM 启动的极早期阶段（&lt;code&gt;JNI_CreateJavaVM&lt;/code&gt; -&amp;gt; &lt;code&gt;Threads::create_vm&lt;/code&gt;），JVM 需要初始化其性能数据子系统（&lt;code&gt;PerfMemory&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;直接原因&lt;/strong&gt;：&lt;code&gt;PerfMemory::create_memory_region&lt;/code&gt; 函数在初始化过程中，调用了其内部的 &lt;code&gt;get_user_name&lt;/code&gt; 函数，目的是为了获取当前运行用户的名称。这通常是为了创建用户专属的性能数据文件（例如 &lt;code&gt;/tmp/hsperfdata_&amp;lt;user&amp;gt;/&amp;lt;pid&amp;gt;&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;触发系统调用&lt;/strong&gt;：为了从用户 ID 解析出用户名，&lt;code&gt;get_user_name&lt;/code&gt; 函数调用了 &lt;code&gt;glibc&lt;/code&gt; 提供的标准 POSIX 函数 &lt;code&gt;__getpwuid_r&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NSS 介入&lt;/strong&gt;：系统的 NSS(Name Service Switch) 框架接管了这个请求。&lt;code&gt;glibc&lt;/code&gt; 内部的 &lt;code&gt;__nscd_*&lt;/code&gt; 系列函数开始工作，准备通过配置好的名称服务守护进程（如 &lt;code&gt;lwsmd&lt;/code&gt; 或 &lt;code&gt;nscd&lt;/code&gt;）来完成查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最终结果&lt;/strong&gt;：为了与这个守护进程通信，&lt;code&gt;glibc&lt;/code&gt; 的客户端逻辑最终调用了 &lt;code&gt;socket()&lt;/code&gt; 系统调用，创建了我们最初观察到的那个 &lt;code&gt;Unix socket&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;这个 &lt;code&gt;Unix socket&lt;/code&gt; 的创建，其根本原因在于 JVM 在初始化性能监控模块时，需要获取当前用户信息。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;
    &lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    总结
&lt;/h2&gt;&lt;p&gt;本文深入探讨了&lt;a class=&#34;link&#34; href=&#34;%28https://mazhen.tech/p/%E8%BF%BD%E8%B8%AA%E5%AE%9A%E4%BD%8D-java-%E8%BF%9B%E7%A8%8B%E7%9A%84-socket-%E5%88%9B%E5%BB%BA/%29&#34; &gt;上一篇文章&lt;/a&gt; 中遗留的一个问题：为何使用 BCC 追踪 &lt;code&gt;Unix socket&lt;/code&gt; 创建时，调用堆栈会在 &lt;code&gt;glibc&lt;/code&gt; 库内部中断并显示 &lt;code&gt;[unknown]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;首先分析了 BCC 默认依赖的“帧指针回溯”技术在面对编译优化时的问题。通过 GDB 对 &lt;code&gt;glibc&lt;/code&gt; 库相关函数的汇编代码进行现场取证，证实了堆栈中断的确是因为 &lt;code&gt;glibc&lt;/code&gt; 内部某个函数在编译时省略了帧指针。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，文章介绍了“DWARF 回溯”方法，最终成功捕获到了从 JVM 内部 C++ 函数到 &lt;code&gt;glibc&lt;/code&gt; 再到系统调用的完整调用堆栈，彻底解开了 &lt;code&gt;[unknown]&lt;/code&gt; 背后的秘密。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
