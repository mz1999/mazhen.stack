<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>db on mazhen.tech</title>
        <link>https://mazhen.tech/tags/db/</link>
        <description>Recent content in db on mazhen.tech</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-CN</language>
        <lastBuildDate>Fri, 15 May 2020 11:30:26 +0800</lastBuildDate><atom:link href="https://mazhen.tech/tags/db/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Atomikos在微服务场景下的使用</title>
        <link>https://mazhen.tech/p/atomikos%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
        <pubDate>Fri, 15 May 2020 11:30:26 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/atomikos%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/atomikos/transactions-essentials&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Atomikos&lt;/a&gt;是一个轻量级的分布式事务管理器，实现了&lt;a class=&#34;link&#34; href=&#34;https://jcp.org/en/jsr/detail?id=907&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java Transaction API (JTA)&lt;/a&gt;规范，可以很方便的和&lt;a class=&#34;link&#34; href=&#34;https://spring.io/projects/spring-boot&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring Boot&lt;/a&gt;集成，支持微服务场景下跨节点的全局事务。&lt;/p&gt;
&lt;p&gt;本文为一个微服务的示例应用，通过引入&lt;code&gt;Atomikos&lt;/code&gt;增加全局事务能力。&lt;/p&gt;
&lt;p&gt;示例代码可以在&lt;a class=&#34;link&#34; href=&#34;https://github.com/mz1999/atomkos-sample&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241132937.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;demo-services&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;用户访问&lt;code&gt;Business&lt;/code&gt;服务，它通过&lt;code&gt;RPC&lt;/code&gt;调用分别调用&lt;code&gt;Order&lt;/code&gt;和&lt;code&gt;Storage&lt;/code&gt;创建订单和减库存。三个服务需要加入到一个全局事务中，要么全部成功，任何一个服务失败，都会造成事务回滚，数据的状态始终保持一致性。&lt;/p&gt;
&lt;p&gt;蚂蚁金服开源的&lt;a class=&#34;link&#34; href=&#34;http://seata.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Seata&lt;/a&gt;就是为了解决这类问题，在微服务架构下提供分布式事务服务。传统的应用服务器通过&lt;code&gt;JTA/JTS&lt;/code&gt;也能解决分布式场景下的事务问题，但需要和&lt;code&gt;EJB&lt;/code&gt;绑定在一起才能使用。&lt;code&gt;Atomikos&lt;/code&gt;是一个独立的分布式事务管理器，原先是为&lt;code&gt;Spring&lt;/code&gt;和&lt;code&gt;Tomcat&lt;/code&gt;提供事务服务，让用户不必只为了事务服务而引入应用服务器。&lt;/p&gt;
&lt;p&gt;现在&lt;code&gt;Atomikos&lt;/code&gt;也能为微服务提供分布式事务服务，这时主要需要两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务上下文如何通过RPC在服务间传播&lt;/li&gt;
&lt;li&gt;微服务如何参与进两阶段提交协议的过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后面会结合示例应用介绍&lt;code&gt;Atomikos&lt;/code&gt;是如何解决这两个问题。示例应用&lt;code&gt;atomkos-sample&lt;/code&gt;的结构如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;api&lt;/strong&gt;：定义了服务接口&lt;code&gt;OrderService&lt;/code&gt;和&lt;code&gt;StorageService&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;order-service&lt;/strong&gt;：&lt;code&gt;OrderService&lt;/code&gt;的具体实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;storage-service&lt;/strong&gt;：&lt;code&gt;StorageService&lt;/code&gt;的具体实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;business-service&lt;/strong&gt;：用户访问入口&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;事务上下文的传播&#34;&gt;事务上下文的传播&lt;/h2&gt;
&lt;p&gt;在项目主工程的pom文件中引入&lt;code&gt;Atomikos&lt;/code&gt;依赖，注意要包括&lt;code&gt;transactions-remoting&lt;/code&gt;，正是它才能让事务上下文在&lt;code&gt;RPC&lt;/code&gt;调用时传递。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;dependency&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;groupId&amp;gt;com.atomikos&amp;lt;/groupId&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;artifactId&amp;gt;transactions-remoting&amp;lt;/artifactId&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;version&amp;gt;5.0.6&amp;lt;/version&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/dependency&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;transactions-remoting&lt;/code&gt;支持&lt;code&gt;jaxrs&lt;/code&gt;，&lt;code&gt;Spring Remoting&lt;/code&gt;和&lt;code&gt;Spring rest&lt;/code&gt;等几种&lt;code&gt;RPC&lt;/code&gt;方式，我们使用的是&lt;code&gt;Spring Remoting&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以&lt;strong&gt;order-service&lt;/strong&gt;为例，通过&lt;code&gt;TransactionalHttpInvokerServiceExporter&lt;/code&gt;将&lt;code&gt;OrderService&lt;/code&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mz1999/atomkos-sample/blob/690d6c0026a8f0874de63828023f26ef9210d0dd/order-service/src/main/java/com/apusic/samples/config/ServiceConfig.java#L12&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;发布为远程服务&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@Bean(name = &amp;#34;/services/order&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;TransactionalHttpInvokerServiceExporter orderService(OrderServiceImpl orderService) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    TransactionalHttpInvokerServiceExporter exporter = new TransactionalHttpInvokerServiceExporter();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    exporter.setService(orderService);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    exporter.setServiceInterface(OrderService.class);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return exporter;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;OrderService&lt;/code&gt;的调用者&lt;strong&gt;business-service&lt;/strong&gt;使用&lt;code&gt;HttpInvokerProxyFactoryBean&lt;/code&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mz1999/atomkos-sample/blob/690d6c0026a8f0874de63828023f26ef9210d0dd/business-service/src/main/java/com/apusic/samples/config/ServiceConfig.java#L14&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;引入远程服务&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@Bean
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public HttpInvokerProxyFactoryBean orderService() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    HttpInvokerProxyFactoryBean orderService = new HttpInvokerProxyFactoryBean();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    orderService.setHttpInvokerRequestExecutor(httpInvokerRequestExecutor());
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    orderService.setServiceUrl(&amp;#34;http://localhost:8082/services/order&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    orderService.setServiceInterface(OrderService.class);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return orderService;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@Bean
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public TransactionalHttpInvokerRequestExecutor httpInvokerRequestExecutor() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    TransactionalHttpInvokerRequestExecutor httpInvokerRequestExecutor = new TransactionalHttpInvokerRequestExecutor();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return httpInvokerRequestExecutor;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;business-service&lt;/strong&gt;负责发起全局事务，它使用&lt;code&gt;Spring&lt;/code&gt;标准的&lt;code&gt;@Transactional&lt;/code&gt;标记方法&lt;a class=&#34;link&#34; href=&#34;https://github.com/mz1999/atomkos-sample/blob/690d6c0026a8f0874de63828023f26ef9210d0dd/business-service/src/main/java/com/apusic/samples/service/BusinessService.java#L19&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;开启事务&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@Transactional
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public void createOrder(String userId, String commodityCode, Integer count) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    orderService.create(userId, commodityCode, count);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    storageService.deduct(commodityCode, count);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;Atomikos&lt;/code&gt;提供了&lt;code&gt;TransactionalHttpInvokerRequestExecutor&lt;/code&gt;和&lt;code&gt;TransactionalHttpInvokerServiceExporter&lt;/code&gt;拦截请求和响应，利用&lt;code&gt;HTTP header&lt;/code&gt;传递事务上下文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241132653.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;spring-remoting&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;business-service&lt;/strong&gt;在调用远程服务&lt;code&gt;OrderService&lt;/code&gt;时，请求发送前会经过&lt;a class=&#34;link&#34; href=&#34;https://github.com/atomikos/transactions-essentials/blob/4332faaf7de551e126ab60c6151e66cee2b854ed/public/transactions-remoting/src/main/java/com/atomikos/remoting/spring/httpinvoker/TransactionalHttpInvokerRequestExecutor.java#L30&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TransactionalHttpInvokerRequestExecutor.prepareConnection&lt;/a&gt;处理，增加&lt;code&gt;HTTP header&lt;/code&gt;，携带事务上下文：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@Override
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;protected void prepareConnection(HttpURLConnection con, int contentLength)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		throws IOException {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	String propagation = template.onOutgoingRequest();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	con.setRequestProperty(HeaderNames.PROPAGATION_HEADER_NAME, propagation);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	super.prepareConnection(con, contentLength);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;OrderService&lt;/code&gt;会使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/atomikos/transactions-essentials/blob/4332faaf7de551e126ab60c6151e66cee2b854ed/public/transactions-remoting/src/main/java/com/atomikos/remoting/spring/httpinvoker/TransactionalHttpInvokerServiceExporter.java#L33&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TransactionalHttpInvokerServiceExporter.decorateInputStream&lt;/a&gt;进行请求拦截，能从&lt;code&gt;HTTP header&lt;/code&gt;中解析出事务上下文：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@Override
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;protected InputStream decorateInputStream(HttpServletRequest request, InputStream is) throws IOException {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	try {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		String propagation = request.getHeader(HeaderNames.PROPAGATION_HEADER_NAME);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		template.onIncomingRequest(propagation);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	} catch (IllegalArgumentException e) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	return super.decorateInputStream(request, is);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;OrderService&lt;/code&gt;处理完成&lt;a class=&#34;link&#34; href=&#34;https://github.com/atomikos/transactions-essentials/blob/4332faaf7de551e126ab60c6151e66cee2b854ed/public/transactions-remoting/src/main/java/com/atomikos/remoting/spring/httpinvoker/TransactionalHttpInvokerServiceExporter.java#L48&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;返回响应时&lt;/a&gt;，会将该节点加入全局事务包装成&lt;code&gt;Event&lt;/code&gt;，放入&lt;code&gt;HTTP header&lt;/code&gt;返回给&lt;strong&gt;business-service&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@Override
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	protected OutputStream decorateOutputStream(HttpServletRequest request, HttpServletResponse response,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			OutputStream os) throws IOException {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		response.addHeader(HeaderNames.EXTENT_HEADER_NAME, extent);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return super.decorateOutputStream(request, response, os);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;business-service&lt;/strong&gt;接收到响应，利用&lt;a class=&#34;link&#34; href=&#34;https://github.com/atomikos/transactions-essentials/blob/4332faaf7de551e126ab60c6151e66cee2b854ed/public/transactions-remoting/src/main/java/com/atomikos/remoting/spring/httpinvoker/TransactionalHttpInvokerRequestExecutor.java#L39&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TransactionalHttpInvokerRequestExecutor.validateResponse&lt;/a&gt;解析出&lt;code&gt;Event&lt;/code&gt;，注册进事务管理器，这样在全局事务提交时，可以让该分支参与到两阶段提交协议：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@Override
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;protected void validateResponse(HttpInvokerClientConfiguration config,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		HttpURLConnection con) throws IOException {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	super.validateResponse(config, con);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	String extent = con.getHeaderField(HeaderNames.EXTENT_HEADER_NAME);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	template.onIncomingResponse(extent);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;两阶段提交过程&#34;&gt;两阶段提交过程&lt;/h2&gt;
&lt;p&gt;在处理&lt;code&gt;RPC&lt;/code&gt;调用的响应时，&lt;code&gt;Atomikos&lt;/code&gt;会将参与到全局事务的远程节点注册为&lt;code&gt;Participants&lt;/code&gt;(&lt;a class=&#34;link&#34; href=&#34;https://github.com/atomikos/transactions-essentials/blob/4332faaf7de551e126ab60c6151e66cee2b854ed/public/transactions-api/src/main/java/com/atomikos/icatch/Extent.java#L64&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Extent.addRemoteParticipants&lt;/a&gt;)，在事务提交时，所有的&lt;code&gt;Participants&lt;/code&gt;都会&lt;a class=&#34;link&#34; href=&#34;https://github.com/atomikos/transactions-essentials/blob/4332faaf7de551e126ab60c6151e66cee2b854ed/public/transactions/src/main/java/com/atomikos/icatch/imp/CoordinatorImp.java#L673&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参与到两阶段提交&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;synchronized ( fsm_ ) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;if ( commit ) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	if ( participants_.size () &amp;lt;= 1 ) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		commit ( true );
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	} else {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		int prepareResult = prepare ();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		// make sure to only do commit if NOT read only
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		if ( prepareResult != Participant.READ_ONLY )
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			commit ( false );
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;} else {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	rollback ();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看出，如果&lt;code&gt;Participants&lt;/code&gt;大于1，会走&lt;code&gt;prepare&lt;/code&gt;和&lt;code&gt;commit&lt;/code&gt;两阶段提交的完整过程。那么&lt;code&gt;OrderService&lt;/code&gt;和&lt;code&gt;StorageService&lt;/code&gt;如何参与进两阶段提交呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Atomikos&lt;/code&gt;提供了&lt;code&gt;REST&lt;/code&gt;入口&lt;a class=&#34;link&#34; href=&#34;https://github.com/atomikos/transactions-essentials/blob/master/public/transactions-remoting/src/main/java/com/atomikos/remoting/twopc/AtomikosRestPort.java&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;com.atomikos.remoting.twopc.AtomikosRestPort&lt;/a&gt;，你可以将&lt;code&gt;AtomikosRestPort&lt;/code&gt;注册到&lt;code&gt;JAX-RS&lt;/code&gt;，例如本示例选择的是&lt;a class=&#34;link&#34; href=&#34;https://cxf.apache.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Apache CFX&lt;/a&gt;，在&lt;code&gt;application.properties&lt;/code&gt;进行配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cxf.path=/api
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cxf.jaxrs.classes-scan=true
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cxf.jaxrs.classes-scan-packages=com.atomikos.remoting.twopc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;business-service&lt;/strong&gt;在进行全局事务提交时，会访问所有&lt;code&gt;Participants&lt;/code&gt;相应的&lt;code&gt;REST&lt;/code&gt;接口进行两阶段提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241133603.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;atomikosrestport&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;business-service&lt;/strong&gt;是怎么知道&lt;code&gt;AtomikosRestPort&lt;/code&gt;的访问地址的呢？上面提到了，&lt;strong&gt;business-service&lt;/strong&gt;在访问&lt;code&gt;OrderService&lt;/code&gt;时，返回的响应&lt;code&gt;header&lt;/code&gt;中包含了&lt;code&gt;Event&lt;/code&gt;，地址就随着&lt;code&gt;Event&lt;/code&gt;返回给了调用者。&lt;code&gt;AtomikosRestPort&lt;/code&gt;的访问地址配置在&lt;code&gt;jta.properties&lt;/code&gt;中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;com.atomikos.icatch.rest_port_url=http://localhost:8082/api/atomikos
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;至此，我们解释清楚了&lt;code&gt;Atomikos&lt;/code&gt;如何为微服务提供分布式事务服务的，主要解决了两个问题：事务上下文如何通过RPC在服务间传播，以及微服务如何参与进两阶段提交协议的过程。&lt;/p&gt;
&lt;p&gt;下一步我准备为&lt;code&gt;Atomikos&lt;/code&gt;增加&lt;a class=&#34;link&#34; href=&#34;https://dubbo.apache.org&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;dubbo&lt;/a&gt;的支持，即事务上下文可以通过&lt;code&gt;dubbo&lt;/code&gt;进行传播。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>应用服务器的分布式事务支持和Seata的对比分析</title>
        <link>https://mazhen.tech/p/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%92%8Cseata%E7%9A%84%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/</link>
        <pubDate>Tue, 21 Apr 2020 11:25:09 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%92%8Cseata%E7%9A%84%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/</guid>
        <description>&lt;h2 id=&#34;应用服务器的分布式事务支持&#34;&gt;应用服务器的分布式事务支持&lt;/h2&gt;
&lt;p&gt;我们先看一下分布式事务的需求是如何产生的，以及应用服务器是如何支持分布式事务管理的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单体应用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先看单体应用，所有的模块部署在一个应用服务器上，业务数据都保存在单个数据库中，这种场景本地事务就可以满足需求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241126947.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;local-transaction&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据库水平拆分&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果数据库按照业务模块进行水平拆分，完成一个业务请求会涉及到跨库的资源访问和更新，这时候就需要使用应用服务器的&lt;code&gt;JTA&lt;/code&gt;进行两阶段提交，保证跨库操作的事务完整性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241127654.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;jta&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用模块拆分&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用按照业务模块进一步拆分，每一个模块都作为&lt;code&gt;EJB&lt;/code&gt;，部署在独立的应用服务器中。完成一个业务请求会跨越多个应用服务器节点和资源，如何在这种场景保证业务操作的事务呢？当访问入口&lt;code&gt;EJB&lt;/code&gt;时&lt;code&gt;JTA&lt;/code&gt;会自动开启全局事务，&lt;strong&gt;事务上下文&lt;/strong&gt;随着&lt;code&gt;EJB&lt;/code&gt;的远程调用在应用服务器之间传播，让被调用的&lt;code&gt;EJB&lt;/code&gt;也加入到全局事务中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241127730.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;jts&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这就是应用因拆分而遇到分布式事务的问题，以及应用服务器是如何解决这个问题的。&lt;/p&gt;
&lt;h2 id=&#34;分布式事务中间件&#34;&gt;分布式事务中间件&lt;/h2&gt;
&lt;p&gt;微服务时代，没人再使用沉重的&lt;code&gt;EJB&lt;/code&gt;，都是将&lt;code&gt;Spring Bean&lt;/code&gt;直接暴露为远程服务。完成一个业务请求需要跨越多个微服务，同样需要面对分布式事务的问题。这时就需要引入&lt;strong&gt;分布式事务中间件&lt;/strong&gt;。我们以蚂蚁金服开源的&lt;a class=&#34;link&#34; href=&#34;https://github.com/seata/seata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Seata&lt;/a&gt;为例，看看它是怎么解决微服务场景下的分布式事务问题。&lt;/p&gt;
&lt;p&gt;将上一小节跑在应用服务器上的业务，使用微服务 + &lt;code&gt;Seata&lt;/code&gt;的重构后，部署架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241128875.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;seata-microservices&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图中黄色方框（&lt;code&gt;RM&lt;/code&gt;，&lt;code&gt;TM&lt;/code&gt;，&lt;code&gt;TC&lt;/code&gt;）是&lt;code&gt;Seata&lt;/code&gt;的核心组件，它们配合完成对微服务的分布式事务支持。可以看出，和应用服务器的&lt;code&gt;EJB&lt;/code&gt;方案架构上类似，只是多了一个独立运行的&lt;code&gt;TC&lt;/code&gt;组件。&lt;/p&gt;
&lt;p&gt;我们再看看&lt;code&gt;Seata&lt;/code&gt;各组件的具体作用。&lt;/p&gt;
&lt;h3 id=&#34;seata的架构&#34;&gt;&lt;code&gt;Seata&lt;/code&gt;的架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241129681.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;seata-architecture&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Seata&lt;/code&gt;由三个组件构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Transaction Coordinator (TC)&lt;/strong&gt;： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transaction Manager (TM)&lt;/strong&gt;： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Resource Manager (RM)&lt;/strong&gt;： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;seata-vs-应用服务器&#34;&gt;&lt;code&gt;Seata&lt;/code&gt; vs. 应用服务器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Seata&lt;/code&gt;和应用服务器的分布式事务支持主要有以下四个差异：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Seata&lt;/code&gt;和应用服务器都可以实现&lt;strong&gt;业务无侵入&lt;/strong&gt;分布式事务支持。但应用服务器的&lt;code&gt;XA&lt;/code&gt;方案实现的是&lt;strong&gt;实时一致性&lt;/strong&gt;，而&lt;code&gt;Seata&lt;/code&gt;的&lt;code&gt;AT 模式&lt;/code&gt;实现的是&lt;strong&gt;最终一致性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Seata&lt;/code&gt;引入了独立运行的&lt;code&gt;Transaction Coordinator&lt;/code&gt;，维护全局事务的运行状态。而应用服务器的访问入口节点承担了维护全局事务状态的职责。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Seata&lt;/code&gt;自己实现了&lt;code&gt;Resource Manager&lt;/code&gt;，不需要依赖数据库的&lt;strong&gt;XA driver&lt;/strong&gt;。这样就有可能将没有实现&lt;strong&gt;XA&lt;/strong&gt;接口的资源加入的分布式事务中，例如&lt;code&gt;NoSQL&lt;/code&gt;。同时，&lt;strong&gt;RM&lt;/strong&gt;的实现要比&lt;code&gt;JTA&lt;/code&gt;中的&lt;strong&gt;XAResource&lt;/strong&gt;复杂很多。&lt;strong&gt;RM&lt;/strong&gt;需要拦截并解析&lt;code&gt;SQL&lt;/code&gt;，生成回滚语句，在事务&lt;code&gt;rollback&lt;/code&gt;时自动进行数据还原。&lt;strong&gt;XAResource&lt;/strong&gt;是对&lt;strong&gt;XA driver&lt;/strong&gt;的包装，资源参与分布式事务的能力，都是由数据库提供的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事务上下文&lt;/strong&gt;的传播机制不同。应用服务器使用标准的&lt;code&gt;RMI-IIOP&lt;/code&gt;协议进行&lt;strong&gt;事务上下文&lt;/strong&gt;的跨节点传播。&lt;code&gt;Seata&lt;/code&gt;是对各种&lt;code&gt;RPC&lt;/code&gt;框架提供了插件，拦截请求和响应，&lt;strong&gt;事务上下文&lt;/strong&gt;随着&lt;code&gt;RPC&lt;/code&gt;调用进行跨节点传播。目前&lt;code&gt;Seata&lt;/code&gt;已经支持了&lt;a class=&#34;link&#34; href=&#34;https://dubbo.apache.org/zh-cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;dubbo&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://github.com/weibocom/motan&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Motan&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://github.com/sofastack/sofa-rpc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;sofa-rpc&lt;/a&gt;等多种&lt;code&gt;RPC&lt;/code&gt;框架。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Seata&lt;/code&gt;和应用服务器都支持在分布式场景下的全局事务，都可以做到对业务无侵入。&lt;code&gt;Seata&lt;/code&gt;实现的是&lt;strong&gt;最终一致性&lt;/strong&gt;，因此性能比应用服务器的&lt;code&gt;XA&lt;/code&gt;方案好很多，具备海量并发处理能力，这也是互联网公司选择它的原因。由于&lt;code&gt;Seata&lt;/code&gt;不依赖数据库的&lt;strong&gt;XA driver&lt;/strong&gt;，只使用数据库的本地事务，就完成了对分布式事务的支持，相当于承担了部分数据库的职责，因此&lt;code&gt;Seata&lt;/code&gt;的实现难度要比应用服务器的&lt;code&gt;JTA&lt;/code&gt;大。&lt;/p&gt;
&lt;h2 id=&#34;应用服务器进入微服务时代&#34;&gt;应用服务器进入微服务时代&lt;/h2&gt;
&lt;p&gt;那么应用服务器的分布式事务支持在微服务时代还有用吗？或者说我们应该怎样改进，才能让应用服务器进入微服务时代？&lt;/p&gt;
&lt;p&gt;首先我们要看到&lt;code&gt;JTA/XA&lt;/code&gt;的优势：支持数据的实时一致性，对业务开发更加友好。客户对原有的系统进行微服务改造时，如果把业务模型假定成数据最终一致性，客户就不得不做出很大的妥协和变更。特别是有些金融客户对一致性的要求会比较高。&lt;/p&gt;
&lt;p&gt;我们可以学习&lt;code&gt;Seata&lt;/code&gt;的架构，抛弃掉沉重的&lt;code&gt;EJB/RMI-IIOP&lt;/code&gt;，让&lt;code&gt;Spring Bean&lt;/code&gt;通过&lt;code&gt;dubbo&lt;/code&gt;等&lt;code&gt;RPC&lt;/code&gt;框架直接对外暴露服务，同时&lt;strong&gt;事务上下文&lt;/strong&gt;可以在&lt;code&gt;RPC&lt;/code&gt;调用时进行传递：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202209241129392.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;jta-microservices&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我们甚至可以将&lt;code&gt;JTA&lt;/code&gt;独立出来，和&lt;code&gt;Tomcat&lt;/code&gt;这样的Web容器整合，为微服务架构提供分布式事务支持。相信通过这样的改造，应用服务器的分布式事务能力在微服务时代又能焕发第二春。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Consensus and Distributed Transactions</title>
        <link>https://mazhen.tech/p/consensus-and-distributed-transactions/</link>
        <pubDate>Fri, 07 Feb 2020 10:44:10 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/consensus-and-distributed-transactions/</guid>
        <description>&lt;script type=&#34;text/javascript&#34; src=&#34;https://mazhen.tech/js/pdf-js/build/pdf.js&#34;&gt;&lt;/script&gt;
&lt;style&gt;
  #the-canvas {
    border: 1px solid black;
    direction: ltr;
    width: 100%;
    height: auto;
    display: none;
  }

  #paginator {
    display: none;
    text-align: center;
    margin-bottom: 10px;
  }

  #loadingWrapper {
    display: none;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 350px;
  }

  #loading {
    display: inline-block;
    width: 50px;
    height: 50px;
    border: 3px solid #d2d0d0;
    ;
    border-radius: 50%;
    border-top-color: #383838;
    animation: spin 1s ease-in-out infinite;
    -webkit-animation: spin 1s ease-in-out infinite;
  }

  @keyframes spin {
    to {
      -webkit-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spin {
    to {
      -webkit-transform: rotate(360deg);
    }
  }
&lt;/style&gt;

&lt;div id=&#34;paginator&#34;&gt;
  &lt;button id=&#34;prev&#34;&gt;Previous&lt;/button&gt;
  &lt;button id=&#34;next&#34;&gt;Next&lt;/button&gt;
  &amp;nbsp; &amp;nbsp;
  &lt;span&gt;Page: &lt;span id=&#34;page_num&#34;&gt;&lt;/span&gt; / &lt;span id=&#34;page_count&#34;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div id=&#34;embed-pdf-container&#34;&gt;
  &lt;div id=&#34;loadingWrapper&#34;&gt;
    &lt;div id=&#34;loading&#34;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;canvas id=&#34;the-canvas&#34;&gt;&lt;/canvas&gt;
&lt;/div&gt;

&lt;script type=&#34;text/javascript&#34;&gt;
  window.onload = function () {
    
    
    var url = &#34;https:\/\/mazhen.tech&#34; + &#39;.\/pdf\/202209241047269.pdf&#39;;

    var hidePaginator = &#34;&#34; === &#34;true&#34;;
    var hideLoader = &#34;&#34; === &#34;true&#34;;
    var selectedPageNum = parseInt(&#34;&#34;) || 1;

    
    var pdfjsLib = window[&#39;pdfjs-dist/build/pdf&#39;];

    
    pdfjsLib.GlobalWorkerOptions.workerSrc = &#34;https:\/\/mazhen.tech&#34; + &#39;/js/pdf-js/build/pdf.worker.js&#39;;

    
    var pdfDoc = null,
      pageNum = selectedPageNum,
      pageRendering = false,
      pageNumPending = null,
      scale = 3,
      canvas = document.getElementById(&#39;the-canvas&#39;),
      ctx = canvas.getContext(&#39;2d&#39;),
      paginator = document.getElementById(&#34;paginator&#34;),
      loadingWrapper = document.getElementById(&#39;loadingWrapper&#39;);


    
    showPaginator();
    showLoader();

    

    function renderPage(num) {
      pageRendering = true;
      
      pdfDoc.getPage(num).then(function (page) {
        var viewport = page.getViewport({ scale: scale });
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        
        var renderContext = {
          canvasContext: ctx,
          viewport: viewport
        };
        var renderTask = page.render(renderContext);

        
        renderTask.promise.then(function () {
          pageRendering = false;
          showContent();

          if (pageNumPending !== null) {
            
            renderPage(pageNumPending);
            pageNumPending = null;
          }
        });
      });

      
      document.getElementById(&#39;page_num&#39;).textContent = num;
    }

    

    function showContent() {
      loadingWrapper.style.display = &#39;none&#39;;
      canvas.style.display = &#39;block&#39;;
    }

    

    function showLoader() {
      if (hideLoader) return
      loadingWrapper.style.display = &#39;flex&#39;;
      canvas.style.display = &#39;none&#39;;
    }

    

    function showPaginator() {
      if (hidePaginator) return
      paginator.style.display = &#39;block&#39;;
    }

    

    function queueRenderPage(num) {
      if (pageRendering) {
        pageNumPending = num;
      } else {
        renderPage(num);
      }
    }

    

    function onPrevPage() {
      if (pageNum &lt;= 1) {
        return;
      }
      pageNum--;
      queueRenderPage(pageNum);
    }
    document.getElementById(&#39;prev&#39;).addEventListener(&#39;click&#39;, onPrevPage);

    

    function onNextPage() {
      if (pageNum &gt;= pdfDoc.numPages) {
        return;
      }
      pageNum++;
      queueRenderPage(pageNum);
    }
    document.getElementById(&#39;next&#39;).addEventListener(&#39;click&#39;, onNextPage);

    

    pdfjsLib.getDocument(url).promise.then(function (pdfDoc_) {
      pdfDoc = pdfDoc_;
      var numPages = pdfDoc.numPages;
      document.getElementById(&#39;page_count&#39;).textContent = numPages;

      
      if (pageNum &gt; numPages) {
        pageNum = numPages
      }

      
      renderPage(pageNum);
    });
  }

&lt;/script&gt;
</description>
        </item>
        <item>
        <title>关系数据库查询处理基础知识扫盲</title>
        <link>https://mazhen.tech/p/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/</link>
        <pubDate>Sun, 01 Jul 2018 17:04:31 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/</guid>
        <description>&lt;p&gt;当&lt;a class=&#34;link&#34; href=&#34;https://pingcap.com/blog-cn/#%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TiDB 源码阅读系列&lt;/a&gt;更新到第六篇&lt;a class=&#34;link&#34; href=&#34;https://pingcap.com/blog-cn/tidb-source-code-reading-6/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Select 语句概览》&lt;/a&gt;时，我发现需要一些关系数据库的基础知识才能更好的理解，例如逻辑查询计划优化其实就是：使用&lt;strong&gt;代数定律&lt;/strong&gt;对查询语句的&lt;strong&gt;代数表达式树&lt;/strong&gt;做等价转换，使改进后的&lt;strong&gt;代数表达式树&lt;/strong&gt;预期可以生成更有效的&lt;strong&gt;物理查询计划&lt;/strong&gt;。有了这些基础知识，看代码才能做到知其然知其所以然。本文希望通过梳理关系数据库背后的知识，为读懂 &lt;code&gt;TiDB&lt;/code&gt; 查询处理器部分的源码扫清障碍。&lt;/p&gt;
&lt;h2 id=&#34;极简数据库发展史&#34;&gt;极简数据库发展史&lt;/h2&gt;
&lt;p&gt;数据库的应用及其广泛，已经成为信息系统的核心技术和重要的基础设施。简单说数据库需要做两件事：存储数据，以及随后在你需要的时候能访问读取数据。&lt;/p&gt;
&lt;p&gt;最早的数据库是基于&lt;strong&gt;文件系统&lt;/strong&gt;，虽然它满足了长期存储数据的需求，但没有提供对文件的查询语言，读取访问非常不便利。于是人们在文件系统上引入一层抽象：&lt;strong&gt;数据模型&lt;/strong&gt;。数据模型是对现实世界数据特征的抽象，能比较真实地模拟现实世界，容易为人所理解，也便于在计算机上实现。&lt;/p&gt;
&lt;p&gt;最早出现的是&lt;strong&gt;层次模型&lt;/strong&gt;（&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Hierarchical_database_model&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hierarchical Model&lt;/a&gt;），数据被组织为一棵树，类似于今天&lt;strong&gt;文档数据库&lt;/strong&gt;使用的&lt;code&gt;JSON&lt;/code&gt;的结构。&lt;strong&gt;层次模型&lt;/strong&gt;很适合处理&lt;strong&gt;one-to-many&lt;/strong&gt;关系，但要表现&lt;strong&gt;many-to-many&lt;/strong&gt;关系则非常困难，一般也不支持&lt;code&gt;join&lt;/code&gt;。使用&lt;strong&gt;层次模型&lt;/strong&gt;最著名的数据库是 &lt;code&gt;IBM&lt;/code&gt; 的&lt;strong&gt;Information Management System (IMS)&lt;/strong&gt;，它最初是为了解决阿波罗飞船登月计划的需求，协调分散在全球制造的200万个阿波罗飞船零部件的生产进度。&lt;/p&gt;
&lt;p&gt;随后出现了不同的方案解决&lt;strong&gt;层次模型&lt;/strong&gt;的限制，其中最突出的两个模型是&lt;strong&gt;网络模型&lt;/strong&gt;（&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Network_model&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Network Model&lt;/a&gt;）和&lt;strong&gt;关系数据模型&lt;/strong&gt;，最终关系数据模型胜出。&lt;/p&gt;
&lt;p&gt;今天最著名和使用最广泛的数据模型是由 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Edgar_F._Codd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Edgar Codd&lt;/a&gt; 博士提出的&lt;strong&gt;关系数据模型&lt;/strong&gt;，他在1970年发布的论文&lt;a class=&#34;link&#34; href=&#34;http://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《A Relational Model of Data for Large Shared Data Banks》&lt;/a&gt;，奠定了关系数据库的理论基础。ACM在1983年把这篇论文列为从1958年以来的四分之一世纪中具有里程碑式意义的最重要的25篇研究论文之一。到了80年代中期，基于关系数据模型的&lt;strong&gt;关系数据库&lt;/strong&gt;已经成为人们存储、查询结构化数据的首选工具。&lt;/p&gt;
&lt;p&gt;到了2010年，&lt;strong&gt;NoSQL&lt;/strong&gt;兴起，试图颠覆&lt;strong&gt;关系数据模型&lt;/strong&gt;的统治地位。随着互联网的爆发式发展，数据库领域又一次发生了摇摆，伴随着互联网的特殊需求，一批有着新鲜血液的 &lt;strong&gt;NoSQL&lt;/strong&gt; 数据库涌现了出来，&lt;strong&gt;层次模型&lt;/strong&gt;又重新站在了大家面前。&lt;strong&gt;NoSQL&lt;/strong&gt;为了应对海量数据存储和高并发访问，决定放弃&lt;strong&gt;关系数据模型&lt;/strong&gt;和&lt;strong&gt;事务&lt;/strong&gt;等关系数据数据库的关键特性。自从 &lt;strong&gt;NoSQL&lt;/strong&gt; 概念横空出世，关系数据库似乎成了低效、高成本、速度慢的数据处理模式的代名词。然而，&lt;strong&gt;NoSQL&lt;/strong&gt;在解决问题的同时也给使用者带来了很多困扰， &lt;strong&gt;最终一致&lt;/strong&gt;让应用开发者要面对各种复杂的场景。&lt;/p&gt;
&lt;p&gt;数据库技术的发展是螺旋式上升，Google发布的&lt;code&gt;Spanner&lt;/code&gt;和&lt;code&gt;F1&lt;/code&gt;两篇论文，让人们看到了&lt;strong&gt;关系数据模型&lt;/strong&gt; 和 &lt;strong&gt;NoSQL&lt;/strong&gt; 融合的可能性。以 &lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TiDB&lt;/a&gt; 为代表的 &lt;strong&gt;NewSQL&lt;/strong&gt; 数据库，让人们重新享受关系模型、强一致性事务等对使用者友好的特性，同时也具备了 &lt;strong&gt;NoSQL&lt;/strong&gt; 的水平扩展能力。&lt;/p&gt;
&lt;h2 id=&#34;关系数据模型-和-关系代数&#34;&gt;关系数据模型 和 关系代数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数据模型&lt;/strong&gt;是对现实世界事物的抽象，而&lt;strong&gt;关系数据模型&lt;/strong&gt;将一切事物都抽象为&lt;strong&gt;关系&lt;/strong&gt;，并通过集合运算的方式规定了关系之间的运算过程，模型相对的比较简单，数据证明严谨，因此很快被大家广泛接受。&lt;/p&gt;
&lt;p&gt;这一节我将介绍关系数据库的数学基础：&lt;strong&gt;关系数据模型&lt;/strong&gt;和&lt;strong&gt;关系代数&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;关系数据模型&#34;&gt;关系数据模型&lt;/h3&gt;
&lt;p&gt;关系模型为人们提供了一种描述数据的方法：一个称为&lt;strong&gt;关系&lt;/strong&gt;（relation）的二维表。现实世界的实体以及实体间的各种联系都可以用&lt;strong&gt;关系&lt;/strong&gt;来表示。我们通过例子来了解关系模型的重要术语：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;雇员表&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;emp_no&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;birth_date&lt;/th&gt;
&lt;th&gt;gender&lt;/th&gt;
&lt;th&gt;hire_date&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;汤唯&lt;/td&gt;
&lt;td&gt;1990-06-08&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;td&gt;2015-08-01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;刘亦菲&lt;/td&gt;
&lt;td&gt;1994-09-10&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;td&gt;2017-05-06&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;刘德华&lt;/td&gt;
&lt;td&gt;1986-04-18&lt;/td&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;td&gt;2008-09-01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;关系（Relation）&lt;/strong&gt; ：一个关系对应通常说的一张二维表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;元组（Tuple）&lt;/strong&gt; ： 表中的一行即为一个元组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;属性（Attribute）&lt;/strong&gt; ：表中的一列即为一个&lt;strong&gt;属性&lt;/strong&gt;，给每一个属性起一个名称即&lt;strong&gt;属性名&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;键（Key）&lt;/strong&gt;：表中的某个属性组，它可以唯一确定一个元组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;域（Domain）&lt;/strong&gt; : 是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。例如性别的域是（男，女）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关系模式（schema）&lt;/strong&gt;：对关系的描述，先给出一个关系名，其后是用圆括号扩起来的所有属性，例如：&lt;code&gt;employees（emp_no, name, birth_date, gender, hire_date）&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关系代数&#34;&gt;关系代数&lt;/h3&gt;
&lt;p&gt;一门&lt;strong&gt;代数&lt;/strong&gt;是由一些&lt;strong&gt;操作符&lt;/strong&gt;和&lt;strong&gt;操作数&lt;/strong&gt;组成。例如算术代数的加、减、乘、除是操作符，变量&lt;code&gt;x&lt;/code&gt;和常量&lt;code&gt;8&lt;/code&gt;是操作数。任何一门代数都允许把操作符作用在操作数上构造出&lt;strong&gt;表达式（expression）&lt;/strong&gt;，例如算术表达式 &lt;code&gt;(x+y)*3&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关系代数&lt;/strong&gt; 也是一门代数，它的操作数是&lt;strong&gt;关系&lt;/strong&gt;，操作运算符有两类：&lt;strong&gt;集合运算符&lt;/strong&gt;和专门的&lt;strong&gt;关系运算符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关系代数&lt;/strong&gt;可以认为是一种抽象的查询语言，利用对&lt;strong&gt;关系&lt;/strong&gt;的&lt;strong&gt;运算&lt;/strong&gt;来表达&lt;strong&gt;查询&lt;/strong&gt;，运算对象是&lt;strong&gt;关系&lt;/strong&gt;，运算结果也是&lt;strong&gt;关系&lt;/strong&gt;。因此，&lt;strong&gt;关系代数&lt;/strong&gt;的表达式也被称为&lt;strong&gt;查询（query）&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;传统的集合运算&#34;&gt;传统的集合运算&lt;/h4&gt;
&lt;p&gt;三个最常见的集合操作是：&lt;strong&gt;并&lt;/strong&gt;（union）、&lt;strong&gt;交&lt;/strong&gt;（intersection）、&lt;strong&gt;差&lt;/strong&gt;（difference）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R ∪ S&lt;/code&gt;，表示关系R和S的&lt;strong&gt;并&lt;/strong&gt;，得到的结果关系的元素来自R或者S，或R和S中都出现过。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R ∩ S&lt;/code&gt;，表示关系R和S的&lt;strong&gt;交&lt;/strong&gt;，同时在R和S中存在的元素集合。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R - S&lt;/code&gt;，表示关系R和S的&lt;strong&gt;差&lt;/strong&gt;，它是由在R中出现但不在S中出现的元素构成的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外一个集合操作是&lt;strong&gt;笛卡尔积&lt;/strong&gt;（Cartesian Product）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系R和S的&lt;strong&gt;笛卡尔积&lt;/strong&gt;是一个有序对的集合，有序对的一个元素是关系R中的任何一个元组，第二个元素是关系S中的任何一个元组表示为 &lt;code&gt;R × S&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关系R&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关系S&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;th&gt;D&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;R × S&lt;/code&gt;的结果&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;R.B&lt;/th&gt;
&lt;th&gt;S.B&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;th&gt;D&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;专门的关系运算&#34;&gt;专门的关系运算&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选择&lt;/strong&gt;（selection)，当&lt;strong&gt;选择&lt;/strong&gt;操作符应用到关系&lt;code&gt;R&lt;/code&gt;上时，产生一个关系R的元组的子集合。结果关系元组必须满足某个涉及&lt;code&gt;R&lt;/code&gt;中属性的条件&lt;code&gt;C&lt;/code&gt;，表示为 σ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;( R )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;投影&lt;/strong&gt; （projection），用来从一个关系生成一个新的关系，这个关系只包含原来关系&lt;code&gt;R&lt;/code&gt;中的部分列。表达式 π&lt;!-- raw HTML omitted --&gt;A1,A2,&amp;hellip;,An&lt;!-- raw HTML omitted --&gt; ( R ) 的值是这样一个关系，它只包含关系&lt;code&gt;R&lt;/code&gt;属性&lt;code&gt;A1,A2,...An&lt;/code&gt;所代表的列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;θ连接&lt;/strong&gt;，关系R和关系S满足条件C的&lt;strong&gt;θ连接&lt;/strong&gt;可以用这样的符号来表示： R ⋈&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt; S&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;θ连接&lt;/strong&gt;的结果这样构造：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先得到R和S的&lt;strong&gt;笛卡尔积&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在得到的关系中寻找满足条件&lt;code&gt;C&lt;/code&gt;的元组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关系R&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关系S&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;th&gt;D&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;R ⋈ &lt;!-- raw HTML omitted --&gt; A&amp;lt;D  AND  R.B ≠ S.B&lt;!-- raw HTML omitted --&gt; S 的结果是：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;R.B&lt;/th&gt;
&lt;th&gt;R.C&lt;/th&gt;
&lt;th&gt;S.B&lt;/th&gt;
&lt;th&gt;S.C&lt;/th&gt;
&lt;th&gt;D&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;有两类常用的连接运算：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;等值连接&lt;/strong&gt;（equijoin）：比较运算符为 &lt;code&gt;=&lt;/code&gt; 的连接运算称为等值连接。例如： R ⋈ &lt;!-- raw HTML omitted --&gt;R.A = S.B &lt;!-- raw HTML omitted --&gt; S 是从关系R与S的笛卡尔积中选取A、B属性值相等的那些元组。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自然连接&lt;/strong&gt;（Natural join）：自然连接是一种特殊的等值连接，两个关系中进行比较的分量必须是相同的属性组，并在结果中把重复的属性列去掉。关系R和S的自然连接表示为  &lt;code&gt;R ⋈ S&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关系R&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关系S&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;th&gt;D&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;R ⋈ S&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;th&gt;D&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;两个关系R和S在做&lt;strong&gt;自然连接&lt;/strong&gt;时，如果一个元组不能和另外关系中的任何一个元组配对的话，这个元组被称为&lt;strong&gt;悬浮元组&lt;/strong&gt;（Dangling tuple）。上面的例子中，关系S的第三个元组就是悬浮元组。&lt;/p&gt;
&lt;p&gt;如果把&lt;strong&gt;悬浮元组&lt;/strong&gt;也保存在结果关系中，而在其他属性上填&lt;strong&gt;空值&lt;/strong&gt;(Null)，就叫做&lt;strong&gt;外连接&lt;/strong&gt;（Outer Join）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;左外连接&lt;/strong&gt;(LEFT OUTER JOIN或LEFT JOIN)：只保留左边关系&lt;code&gt;R&lt;/code&gt;中的悬浮元组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右外连接&lt;/strong&gt;(RIGHT OUTER JOIN或RIGHT JOIN)：只保留右边关系&lt;code&gt;S&lt;/code&gt;中的悬浮元组&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;关系代数的扩展操作符&#34;&gt;关系代数的扩展操作符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消除重复操作符&lt;/strong&gt;（duplicated-elimination operator）用 &lt;code&gt;δ(R)&lt;/code&gt; 来返回一个没有重复元组的关系&lt;code&gt;R&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;聚集操作符&lt;/strong&gt; （aggregation operator）用来汇总或者聚集关系某一列中出现的值，有 &lt;code&gt;SUM&lt;/code&gt;，&lt;code&gt;AVG&lt;/code&gt;，&lt;code&gt;MIN&lt;/code&gt;，&lt;code&gt;MAX&lt;/code&gt;，&lt;code&gt;COUNT&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分组操作&lt;/strong&gt;（grouping）根据元组在一个或多个属性上的值把关系的元组拆成“组”。这样聚集操作就可以对分组的各个列进行计算。分组操作符 &lt;code&gt;γ&lt;/code&gt; 是组合了&lt;strong&gt;分组&lt;/strong&gt;和&lt;strong&gt;聚合操作&lt;/strong&gt;的一个算子。例如表达式： γ &lt;!-- raw HTML omitted --&gt;gender, COUNT(emp_no)-&amp;gt;count&lt;!-- raw HTML omitted --&gt;(employees) 代表把性别（&lt;code&gt;gender&lt;/code&gt;）作为分组属性，然后对每一个分组进行&lt;code&gt;COUNT(emp_no)&lt;/code&gt;的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排序算子&lt;/strong&gt;（sorting operator）如果关系&lt;code&gt;R&lt;/code&gt;的模式是 &lt;code&gt;R(A,B,C)&lt;/code&gt;，那么 τ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;( R ) 就把&lt;code&gt;R&lt;/code&gt;中的元组按照属性&lt;code&gt;C&lt;/code&gt;的值排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关系代数小结&#34;&gt;关系代数小结&lt;/h3&gt;
&lt;p&gt;上面的知识有些枯燥，但非常容易理解，因为我们经常使用关系数据库，已经接受了这些概念。掌握了一些关系代数的知识，在阅读&lt;code&gt;TiDB&lt;/code&gt;源码时，当看到&lt;code&gt;selection&lt;/code&gt;、&lt;code&gt;projection&lt;/code&gt; 这些术语就能一下想到它们对应的关系代数运算符。&lt;/p&gt;
&lt;p&gt;这里只介绍了关系代数最基本的概念，如果想完整学习，建议参考斯坦福大学大学的课程&lt;a class=&#34;link&#34; href=&#34;http://infolab.stanford.edu/~ullman/fcdb.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CS145: A First Course in Database Systems&lt;/a&gt;，对应的教材有中文版&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/3923575/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《数据库系统基础教程》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其实我们在查询时提交给数据库的就是&lt;strong&gt;关系代数表达式&lt;/strong&gt;，它是关系运算符的组合，数据库会根据一些&lt;strong&gt;代数定律&lt;/strong&gt;对最初的表达式做等价变换，得出一个最优的&lt;strong&gt;等价表达式&lt;/strong&gt;（equivalent expression），即可以更快的被计算出结果的表达式。这个过程就是&lt;strong&gt;逻辑查询计划优化&lt;/strong&gt;，后面我会简单的介绍相关概念。&lt;/p&gt;
&lt;h2 id=&#34;sql-的诞生&#34;&gt;SQL 的诞生&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;SQL&lt;/strong&gt;(Structured Query Language) 结构化查询语言，是关系数据库的标准语言。&lt;/p&gt;
&lt;p&gt;在1970年Codd博士提出了关系模型之后，由于&lt;strong&gt;关系代数&lt;/strong&gt;或者&lt;strong&gt;关系&lt;/strong&gt;都太数学了，难以被普通用户接受。IBM在研制关系数据库管理系统原型&lt;code&gt;System R&lt;/code&gt;的过程中，决定摈弃数学语言，以自然语言为方向，结果诞生了结构化英语查询语言（&lt;code&gt;Structured English Query Language&lt;/code&gt;，&lt;code&gt;SEQUEL&lt;/code&gt;），后来更名为&lt;strong&gt;SQL&lt;/strong&gt;。&lt;code&gt;System R&lt;/code&gt; 因此获得1988年度ACM“软件系统奖”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL&lt;/strong&gt;是声明式查询语言，你只需要指定想要获得什么样的数据，而无须了解如何实现这个目标。&lt;strong&gt;SQL&lt;/strong&gt;具体是如何执行的，取决于数据库系统的&lt;strong&gt;查询处理器&lt;/strong&gt;，它来决定哪些索引和哪些连接方法可以使用，以及以什么样的顺序执行查询的各个部分。&lt;strong&gt;SQL&lt;/strong&gt;隐藏了数据库引擎的实现细节，因此用户可以在不修改查询语句的情况下，享受到数据库性能优化带来的好处。&lt;/p&gt;
&lt;p&gt;下面我们来看看数据库的查询处理器。&lt;/p&gt;
&lt;h2 id=&#34;关系数据库的查询处理器&#34;&gt;关系数据库的查询处理器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;SQL&lt;/strong&gt;是在很高层次上表达查询，那么数据库的&lt;strong&gt;查询处理器&lt;/strong&gt;必须提供查询被如何执行的大量细节。下面我从概念上介绍查询处理器的处理流程，实际的数据库实现要复杂的多，特别是像 &lt;code&gt;TiDB&lt;/code&gt; 这样的分布式数据库。如果想比较系统的了解数据库的实现技术，同样推荐斯坦福大学计算机科学专业的课程 &lt;a class=&#34;link&#34; href=&#34;http://infolab.stanford.edu/~ullman/dbsi.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CS245: Database System Implementation&lt;/a&gt;。上面提到的&lt;a class=&#34;link&#34; href=&#34;http://infolab.stanford.edu/~ullman/fcdb.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CS145&lt;/a&gt;是&lt;a class=&#34;link&#34; href=&#34;http://infolab.stanford.edu/~ullman/dbsi.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CS245&lt;/a&gt;的预修课。国内很少有讲数据库内部实现的书，这门课的教材值得阅读。当然最好的学习方法是理论联系实践，多去读 &lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TiDB&lt;/a&gt; 的源代码:)&lt;/p&gt;
&lt;p&gt;一般查询处理可以简单的划分为以下几个步骤：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ol&gt;
&lt;li&gt;对SQL进行语法分析，将查询语句转换成&lt;strong&gt;抽象语法树&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;把&lt;strong&gt;抽象语法树&lt;/strong&gt;转换成&lt;strong&gt;关系代数表达式树&lt;/strong&gt;，这就是初始的&lt;strong&gt;逻辑查询计划&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;关系代数&lt;/strong&gt;中的多个&lt;strong&gt;代数定律&lt;/strong&gt;改进初始的&lt;strong&gt;代数表达式树&lt;/strong&gt;。利用一些&lt;strong&gt;代数定律&lt;/strong&gt;，可以把&lt;strong&gt;代数表达式树&lt;/strong&gt;转换成一个&lt;strong&gt;等价&lt;/strong&gt;的表达式树，后者预期可以生成更有效的&lt;strong&gt;物理查询计划&lt;/strong&gt;。这一步进行了查询重写，可以称为&lt;strong&gt;逻辑查询计划优化&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;为&lt;strong&gt;逻辑查询计划&lt;/strong&gt;的每一个操作符选择实现算法，并确定这些操作符的执行顺序，&lt;strong&gt;逻辑查询计划&lt;/strong&gt;被转化为&lt;strong&gt;物理查询计划&lt;/strong&gt;。&lt;strong&gt;物理查询计划&lt;/strong&gt;指明了要执行的操作，操作的执行顺序，执行每步所用的算法，获取数据的方式，以及数据从一个操作传递给另一个操作的方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;查询示例&#34;&gt;查询示例&lt;/h3&gt;
&lt;p&gt;本文准备以一个简单的例子来介绍查询处理的流程，下面是查询涉及的两张表：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;employees&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;emp_no&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;birth_date&lt;/th&gt;
&lt;th&gt;gender&lt;/th&gt;
&lt;th&gt;hire_date&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;汤唯&lt;/td&gt;
&lt;td&gt;1990-06-08&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;td&gt;2015-08-01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;刘亦菲&lt;/td&gt;
&lt;td&gt;1994-09-10&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;td&gt;2017-05-06&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;刘德华&lt;/td&gt;
&lt;td&gt;1986-04-18&lt;/td&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;td&gt;2008-09-01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;salaries&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;emp_no&lt;/th&gt;
&lt;th&gt;salary&lt;/th&gt;
&lt;th&gt;last_modified&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8000&lt;/td&gt;
&lt;td&gt;2018-04-01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6000&lt;/td&gt;
&lt;td&gt;2018-04-01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;15000&lt;/td&gt;
&lt;td&gt;2018-04-01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;想要获取工资大于7000的员工姓名列表，SQL语句可以这么写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SELECT name
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;FROM employees, salaries
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;WHERE employees.emp_no = salaries.emp_no AND
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      salary &amp;gt; 7000;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;sql-语法分析&#34;&gt;SQL 语法分析&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SQL Parser&lt;/code&gt;的功能是把SQL语句按照SQL语法规则进行解析，将文本转换成&lt;strong&gt;抽象语法树&lt;/strong&gt;（AST）。具体的实现可以参考这篇文章&lt;a class=&#34;link&#34; href=&#34;https://github.com/mz1999/Apusic-db-team/blob/master/docs/sql-parser.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《TiDB SQL Parser 的实现》&lt;/a&gt;。 示例SQL解析完成后得到下面的语法树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011707079.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;生成逻辑查询计划&#34;&gt;生成逻辑查询计划&lt;/h3&gt;
&lt;p&gt;现在将上一步生成的语法树转换成&lt;strong&gt;关系代数表达式树&lt;/strong&gt;，也就是&lt;strong&gt;逻辑查询计划&lt;/strong&gt;。对于示例SQL的抽象语法树转换过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;FromList&amp;gt;&lt;/code&gt; 中涉及的关系&lt;code&gt;employees&lt;/code&gt;和&lt;code&gt;salaries&lt;/code&gt;做笛卡尔积运算&lt;/li&gt;
&lt;li&gt;选择（selection）运算 σ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;，其中&lt;code&gt;C&lt;/code&gt;被替换成&lt;code&gt;&amp;lt;Condition&amp;gt;&lt;/code&gt;表达式，即&lt;code&gt;employees.emp_no = salaries.emp_no AND salary &amp;gt; 7000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;投影（projection） π&lt;!-- raw HTML omitted --&gt;L&lt;!-- raw HTML omitted --&gt;，其中&lt;code&gt;L&lt;/code&gt;是&lt;code&gt;&amp;lt;SelList&amp;gt;&lt;/code&gt;中的属性列表，对于这个查询只有一个属性&lt;code&gt;name&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们得到下面的关系代数表达式树：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;逻辑查询计划的改进&#34;&gt;逻辑查询计划的改进&lt;/h3&gt;
&lt;p&gt;当我们把查询语句转换成关系代数表达式时，得到了一个初始的&lt;strong&gt;逻辑查询计划&lt;/strong&gt;。现在我们可以使用关系代数中的多个&lt;strong&gt;代数定律&lt;/strong&gt;改进&lt;strong&gt;逻辑查询计划&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里仅仅列出一小部分这样的&lt;strong&gt;代数定律&lt;/strong&gt;，它们可以将一个表达式树转换成一个&lt;strong&gt;等价&lt;/strong&gt;的表达式树。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换律和结合律&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;R × S = S × R; (R X S) × T = R × (S × T)&lt;/p&gt;
&lt;p&gt;R ⋈ S = S ⋈ R; (R ⋈ S) ⋈ T = R ⋈ (S ⋈ T)&lt;/p&gt;
&lt;p&gt;R ∪ S = S ∪ R; (R ∪ S) ∪ T = R ∪ (S ∪ T)&lt;/p&gt;
&lt;p&gt;R ∩ S = S ∩ R; (R ∩ S) ∩ T = R ∩ (S ∩ T)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涉及选择的定律&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;σ&lt;!-- raw HTML omitted --&gt;C1 AND C2&lt;!-- raw HTML omitted --&gt; = σ&lt;!-- raw HTML omitted --&gt;C1&lt;!-- raw HTML omitted --&gt;(σ&lt;!-- raw HTML omitted --&gt;C2&lt;!-- raw HTML omitted --&gt;( R ))&lt;/p&gt;
&lt;p&gt;σ&lt;!-- raw HTML omitted --&gt;C1 OR C2&lt;!-- raw HTML omitted --&gt; = (σ&lt;!-- raw HTML omitted --&gt;C1&lt;!-- raw HTML omitted --&gt;( R ) ∪ (σ&lt;!-- raw HTML omitted --&gt;C2&lt;!-- raw HTML omitted --&gt;( R ) )&lt;/p&gt;
&lt;p&gt;σ&lt;!-- raw HTML omitted --&gt;C1&lt;!-- raw HTML omitted --&gt;(σ&lt;!-- raw HTML omitted --&gt;C2&lt;!-- raw HTML omitted --&gt;( R )) = σ&lt;!-- raw HTML omitted --&gt;C2&lt;!-- raw HTML omitted --&gt;(σ&lt;!-- raw HTML omitted --&gt;C1&lt;!-- raw HTML omitted --&gt;( R ))&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下推选择&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在表达式中下推选择是查询优化器最强有力的工具。&lt;/p&gt;
&lt;p&gt;σ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;( R × S ) = σ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;( R ) × S&lt;/p&gt;
&lt;p&gt;σ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;( R ⋈ S) = σ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;( R ) ⋈ S&lt;/p&gt;
&lt;p&gt;σ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;( R ⋈&lt;!-- raw HTML omitted --&gt;D&lt;!-- raw HTML omitted --&gt; S) = σ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;( R ) ⋈&lt;!-- raw HTML omitted --&gt;D&lt;!-- raw HTML omitted --&gt; S&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涉及连接和笛卡尔积的定律&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;R ⋈&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt; S = σ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;( R × S)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涉及消除重复的定律&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;δ(R×S) = δ( R ) × δ(S)&lt;/p&gt;
&lt;p&gt;δ(R⋈&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;S) = δ( R ) ⋈&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt; δ(S)&lt;/p&gt;
&lt;p&gt;另外还有涉及投影的定律、涉及分组和聚集的定律。这部分有些理论化，可以参考这篇&lt;a class=&#34;link&#34; href=&#34;https://pingcap.com/blog-cn/tidb-source-code-reading-7/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《TiDB 源码阅读系列文章（七）基于规则的优化》&lt;/a&gt;看看 &lt;code&gt;TiDB&lt;/code&gt; 具体是怎么做的。&lt;/p&gt;
&lt;p&gt;对于本例使用到的定律比较简单。先将选择的两部分分解为 σ&lt;!-- raw HTML omitted --&gt;employees.emp_no = salaries.emp_no&lt;!-- raw HTML omitted --&gt;
和 σ&lt;!-- raw HTML omitted --&gt;salary &amp;gt; 7000&lt;!-- raw HTML omitted --&gt;，后者可以在树中下推。第一个条件涉及笛卡尔积两边的属性，可以把上面提到的定律 R ⋈&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt; S = σ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;( R × S)&lt;/p&gt;
&lt;p&gt;从右向左使用，把&lt;strong&gt;笛卡尔积&lt;/strong&gt;转换成&lt;strong&gt;连接&lt;/strong&gt;。使用了两个定律后，得到优化后的逻辑查询计划如下图：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;物理查询计划的生成&#34;&gt;物理查询计划的生成&lt;/h3&gt;
&lt;p&gt;这一步我们需要把&lt;strong&gt;逻辑查询计划&lt;/strong&gt;转换成&lt;strong&gt;物理查询计划&lt;/strong&gt;。通常由逻辑计划可以得到多个物理计划，我们需要对每个物理计划进行评估，选择具有最小估计代价的物理查询计划。&lt;/p&gt;
&lt;h4 id=&#34;基于代价的物理计划选择&#34;&gt;基于代价的物理计划选择&lt;/h4&gt;
&lt;p&gt;在从逻辑计划构建物理计划的时候，因为可能得到多个物理计划，我们需要通过估计物理计划执行的代价来确定最优选择。&lt;/p&gt;
&lt;p&gt;如何计算这个代价呢？我们可以用物理计划每一步的任务执行时发生的磁盘I/O数、网络吞吐量、占用的内存空间大小等近似估算。&lt;/p&gt;
&lt;p&gt;这些资源的访问和占用，又是由什么决定的呢？可能包括的决定因素有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参与运算任务执行的数据大小&lt;/li&gt;
&lt;li&gt;数据的分布位置（连续的磁盘空间、离散的磁盘空间、网络节点等）&lt;/li&gt;
&lt;li&gt;关系中属性的不同值的数目&lt;/li&gt;
&lt;li&gt;属性值的最大值、最小值、以及值的分布情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据库会收集统计这些信息，用来估算具体任务的代价。&lt;/p&gt;
&lt;p&gt;逻辑查询计划在转换成物理计划的时候，每一步的转换都会面临多种情况的选择，最容易想到的是使用穷举法，估算每一种情况的代价，最后确定最优的物理计划。但使用穷举法的话，很可能估算本身的代价变得非常大，实践中可以采用&lt;strong&gt;动态规划&lt;/strong&gt;（dynamic programming）等算法。&lt;/p&gt;
&lt;h4 id=&#34;枚举物理查询计划&#34;&gt;枚举物理查询计划&lt;/h4&gt;
&lt;p&gt;以上一步输出的逻辑查询计划为例，看看在枚举物理查询计划时需要做出哪些选择。&lt;/p&gt;
&lt;p&gt;首先，逻辑查询计划的每个结点转换成什么样的物理运算符会遇到多种选择。我们从逻辑查询计划树自底往上来看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑计划的叶子结点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;逻辑查询计划树的叶子结点被一个&lt;strong&gt;扫描运算符&lt;/strong&gt;替代。这些运算符一般包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;TableScan( R )&lt;/strong&gt;：以任意顺序读人所有元组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SortScan(R, L)&lt;/strong&gt;：按照顺序读入&lt;code&gt;R&lt;/code&gt;的元组，并以列&lt;code&gt;L&lt;/code&gt;中的属性进行排列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IndexScan(R, C)&lt;/strong&gt;：&lt;code&gt;C&lt;/code&gt;是一个带有比较运算符的条件，例如 &lt;code&gt;A = 100&lt;/code&gt;，&lt;code&gt;A&lt;/code&gt;是&lt;code&gt;R&lt;/code&gt;的一个属性，如果&lt;code&gt;A&lt;/code&gt;上建立的索引，可以通过索引来访问&lt;code&gt;R&lt;/code&gt;的元组。如果比较运算符不是等值比较，则索引必须是一个支持范围查询的索引，例如&lt;code&gt;B+ Tree&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IndexScan(R, A)&lt;/strong&gt;：这里&lt;code&gt;A&lt;/code&gt;是&lt;code&gt;R&lt;/code&gt;的一个属性，关系&lt;code&gt;R&lt;/code&gt;通过&lt;code&gt;A&lt;/code&gt;上的索引被检索。 如果&lt;code&gt;R&lt;/code&gt;的数据在磁盘上不是占用连续的存储空间，该运算符可能比&lt;strong&gt;TableScan&lt;/strong&gt;更有效。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;逻辑计划的σ选择（selection)结点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;σ&lt;/code&gt;选择结点一般有两种选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以简单的用物理过滤运算符&lt;code&gt;Filter( C )&lt;/code&gt;替代 σ&lt;!-- raw HTML omitted --&gt;C&lt;!-- raw HTML omitted --&gt;( R )&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;C&lt;/code&gt;是一个带有比较运算符的条件，例如 &lt;code&gt;A = 100&lt;/code&gt;，并且属性&lt;code&gt;A&lt;/code&gt;上有索引，可以把比较运算合并到&lt;strong&gt;扫描运算符&lt;/strong&gt;：&lt;code&gt;IndexScan(R, A = 100)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于本例，&lt;code&gt;salary&lt;/code&gt; 一般都不会建立索引，因此可以把&lt;code&gt;σ( salary &amp;gt; 7000 )&lt;/code&gt; 替换为 &lt;code&gt;Filter( salary &amp;gt; 7000 )&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑计划的连接结点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的&lt;strong&gt;等值连接&lt;/strong&gt;满足&lt;strong&gt;结合律&lt;/strong&gt;和&lt;strong&gt;交换律&lt;/strong&gt;，因此&lt;strong&gt;连接&lt;/strong&gt;可以得到很多候选的物理执行计划。其中最关键的问题是确定连接顺序。&lt;/p&gt;
&lt;p&gt;当两个关系连接，只有两种选择，一般我们应该将估计值较小的关系放在前面。当连接有2个以上关系时，可能的连接树的数量会迅速增加，例如4个关系的连接将会有&lt;code&gt;4!=24&lt;/code&gt;种连接方式。这一部分很复杂，就不在本文讨论了。&lt;/p&gt;
&lt;p&gt;除了连接顺序，还需要确定具体使用的连接算法。常见的算法有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;nested loops&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于排序的join&lt;/strong&gt;（sort merge join）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hash join&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于索引的join&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;逻辑计划的投影结点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;投影结点的任务比较明确，输出包含指定列的关系。&lt;/p&gt;
&lt;p&gt;除了将逻辑查询计划的结点转换成物理运算符，在选择物理计划时还要考虑数据如何在运算符之间流动（中间结果保存到磁盘或流水线方式），物理运算符的执行顺序等。这些细节本文就不再讨论。&lt;/p&gt;
&lt;p&gt;最后，假定我们在所有选择的组合中，确定了其中一个作为最优的物理查询计划，然后就可以把它交给查询执行器真正的执行了：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;本文把关系数据库查询处理涉及的基础知识进行了梳理，希望对你理解 &lt;code&gt;TiDB&lt;/code&gt; 的代码能有所帮助。&lt;/p&gt;
&lt;p&gt;数据库是一个非常迷人的领域，它有很强的理论基础，同时又涉及大量的工程实践，可以说是最复杂的系统软件之一。我相信能开发数据库是很多程序员的梦想。梦想还是要有的，让我们一起努力吧！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>关于MySQL XA事务的隔离级别</title>
        <link>https://mazhen.tech/p/%E5%85%B3%E4%BA%8Emysql-xa%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
        <pubDate>Tue, 05 Jun 2018 14:44:59 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E5%85%B3%E4%BA%8Emysql-xa%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
        <description>&lt;h2 id=&#34;为什么xa事务建议用serializable隔离级别&#34;&gt;为什么XA事务建议用SERIALIZABLE隔离级别&lt;/h2&gt;
&lt;p&gt;在MySQL最新的官方文档中，关于&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/xa.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;XA Transactions&lt;/a&gt;的介绍有这么一段描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As with nondistributed transactions, &lt;code&gt;SERIALIZABLE&lt;/code&gt; may be preferred if your applications are sensitive to read phenomena. &lt;code&gt;REPEATABLE READ&lt;/code&gt; may not be sufficient for distributed transactions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这段话表达的意思是，对于分布式XA事务， &lt;code&gt;REPEATABLE READ&lt;/code&gt; 隔离级别是不够的。&lt;/p&gt;
&lt;p&gt;MySQL旧版本的&lt;a class=&#34;link&#34; href=&#34;https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/xa.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;文档&lt;/a&gt;，对于这个问题表达的更加直接：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, for a distributed transaction, you must use the &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level to achieve ACID properties. It is enough to use REPEATABLE READ for a nondistributed transaction, but not for a distributed transaction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;怎么理解呢？举个简单的例子：假设MySQL使用的是&lt;code&gt;REPEATABLE READ&lt;/code&gt; 隔离级别，XA事务 &lt;code&gt;T1 &lt;/code&gt; 修改的数据涉及两个节点 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt;，当事务 &lt;code&gt;T1&lt;/code&gt; 在 &lt;code&gt;A&lt;/code&gt; 上完成commit，而在 &lt;code&gt;B&lt;/code&gt; 上还没commit之前，也就是说这时事务 &lt;code&gt;T1&lt;/code&gt; 并没有真正结束，另一个XA事务 &lt;code&gt;T2&lt;/code&gt; 已经可以访问到 &lt;code&gt;T1&lt;/code&gt; 在 &lt;code&gt;A&lt;/code&gt; 上提交后数据，这不是出现脏读了吗？&lt;/p&gt;
&lt;p&gt;那么使用&lt;code&gt;SERIALIZABLE&lt;/code&gt;就能保证吗？还是看例子：事务 &lt;code&gt;T1&lt;/code&gt; 修改节点 &lt;code&gt;A&lt;/code&gt; 上的数据 &lt;code&gt;a -&amp;gt; a&#39;&lt;/code&gt;，修改 &lt;code&gt;B&lt;/code&gt; 上的数据 &lt;code&gt;b -&amp;gt; b&#39;&lt;/code&gt;，在提交阶段，可能被其他事务 &lt;code&gt;T2&lt;/code&gt; 读取到了 &lt;code&gt;a&#39;&lt;/code&gt;， 因为使用了&lt;code&gt;SERIALIZABLE&lt;/code&gt;隔离级别， MySQL 会对所有读加锁，那么 &lt;code&gt;T2&lt;/code&gt; 在 &lt;code&gt;B&lt;/code&gt; 上读取 &lt;code&gt;b&lt;/code&gt; 时会被一直阻塞，直到 &lt;code&gt;T1&lt;/code&gt; 在 &lt;code&gt;B&lt;/code&gt; 上完成commit，这时 &lt;code&gt;T2&lt;/code&gt; 在 &lt;code&gt;B&lt;/code&gt; 读取到的就是 &lt;code&gt;b&#39;&lt;/code&gt;。 也就是说，&lt;code&gt;SERIALIZABLE&lt;/code&gt;隔离级别保证了读到 &lt;code&gt;a&#39;&lt;/code&gt; 的事务，不会读到 &lt;code&gt;b&lt;/code&gt; ，而是读到 &lt;code&gt;b&#39;&lt;/code&gt;，确保了事务ACID的要求。&lt;/p&gt;
&lt;p&gt;更加详细的描述可以参考&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1005380&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;鹅厂 TDSQL XA 事务隔离级别的奥秘&lt;/a&gt;，他们的结论是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果某个并发事务调度机制可以让具有依赖关系的事务构成一个有向无环图(DAG)，那么这个调度就是可串行化的调度。由于每个后端DB都在使用serializable隔离级别，所以每个后端DB上面并发执行的事务分支构成的依赖关系图一定是DAG。&lt;/p&gt;
&lt;p&gt;只要所有连接都是用serializable隔离级别，那么TDSQL XA执行的事务仍然可以达到可串行化隔离级别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;serializable性能差有更好的实现方式吗&#34;&gt;SERIALIZABLE性能差，有更好的实现方式吗&lt;/h2&gt;
&lt;p&gt;如果分布式事务想实现&lt;code&gt;read-committed&lt;/code&gt;以上的隔离级别，又不想使用&lt;code&gt;SERIALIZABLE&lt;/code&gt;，有什么更好的方式吗？&lt;/p&gt;
&lt;p&gt;当然有，想想看&lt;code&gt;TiDB&lt;/code&gt;是怎么做的，底层&lt;code&gt;TiKV&lt;/code&gt;是一个整体，有全局的MVCC，所以能够做到分布式事务的Snapshot隔离级别。&lt;/p&gt;
&lt;p&gt;PostgreSQL社区中，有&lt;a class=&#34;link&#34; href=&#34;http://postgresxc.wikia.com/wiki/Postgres-XC_Wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Postgres-XC&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://www.postgres-xl.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Postgres-XL&lt;/a&gt;的方案，采用的并发机制是全局MVCC 和本地写锁。 &lt;code&gt;Postgres-XC&lt;/code&gt; 维持了全局活跃事务列表，从而提供全局MVCC。&lt;/p&gt;
&lt;p&gt;虽然MySQL也实现了MVCC，但它没有将底层K/V带有时间戳的版本信息暴露出来。也就是说，多个MySQL实例组成的集群没有全局的MVCC，无法得到全局一致性快照，自然就很难做到分布式的Snapshot隔离级别。腾讯的&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1005380&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这篇文章&lt;/a&gt;也分析了这么做比较困难：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于MySQL innodb使用MVCC做select（除了serializable和for update/lock in share mode子句），还需要将这个全局事务id给予innodb做事务id，同时，还需要TDSQL XA集群的多个set的innodb 共享各自的本地事务状态给所有其他innodb（这也是PGXL 所做的），&lt;strong&gt;任何一个innodb的本地事务的启动，prepare，commit，abort都需要通知给所有其他innodb实例。只有这样做，集群中的每个innodb实例才能够建立全局完全有一致的、当前集群中正在处理的所有事务的状态，以便做多版本并发控制。&lt;/strong&gt; 这本身都会造成极大的性能开销，并且导致set之间的严重依赖，降低系统可靠性。这些都是我们要极力避免的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;根据上面的分析，如果使用MySQL 的 XA分布式事务，最安全的方式还是按照官方建议，使用&lt;code&gt;SERIALIZABLE&lt;/code&gt;隔离级别。&lt;/p&gt;
&lt;p&gt;如果想基于MySQL做改造，实现全局MVCC，从而实现分布式事务的Snapshot隔离级别，目前还没有看到MySQL社区有这类项目，相信实现难度比较大。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>从RadonDB看新型数据库中间件的特性</title>
        <link>https://mazhen.tech/p/%E4%BB%8Eradondb%E7%9C%8B%E6%96%B0%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E7%89%B9%E6%80%A7/</link>
        <pubDate>Sun, 03 Jun 2018 14:43:12 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E4%BB%8Eradondb%E7%9C%8B%E6%96%B0%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E7%89%B9%E6%80%A7/</guid>
        <description>&lt;p&gt;现在新出现的MySQL中间件除了基本的数据sharding功能，都增加了很多高级特性，我觉得有三个特性比较重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分布式事务的支持&lt;/li&gt;
&lt;li&gt;数据的强一致复制，提高了数据的安全性和可用性&lt;/li&gt;
&lt;li&gt;支持跨shard join&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过对这些特性的支持，MySQL中间件具备了一些newSQL数据库的能力，不再是个纯粹的中间件，让用户更容易使用。我调研了最近开源的青云&lt;a class=&#34;link&#34; href=&#34;http://radondb.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RadonDB&lt;/a&gt;，希望了解下这方面最新的进展。&lt;/p&gt;
&lt;p&gt;先简单看下&lt;code&gt;RadonDB&lt;/code&gt;的整体架构：存储/计算分离。存储节点是&lt;code&gt;MySQL&lt;/code&gt;，3个一组用&lt;code&gt;raft&lt;/code&gt;实现数据的强一致性，不再是异步/半同步复制，数据的安全性、可用性级别更高。上层是&lt;code&gt;SQL节点&lt;/code&gt;，负责客户端连接、SQL语句的解析和执行、分布式事务协调、数据sharding逻辑等。右下脚&lt;code&gt;计算节点&lt;/code&gt;的作用，后面会解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011444858.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在知乎上看到&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/276564413&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&amp;lt;如何评价青云开源的分布式数据库 radondb&amp;gt;&lt;/a&gt;，&lt;code&gt;RandoDB&lt;/code&gt;被吐槽的很厉害。我们从这些吐槽可以了解产品宣传之外的一些信息，知道做这种中间件不是那么容易。大家对&lt;code&gt;RandoDB&lt;/code&gt;的几个关键特性的实现方式都不太满意。让我们逐一看看。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分布式事务的实现&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对分布式事务的实现大家吐槽的最厉害：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官方宣传用XA实现了Snapshot Isolation，然而众所周知XA是无法实现SI的。所谓的事务其实只支持单条SQL，BEGIN / SET AUTOCOMMIT=0 都不支持。&lt;/p&gt;
&lt;p&gt;单语句事务，就是不能 begin 开启事务。&lt;/p&gt;
&lt;p&gt;为了达到 SI 隔离级别，在执行用户 SQL 时，会加上一个 commitLock，防止其他事务提交。这决定了加锁必须时间很短，比如一条SQL，如果你从start transaction开始加锁，那其他事务全都无法提交了，系统事实上已经不可用。&lt;/p&gt;
&lt;p&gt;所谓分布式事物快照隔离级别是 radondb 层 query 和 commit 语句串行化实现的。这个应该是串行化隔离级别了。而且是和冲突没关系的串行化，就是说根本不管两个事物之间有没有冲突数据。性能自行脑补。&lt;/p&gt;
&lt;p&gt;没有 XA log 的 XA 事务原子性实现都是耍流氓。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么&lt;em&gt;XA是无法实现SI&lt;/em&gt;？ 我的理解是，单个MySQL实例虽然实现了&lt;code&gt;MVCC&lt;/code&gt;，但它没有将底层&lt;code&gt;K/V&lt;/code&gt;带有时间戳的版本信息暴露出来。也就是说，多个MySQL实例组成的集群没有全局的&lt;code&gt;MVCC&lt;/code&gt;，每个实例内部的&lt;code&gt;MVCC&lt;/code&gt;是独立的，无法得到全局一致性快照。XA事务跨越了多个节点，所以没办法实现&lt;code&gt;Snapshot隔离级别&lt;/code&gt;。可以对比下&lt;code&gt;TiDB&lt;/code&gt;的实现，底层&lt;code&gt;TiKV&lt;/code&gt;是一个整体，有全局的&lt;code&gt;MVCC&lt;/code&gt;，所以能在上层支持分布式事务的&lt;code&gt;Snapshot隔离级别&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RandoDB&lt;/code&gt;的实现能work，但相当于在Proxy层将所有事务串行化，即使两个事务之间没有数据冲突。而且只有单语句事务。&lt;/p&gt;
&lt;p&gt;对于XA log，开发者的解释是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;proxy xa log只针对xa commit出错，目前通过分析log然后人工介入，这里没有再记log的必要&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我觉得这么做很不严谨。2PC协议有一个问题，一旦事务参与者投票，它必须等待coordinator给出指示，提交或放弃。如果这时coordinator挂了，事务参与者除了等待什么也做不了。事务处于未决状态，事务的最终结果记录在coordinator的事务日志中，只能等它recovery。因此，现在很多改进的做法是用&lt;code&gt;Paxos/raft&lt;/code&gt;保证事务日志的高可用，coordinator挂了可以快速切换。即使不用&lt;code&gt;raft&lt;/code&gt;，找一个地方可靠持久的保存事务日志是非常必要的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用Raft保证强一致性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在很多项目都会使用&lt;code&gt;Paxos/Raft&lt;/code&gt;来改进MySQL的复制机制，实现数据的强一致性。如果主、备间任何时刻都完全一致，那么任何时刻都可以安全的进行主备切换。如果无法保证主、备间的强一致性，那么当有持续不断的更新时，主备切换就无法保证强一致性，需要在切换时暂停主库的写入，服务会有短暂的中断。&lt;/p&gt;
&lt;p&gt;腾讯的&lt;a class=&#34;link&#34; href=&#34;https://github.com/Tencent/phxsql&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PhxSQL&lt;/a&gt;就是建立在&lt;code&gt;Paxos&lt;/code&gt;的一致性和MySQL的&lt;code&gt;binlog&lt;/code&gt;流水基础上，通过&lt;code&gt;Paxos&lt;/code&gt;保证强一致和高可用的MySQL集群。关于PhxSQL的设计理念可以参见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/Qz2R4oTqWk3SmhuHCQOleQ&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;谈谈PhxSQL的设计和实现哲学（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/M2h6v7MuYEnbktVb8VswZw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;谈谈PhxSQL的设计和实现哲学（下）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采用类似做法的还有阿里云的&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/document_detail/51701.htm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL金融版&lt;/a&gt;。另外，MySQL官方也从5.7开始推出了&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/5.7/en/group-replication.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Group Replication&lt;/a&gt;机制，内部使用&lt;code&gt;Paxos&lt;/code&gt;实现了多个副本的一致。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RadonDB&lt;/code&gt;的实现机制和&lt;a class=&#34;link&#34; href=&#34;https://github.com/Tencent/phxsql&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PhxSQL&lt;/a&gt;不太一样。它在一组MySQL集群内的复制还是通过&lt;code&gt;Semi-Sync&lt;/code&gt;机制（Semi-Sync设置为无限大，不退化为异步复制），保证有一个&lt;code&gt;slave&lt;/code&gt;和&lt;code&gt;master&lt;/code&gt;完全一致。主备切换时会选择这个&lt;code&gt;slave&lt;/code&gt;为主，然后结合MySQL的 &lt;code&gt;Multi-threaded replication&lt;/code&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/5.7/en/replication-gtids.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GTID机制&lt;/a&gt; 进行快速回放，让主备重新一致。&lt;code&gt;Raft&lt;/code&gt;用在哪里了？在 &lt;code&gt;RadonDB&lt;/code&gt; 只使用 &lt;code&gt;Raft&lt;/code&gt; 进行选主，当主挂掉之后，使用 &lt;code&gt;Raft&lt;/code&gt; 选出新的主。&lt;code&gt;Raft&lt;/code&gt;选主的逻辑是选出一个拥有最多的&lt;code&gt;committed log&lt;/code&gt;的成员作为主，那么对于&lt;code&gt;RadonDB&lt;/code&gt;来说，哪个MySQL的&lt;code&gt;GTID&lt;/code&gt;最大就选哪个。&lt;/p&gt;
&lt;p&gt;我自己还没有使用&lt;code&gt;Raft&lt;/code&gt;的经验，不确定&lt;code&gt;RadonDB&lt;/code&gt;的实现机制是否合理。但利用&lt;code&gt;Semi-Sync&lt;/code&gt;模拟同步复制的方案，我觉得有一个地方不妥。当和主库保持强同步的备库有问题时，这组MySQL整体就不可用，因为它需要至少一个备库和主库完全一致，这就因为单点降低了整个集群的可用性。如果是用&lt;code&gt;Raft&lt;/code&gt;做数据复制，就不会有这种单点影响全局可用性的问题。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;RandoDB&lt;/code&gt;被吐槽 &lt;code&gt;Raft&lt;/code&gt; 的实现业余、不严谨：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;打开用来做HA的Xenon模块，一看又是作业级的肯写代码不肯写测试的raft练手实现。raft测试用例一共1500行&lt;a class=&#34;link&#34; href=&#34;https://github.com/radondb/xenon/blob/master/src/raft/raft_test.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go代码&lt;/a&gt;
刚才数了下，自己的raft库光election相关的单元测试用例就数千行代码了。做生产环境用的系统不是练手写作业，需要一个go的raft库，既然都不肯写完备的测试了，那就老老实实用etcd或者hashicorp的raft。自己私下撸一个raft库练手，和给自己全职项目选一个可靠的raft实现，两者真的不矛盾。最滑稽，只做选主干嘛自己撸一个raft实现？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;join等复杂查询的实现&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;严格说&lt;code&gt;RandoDB&lt;/code&gt;是不支持join的。它的做法是让&lt;code&gt;计算节点&lt;/code&gt;通过&lt;code&gt;binglog&lt;/code&gt;复制了全量数据，&lt;code&gt;SQL节点&lt;/code&gt;会把join等复杂查处路由到&lt;code&gt;计算节点&lt;/code&gt;执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“计算节点”使用tokudb存储引擎存储全量数据，为了支持复杂查询。。。如果我一个分布式系统的数据总量有20T、100T，也用单个“计算节点”存储全量数据？而且这个数据同步过程是异步的，显然没法用在OLTP场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过一些实用的方式支持了Join，这种做法可以work，但&lt;code&gt;RandoDB&lt;/code&gt;离它宣称的数据库还差很远，缺少全局的执行计划优化。&lt;/p&gt;
&lt;p&gt;总体来说，&lt;code&gt;RandoDB&lt;/code&gt;的理想很宏大，用实用的方案解决了一些问题，但要成为真正成熟的数据库产品还差的比较远。&lt;code&gt;RadonDB&lt;/code&gt; 的核心代码1万行左右。加上其它类库引入，&lt;code&gt;Radon&lt;/code&gt;代码11万+， &lt;code&gt;Xenon&lt;/code&gt;代码5万行+ 。&lt;/p&gt;
&lt;p&gt;最后，看到有人推荐腾讯的&lt;a class=&#34;link&#34; href=&#34;http://tdsql.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TDSQL&lt;/a&gt;，也顺便了解了一下。从资料看&lt;a class=&#34;link&#34; href=&#34;http://tdsql.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TDSQL&lt;/a&gt;很不错，可惜不是开源产品。除了水平扩张、安全增强、自动化运维以外，它具备了我们上面提到的数据库中间件的高级特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持分布式事务&lt;code&gt;XA&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;全局事务的隔离级别最高可以达到&lt;code&gt;serializable&lt;/code&gt;级别&lt;/li&gt;
&lt;li&gt;分布式事务对业务透明，兼容单机事务语法&lt;/li&gt;
&lt;li&gt;允许事务中多条语句分别发给多个分片&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;autocommit&lt;/code&gt;下单条语句写访问多个分片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;默认采用&lt;strong&gt;强同步复制&lt;/strong&gt;，即主从节点数据完全一致&lt;/li&gt;
&lt;li&gt;复杂查询方面
&lt;ul&gt;
&lt;li&gt;允许以流式处理方式运行&lt;code&gt;group by&lt;/code&gt;、&lt;code&gt;order by&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;支持两个&lt;code&gt;Shard&lt;/code&gt;使用&lt;code&gt;shardkey&lt;/code&gt;（分表键）做等值连接，以及使用&lt;code&gt;shardkey&lt;/code&gt;的子查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;支持了部分受限的复杂查询，对于数据库中间件来说已经算比较强大了。关于&lt;code&gt;TDSQL&lt;/code&gt;的分布式事务，可以通过这两篇进行更多的了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1005840&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一文教你迅速解决分布式事务 XA 一致性问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1005380&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;鹅厂 TDSQL XA 事务隔离级别的奥秘&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们做MySQL中间件，可以瞄准&lt;code&gt;TDSQL&lt;/code&gt;，对于分布式事务、数据强一致性，以及复杂查询、跨shard join 等特性都要考虑支持。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>TiDB Insert 执行流程图</title>
        <link>https://mazhen.tech/p/tidb-insert-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE/</link>
        <pubDate>Tue, 15 May 2018 14:38:05 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/tidb-insert-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE/</guid>
        <description>&lt;p&gt;TiDB源码解读系列的&lt;a class=&#34;link&#34; href=&#34;https://pingcap.com/blog-cn/tidb-source-code-reading-4/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Insert语句概览》&lt;/a&gt;讲解了&lt;code&gt;Insert&lt;/code&gt;执行的整体流程，并在最后用一幅图描述了整个流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011439770.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我按照自己的理解对这幅图扩展了一下，在原先数据结构转换流程的基础上，补充了代码的调用流程，个人感觉更加全面，希望对你阅读代码也有帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011439951.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Cursor功能实现总结</title>
        <link>https://mazhen.tech/p/cursor%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/</link>
        <pubDate>Fri, 11 May 2018 17:01:04 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/cursor%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/</guid>
        <description>&lt;script type=&#34;text/javascript&#34; src=&#34;https://mazhen.tech/js/pdf-js/build/pdf.js&#34;&gt;&lt;/script&gt;
&lt;style&gt;
  #the-canvas {
    border: 1px solid black;
    direction: ltr;
    width: 100%;
    height: auto;
    display: none;
  }

  #paginator {
    display: none;
    text-align: center;
    margin-bottom: 10px;
  }

  #loadingWrapper {
    display: none;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 350px;
  }

  #loading {
    display: inline-block;
    width: 50px;
    height: 50px;
    border: 3px solid #d2d0d0;
    ;
    border-radius: 50%;
    border-top-color: #383838;
    animation: spin 1s ease-in-out infinite;
    -webkit-animation: spin 1s ease-in-out infinite;
  }

  @keyframes spin {
    to {
      -webkit-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spin {
    to {
      -webkit-transform: rotate(360deg);
    }
  }
&lt;/style&gt;

&lt;div id=&#34;paginator&#34;&gt;
  &lt;button id=&#34;prev&#34;&gt;Previous&lt;/button&gt;
  &lt;button id=&#34;next&#34;&gt;Next&lt;/button&gt;
  &amp;nbsp; &amp;nbsp;
  &lt;span&gt;Page: &lt;span id=&#34;page_num&#34;&gt;&lt;/span&gt; / &lt;span id=&#34;page_count&#34;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div id=&#34;embed-pdf-container&#34;&gt;
  &lt;div id=&#34;loadingWrapper&#34;&gt;
    &lt;div id=&#34;loading&#34;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;canvas id=&#34;the-canvas&#34;&gt;&lt;/canvas&gt;
&lt;/div&gt;

&lt;script type=&#34;text/javascript&#34;&gt;
  window.onload = function () {
    
    
    var url = &#34;https:\/\/mazhen.tech&#34; + &#39;.\/pdf\/202207011702216.pdf&#39;;

    var hidePaginator = &#34;&#34; === &#34;true&#34;;
    var hideLoader = &#34;&#34; === &#34;true&#34;;
    var selectedPageNum = parseInt(&#34;&#34;) || 1;

    
    var pdfjsLib = window[&#39;pdfjs-dist/build/pdf&#39;];

    
    pdfjsLib.GlobalWorkerOptions.workerSrc = &#34;https:\/\/mazhen.tech&#34; + &#39;/js/pdf-js/build/pdf.worker.js&#39;;

    
    var pdfDoc = null,
      pageNum = selectedPageNum,
      pageRendering = false,
      pageNumPending = null,
      scale = 3,
      canvas = document.getElementById(&#39;the-canvas&#39;),
      ctx = canvas.getContext(&#39;2d&#39;),
      paginator = document.getElementById(&#34;paginator&#34;),
      loadingWrapper = document.getElementById(&#39;loadingWrapper&#39;);


    
    showPaginator();
    showLoader();

    

    function renderPage(num) {
      pageRendering = true;
      
      pdfDoc.getPage(num).then(function (page) {
        var viewport = page.getViewport({ scale: scale });
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        
        var renderContext = {
          canvasContext: ctx,
          viewport: viewport
        };
        var renderTask = page.render(renderContext);

        
        renderTask.promise.then(function () {
          pageRendering = false;
          showContent();

          if (pageNumPending !== null) {
            
            renderPage(pageNumPending);
            pageNumPending = null;
          }
        });
      });

      
      document.getElementById(&#39;page_num&#39;).textContent = num;
    }

    

    function showContent() {
      loadingWrapper.style.display = &#39;none&#39;;
      canvas.style.display = &#39;block&#39;;
    }

    

    function showLoader() {
      if (hideLoader) return
      loadingWrapper.style.display = &#39;flex&#39;;
      canvas.style.display = &#39;none&#39;;
    }

    

    function showPaginator() {
      if (hidePaginator) return
      paginator.style.display = &#39;block&#39;;
    }

    

    function queueRenderPage(num) {
      if (pageRendering) {
        pageNumPending = num;
      } else {
        renderPage(num);
      }
    }

    

    function onPrevPage() {
      if (pageNum &lt;= 1) {
        return;
      }
      pageNum--;
      queueRenderPage(pageNum);
    }
    document.getElementById(&#39;prev&#39;).addEventListener(&#39;click&#39;, onPrevPage);

    

    function onNextPage() {
      if (pageNum &gt;= pdfDoc.numPages) {
        return;
      }
      pageNum++;
      queueRenderPage(pageNum);
    }
    document.getElementById(&#39;next&#39;).addEventListener(&#39;click&#39;, onNextPage);

    

    pdfjsLib.getDocument(url).promise.then(function (pdfDoc_) {
      pdfDoc = pdfDoc_;
      var numPages = pdfDoc.numPages;
      document.getElementById(&#39;page_count&#39;).textContent = numPages;

      
      if (pageNum &gt; numPages) {
        pageNum = numPages
      }

      
      renderPage(pageNum);
    });
  }

&lt;/script&gt;
</description>
        </item>
        <item>
        <title>TiDB SQL Parser 的实现</title>
        <link>https://mazhen.tech/p/tidb-sql-parser-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Wed, 09 May 2018 14:34:58 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/tidb-sql-parser-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;p&gt;PingCAP发布了TiDB的&lt;a class=&#34;link&#34; href=&#34;https://pingcap.com/blog-cn/#%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;源码阅读系列文章&lt;/a&gt;，让我们可以比较系统的去学习了解TiDB的内部实现。最近的一篇&lt;a class=&#34;link&#34; href=&#34;https://pingcap.com/blog-cn/tidb-source-code-reading-3/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《SQL 的一生》&lt;/a&gt;，从整体上讲解了一条SQL语句的处理流程，从网络上接收数据，MySQL协议解析和转换，SQL语法解析，查询计划的制定和优化，查询计划执行，到最后返回结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011436753.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;SQL Parser&lt;/code&gt;的功能是把SQL语句按照SQL语法规则进行解析，将文本转换成抽象语法树（&lt;code&gt;AST&lt;/code&gt;），这部分功能需要些背景知识才能比较容易理解，我尝试做下相关知识的介绍，希望能对读懂这部分代码有点帮助。&lt;/p&gt;
&lt;p&gt;TiDB是使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/cznic/goyacc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;goyacc&lt;/a&gt;根据预定义的SQL语法规则文件&lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/master/parser/parser.y&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;parser.y&lt;/a&gt;生成SQL语法解析器。我们可以在TiDB的&lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/50e98f427e7943396dbe38d23178b9f9dc5398b7/Makefile#L50&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Makefile&lt;/a&gt;文件中看到这个过程，先build &lt;code&gt;goyacc&lt;/code&gt;工具，然后使用&lt;code&gt;goyacc&lt;/code&gt;根据&lt;code&gt;parser.y&lt;/code&gt;生成解析器&lt;code&gt;parser.go&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;goyacc:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; $(GOBUILD) -o bin/goyacc parser/goyacc/main.go
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;parser: goyacc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; bin/goyacc -o /dev/null parser/parser.y
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; bin/goyacc -o parser/parser.go parser/parser.y 2&amp;gt;&amp;amp;1 ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cznic/goyacc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;goyacc&lt;/a&gt;是&lt;a class=&#34;link&#34; href=&#34;http://dinosaur.compilertools.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;yacc&lt;/a&gt;的Golang版，所以要想看懂语法规则定义文件&lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/master/parser/parser.y&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;parser.y&lt;/a&gt;，了解解析器是如何工作的，先要对&lt;a class=&#34;link&#34; href=&#34;http://dinosaur.compilertools.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Lex &amp;amp; Yacc&lt;/a&gt;有些了解。&lt;/p&gt;
&lt;h2 id=&#34;lex--yacc-介绍&#34;&gt;Lex &amp;amp; Yacc 介绍&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://dinosaur.compilertools.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Lex &amp;amp; Yacc&lt;/a&gt; 是用来生成词法分析器和语法分析器的工具，它们的出现简化了编译器的编写。&lt;code&gt;Lex &amp;amp; Yacc&lt;/code&gt; 分别是由贝尔实验室的&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Mike_Lesk&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Mike Lesk&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Stephen_C._Johnson&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Stephen C. Johnson&lt;/a&gt;在1975年发布。对于Java程序员来说，更熟悉的是&lt;a class=&#34;link&#34; href=&#34;http://www.antlr.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ANTLR&lt;/a&gt;，&lt;code&gt;ANTLR 4&lt;/code&gt; 提供了 &lt;code&gt;Listener&lt;/code&gt;+&lt;code&gt;Visitor&lt;/code&gt; 组合接口， 不需要在语法定义中嵌入&lt;code&gt;actions&lt;/code&gt;，使应用代码和语法定义解耦。&lt;code&gt;Spark&lt;/code&gt;的SQL解析就是使用了&lt;code&gt;ANTLR&lt;/code&gt;。&lt;code&gt;Lex &amp;amp; Yacc&lt;/code&gt; 相对显得有些古老，实现的不是那么优雅，不过我们也不需要非常深入的学习，只要能看懂语法定义文件，了解生成的解析器是如何工作的就够了。我们可以从一个简单的例子开始：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011436897.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图描述了使用&lt;code&gt;Lex &amp;amp; Yacc&lt;/code&gt;构建编译器的流程。&lt;code&gt;Lex&lt;/code&gt;根据用户定义的&lt;code&gt;patterns&lt;/code&gt;生成词法分析器。词法分析器读取源代码，根据&lt;code&gt;patterns&lt;/code&gt;将源代码转换成&lt;code&gt;tokens&lt;/code&gt;输出。&lt;code&gt;Yacc&lt;/code&gt;根据用户定义的语法规则生成语法分析器。语法分析器以词法分析器输出的&lt;code&gt;tokens&lt;/code&gt;作为输入，根据语法规则创建出语法树。最后对语法树遍历生成输出结果，结果可以是产生机器代码，或者是边遍历 &lt;code&gt;AST&lt;/code&gt; 边解释执行。&lt;/p&gt;
&lt;p&gt;从上面的流程可以看出，用户需要分别为&lt;code&gt;Lex&lt;/code&gt;提供&lt;code&gt;patterns&lt;/code&gt;的定义，为 &lt;code&gt;Yacc&lt;/code&gt; 提供语法规则文件，&lt;code&gt;Lex &amp;amp; Yacc&lt;/code&gt; 根据用户提供的输入文件，生成符合他们需求的词法分析器和语法分析器。这两种配置都是文本文件，并且结构相同：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;... definitions ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;... rules ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;... subroutines ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;文件内容由 &lt;code&gt;%%&lt;/code&gt; 分割成三部分，我们重点关注中间规则定义部分。对于上面的例子，&lt;code&gt;Lex&lt;/code&gt; 的输入文件如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/* 变量 */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[a-z]    {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            yylval = *yytext - &amp;#39;a&amp;#39;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return VARIABLE;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/* 整数 */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[0-9]+   {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            yylval = atoi(yytext);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return INTEGER;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/* 操作符 */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[-+()=/*\n] { return *yytext; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/* 跳过空格 */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[ \t]    ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/* 其他格式报错 */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.        yyerror(&amp;#34;invalid character&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面只列出了规则定义部分，可以看出该规则使用正则表达式定义了变量、整数和操作符等几种&lt;code&gt;token&lt;/code&gt;。例如整数&lt;code&gt;token&lt;/code&gt;的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[0-9]+  {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            yylval = atoi(yytext);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return INTEGER; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当输入字符串匹配这个正则表达式，大括号内的动作会被执行：将整数值存储在变量 &lt;code&gt;yylval&lt;/code&gt; 中，并返回 &lt;code&gt;token&lt;/code&gt; 类型 &lt;code&gt;INTEGER&lt;/code&gt; 给 &lt;code&gt;Yacc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再来看看 &lt;code&gt;Yacc&lt;/code&gt; 语法规则定义文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%token INTEGER VARIABLE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%left &amp;#39;+&amp;#39; &amp;#39;-&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%left &amp;#39;*&amp;#39; &amp;#39;/&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;program:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        program statement &amp;#39;\n&amp;#39; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;statement:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        expr                    { printf(&amp;#34;%d\n&amp;#34;, $1); }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        | VARIABLE &amp;#39;=&amp;#39; expr     { sym[$1] = $3; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;expr:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        INTEGER
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        | VARIABLE              { $$ = sym[$1]; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        | expr &amp;#39;+&amp;#39; expr         { $$ = $1 + $3; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        | expr &amp;#39;-&amp;#39; expr         { $$ = $1 - $3; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        | expr &amp;#39;*&amp;#39; expr         { $$ = $1 * $3; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        | expr &amp;#39;/&amp;#39; expr         { $$ = $1 / $3; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        | &amp;#39;(&amp;#39; expr &amp;#39;)&amp;#39;          { $$ = $2; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第一部分定义了 &lt;code&gt;token&lt;/code&gt; 类型和运算符的结合性。四种运算符都是左结合，同一行的运算符优先级相同，不同行的运算符，后定义的行具有更高的优先级。&lt;/p&gt;
&lt;p&gt;语法规则使用了&lt;code&gt;BNF&lt;/code&gt;定义。&lt;code&gt;BNF&lt;/code&gt; 可以用来表达上下文无关（&lt;em&gt;context-free&lt;/em&gt;）语言，大部分的现代编程语言都可以使用 &lt;code&gt;BNF&lt;/code&gt; 表示。上面的规则定义了三个&lt;strong&gt;产生式&lt;/strong&gt;。&lt;strong&gt;产生式&lt;/strong&gt;冒号左边的项（例如 &lt;code&gt;statement&lt;/code&gt;）被称为&lt;strong&gt;非终结符&lt;/strong&gt;， &lt;code&gt;INTEGER&lt;/code&gt; 和 &lt;code&gt;VARIABLE&lt;/code&gt; 被称为&lt;strong&gt;终结符&lt;/strong&gt;,它们是由 &lt;code&gt;Lex&lt;/code&gt; 返回的 &lt;code&gt;token&lt;/code&gt; 。&lt;strong&gt;终结符&lt;/strong&gt;只能出现在&lt;strong&gt;产生式&lt;/strong&gt;的右侧。可以使用&lt;strong&gt;产生式&lt;/strong&gt;定义的语法生成表达式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;expr -&amp;gt; expr * expr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     -&amp;gt; expr * INTEGER
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     -&amp;gt; expr + expr * INTEGER
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     -&amp;gt; expr + INTEGER * INTEGER
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     -&amp;gt; INTEGER + INTEGER * INTEGER
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;解析表达式是生成表达式的逆向操作，我们需要归约表达式到一个&lt;strong&gt;非终结符&lt;/strong&gt;。&lt;code&gt;Yacc&lt;/code&gt; 生成的语法分析器使用&lt;strong&gt;自底向上&lt;/strong&gt;的归约（&lt;em&gt;shift-reduce&lt;/em&gt;）方式进行语法解析，同时使用堆栈保存中间状态。还是看例子，表达式&lt;code&gt;x + y * z&lt;/code&gt;的解析过程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1    . x + y * z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2    x . + y * z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3    expr . + y * z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4    expr + . y * z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5    expr + y . * z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6    expr + expr . * z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7    expr + expr * . z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8    expr + expr * z .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9    expr + expr * expr .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10   expr + expr .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11   expr .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12   statement .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;13   program  .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;点（&lt;code&gt;.&lt;/code&gt;）表示当前的读取位置，随着 &lt;code&gt;.&lt;/code&gt; 从左向右移动，我们将读取的&lt;code&gt;token&lt;/code&gt;压入堆栈，当发现堆栈中的内容匹配了某个&lt;strong&gt;产生式&lt;/strong&gt;的右侧，则将匹配的项从堆栈中弹出，将该&lt;strong&gt;产生式&lt;/strong&gt;左侧的&lt;strong&gt;非终结符&lt;/strong&gt;压入堆栈。这个过程持续进行，直到读取完所有的&lt;code&gt;tokens&lt;/code&gt;，并且只有&lt;strong&gt;启始非终结符&lt;/strong&gt;（本例为 &lt;code&gt;program&lt;/code&gt;）保留在堆栈中。&lt;/p&gt;
&lt;p&gt;产生式右侧的大括号中定义了该规则关联的动作，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;expr:  expr &amp;#39;*&amp;#39; expr         { $$ = $1 * $3; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们将堆栈中匹配该&lt;strong&gt;产生式&lt;/strong&gt;右侧的项替换为&lt;strong&gt;产生式&lt;/strong&gt;左侧的&lt;strong&gt;非终结符&lt;/strong&gt;，本例中我们弹出 &lt;code&gt;expr &#39;*&#39; expr&lt;/code&gt;，然后把 &lt;code&gt;expr&lt;/code&gt; 压回堆栈。 我们可以使用 &lt;code&gt;$position&lt;/code&gt; 的形式访问堆栈中的项，&lt;code&gt;$1&lt;/code&gt;引用的是第一项，&lt;code&gt;$2&lt;/code&gt;引用的是第二项，以此类推。&lt;code&gt;$$&lt;/code&gt; 代表的是归约操作执行后的堆栈顶。本例的动作是将三项从堆栈中弹出，两个表达式相加，结果再压回堆栈顶。&lt;/p&gt;
&lt;p&gt;上面例子中语法规则关联的动作，在完成语法解析的同时，也完成了表达式求值。一般我们希望语法解析的结果是一棵抽象语法树（&lt;code&gt;AST&lt;/code&gt;），可以这么定义语法规则关联的动作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;expr:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    INTEGER             { $$ = con($1); }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    | VARIABLE          { $$ = id($1); }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    | expr &amp;#39;+&amp;#39; expr     { $$ = opr(&amp;#39;+&amp;#39;, 2, $1, $3); }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    | expr &amp;#39;-&amp;#39; expr     { $$ = opr(&amp;#39;-&amp;#39;, 2, $1, $3); }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    | expr &amp;#39;*&amp;#39; expr     { $$ = opr(&amp;#39;*&amp;#39;, 2, $1, $3); } 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    | expr &amp;#39;/&amp;#39; expr     { $$ = opr(&amp;#39;/&amp;#39;, 2, $1, $3); }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    | &amp;#39;(&amp;#39; expr &amp;#39;)&amp;#39;      { $$ = $2; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;nodeType *con(int value) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;nodeType *id(int i) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;nodeType *opr(int oper, int nops, ...) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}    
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面是一个语法规则定义的片段，我们可以看到，每个规则关联的动作不再是求值，而是调用相应的函数，该函数会返回抽象语法树的节点类型 &lt;code&gt;nodeType&lt;/code&gt;，然后将这个节点压回堆栈，解析完成时，我们就得到了一颗由 &lt;code&gt;nodeType&lt;/code&gt; 构成的抽象语法树。对这个语法树进行遍历访问，可以生成机器代码，也可以解释执行。&lt;/p&gt;
&lt;p&gt;至此，我们大致了解了&lt;code&gt;Lex &amp;amp; Yacc&lt;/code&gt;的原理。其实还有非常多的细节，例如如何消除语法的歧义，但我们的目的是读懂TiDB的代码，掌握这些概念已经够用了。&lt;/p&gt;
&lt;h2 id=&#34;goyacc-简介&#34;&gt;goyacc 简介&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cznic/goyacc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;goyacc&lt;/a&gt; 是golang版的 &lt;code&gt;Yacc&lt;/code&gt;。和 &lt;code&gt;Yacc&lt;/code&gt;的功能一样，&lt;code&gt;goyacc&lt;/code&gt; 根据输入的语法规则文件，生成该语法规则的go语言版解析器。&lt;code&gt;goyacc&lt;/code&gt; 生成的解析器 &lt;code&gt;yyParse&lt;/code&gt; 要求词法分析器符合下面的接口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;type yyLexer interface {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Lex(lval *yySymType) int
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Error(e string)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;type yyLexerEx interface {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; yyLexer
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // Hook for recording a reduction.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Reduced(rule, state int, lval *yySymType) (stop bool) // Client should copy *lval.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;TiDB没有使用类似 &lt;code&gt;Lex&lt;/code&gt; 的工具生成词法分析器，而是纯手工打造，词法分析器对应的代码是 &lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/master/parser/lexer.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;parser/lexer.go&lt;/a&gt;， 它实现了 &lt;code&gt;goyacc&lt;/code&gt; 要求的接口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// Scanner implements the yyLexer interface.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;type Scanner struct {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; r   reader
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; buf bytes.Buffer
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; errs         []error
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; stmtStartPos int
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // For scanning such kind of comment: /*! MySQL-specific code */ or /*+ optimizer hint */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; specialComment specialCommentScanner
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; sqlMode mysql.SQLMode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// Lex returns a token and store the token value in v.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// Scanner satisfies yyLexer interface.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 0 and invalid are special token id this function would return:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// return 0 tells parser that scanner meets EOF,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// return invalid tells parser that scanner meets illegal character.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func (s *Scanner) Lex(v *yySymType) int {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; tok, pos, lit := s.scan()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; v.offset = pos.Offset
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; v.ident = lit
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// Errors returns the errors during a scan.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func (s *Scanner) Errors() []error {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return s.errs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;另外&lt;code&gt;lexer&lt;/code&gt; 使用了&lt;code&gt;字典树&lt;/code&gt;技术进行 &lt;code&gt;token&lt;/code&gt; 识别，具体的实现代码在&lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/master/parser/misc.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;parser/misc.go&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;tidb-sql-parser的实现&#34;&gt;TiDB SQL Parser的实现&lt;/h2&gt;
&lt;p&gt;终于到了正题。有了上面的背景知识，对TiDB 的 &lt;code&gt;SQL Parser&lt;/code&gt; 模块会相对容易理解一些。先看SQL语法规则文件&lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/master/parser/parser.y&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;parser.y&lt;/a&gt;，&lt;code&gt;goyacc&lt;/code&gt; 就是根据这个文件生成SQL语法解析器的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;parser.y&lt;/code&gt; 有6500多行，第一次打开可能会被吓到，其实这个文件仍然符合我们上面介绍过的结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;... definitions ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;... rules ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;... subroutines ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;parser.y&lt;/code&gt; 第三部分 &lt;code&gt;subroutines&lt;/code&gt; 是空白没有内容的， 所以我们只需要关注第一部分 &lt;code&gt;definitions&lt;/code&gt; 和第二部分 &lt;code&gt;rules&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第一部分主要是定义&lt;code&gt;token&lt;/code&gt;的类型、优先级、结合性等。注意 &lt;code&gt;union&lt;/code&gt; 这个联合体结构体：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%union {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; offset int // offset
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; item interface{}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ident string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; expr ast.ExprNode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; statement ast.StmtNode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;该联合体结构体定义了在语法解析过程中被压入堆栈的&lt;strong&gt;项&lt;/strong&gt;的属性和类型。&lt;/p&gt;
&lt;p&gt;压入堆栈的&lt;strong&gt;项&lt;/strong&gt;可能是&lt;code&gt;终结符&lt;/code&gt;，也就是 &lt;code&gt;token&lt;/code&gt;，它的类型可以是&lt;code&gt;item&lt;/code&gt; 或 &lt;code&gt;ident&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;这个&lt;strong&gt;项&lt;/strong&gt;也可能是&lt;code&gt;非终结符&lt;/code&gt;，即产生式的左侧，它的类型可以是 &lt;code&gt;expr&lt;/code&gt; 、 &lt;code&gt;statement&lt;/code&gt; 、 &lt;code&gt;item&lt;/code&gt; 或 &lt;code&gt;ident&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;goyacc&lt;/code&gt; 根据这个 &lt;code&gt;union&lt;/code&gt; 在解析器里生成对应的 &lt;code&gt;struct&lt;/code&gt; 是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;type yySymType struct {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; yys       int
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; offset    int // offset
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; item      interface{}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ident     string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; expr      ast.ExprNode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; statement ast.StmtNode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在语法解析过程中，&lt;code&gt;非终结符&lt;/code&gt;会被构造成抽象语法树（&lt;code&gt;AST&lt;/code&gt;）的节点 &lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/73900c4890dc9708fe4de39021001ca554bc8374/ast/ast.go#L60&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ast.ExprNode&lt;/a&gt; 或 &lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/73900c4890dc9708fe4de39021001ca554bc8374/ast/ast.go#L94&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ast.StmtNode&lt;/a&gt;。抽象语法树相关的数据结构都定义在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/tree/master/ast&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ast&lt;/a&gt; 包中，它们大都实现了 &lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/73900c4890dc9708fe4de39021001ca554bc8374/ast/ast.go#L29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ast.Node&lt;/a&gt; 接口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// Node is the basic element of the AST.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// Interfaces embed Node should have &amp;#39;Node&amp;#39; name suffix.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;type Node interface {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Accept(v Visitor) (node Node, ok bool)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Text() string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; SetText(text string)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这个接口有一个 &lt;code&gt;Accept&lt;/code&gt; 方法，接受 &lt;code&gt;Visitor&lt;/code&gt; 参数，后续对 &lt;code&gt;AST&lt;/code&gt; 的处理，主要依赖这个 &lt;code&gt;Accept&lt;/code&gt; 方法，以 &lt;code&gt;Visitor&lt;/code&gt; 模式遍历所有的节点以及对 &lt;code&gt;AST&lt;/code&gt; 做结构转换。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// Visitor visits a Node.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;type Visitor interface {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Enter(n Node) (node Node, skipChildren bool)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Leave(n Node) (node Node, ok bool)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;例如 &lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/master/plan/preprocess.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;plan.preprocess&lt;/a&gt; 是对 &lt;code&gt;AST&lt;/code&gt;  做预处理，包括合法性检查以及名字绑定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;union&lt;/code&gt; 后面是对 &lt;code&gt;token&lt;/code&gt; 和 &lt;code&gt;非终结符&lt;/code&gt; 按照类型分别定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/* 这部分的token是 ident类型 */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%token &amp;lt;ident&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; add   &amp;#34;ADD&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; all    &amp;#34;ALL&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; alter   &amp;#34;ALTER&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; analyze   &amp;#34;ANALYZE&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; and   &amp;#34;AND&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; as   &amp;#34;AS&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; asc   &amp;#34;ASC&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; between   &amp;#34;BETWEEN&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; bigIntType  &amp;#34;BIGINT&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/* 这部分的token是 item 类型 */   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%token &amp;lt;item&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    /*yy:token &amp;#34;1.%d&amp;#34;   */ floatLit        &amp;#34;floating-point literal&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; /*yy:token &amp;#34;1.%d&amp;#34;   */ decLit          &amp;#34;decimal literal&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; /*yy:token &amp;#34;%d&amp;#34;     */ intLit          &amp;#34;integer literal&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; /*yy:token &amp;#34;%x&amp;#34;     */ hexLit          &amp;#34;hexadecimal literal&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; /*yy:token &amp;#34;%b&amp;#34;     */ bitLit          &amp;#34;bit literal&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; andnot  &amp;#34;&amp;amp;^&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; assignmentEq &amp;#34;:=&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; eq  &amp;#34;=&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ge  &amp;#34;&amp;gt;=&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/* 非终结符按照类型分别定义 */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%type &amp;lt;expr&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    Expression   &amp;#34;expression&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; BoolPri    &amp;#34;boolean primary expression&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ExprOrDefault   &amp;#34;expression or default&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; PredicateExpr   &amp;#34;Predicate expression factor&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; SetExpr    &amp;#34;Set variable statement value&amp;#39;s expression&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%type &amp;lt;statement&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; AdminStmt   &amp;#34;Check table statement or show ddl statement&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; AlterTableStmt   &amp;#34;Alter table statement&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; AlterUserStmt   &amp;#34;Alter user statement&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; AnalyzeTableStmt  &amp;#34;Analyze table statement&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; BeginTransactionStmt  &amp;#34;BEGIN TRANSACTION statement&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; BinlogStmt   &amp;#34;Binlog base64 statement&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%type   &amp;lt;item&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; AlterTableOptionListOpt  &amp;#34;alter table option list opt&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; AlterTableSpec   &amp;#34;Alter table specification&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; AlterTableSpecList  &amp;#34;Alter table specification list&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; AnyOrAll   &amp;#34;Any or All for subquery&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Assignment   &amp;#34;assignment&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%type &amp;lt;ident&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; KeyOrIndex  &amp;#34;{KEY|INDEX}&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ColumnKeywordOpt &amp;#34;Column keyword or empty&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; PrimaryOpt  &amp;#34;Optional primary keyword&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; NowSym   &amp;#34;CURRENT_TIMESTAMP/LOCALTIME/LOCALTIMESTAMP&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; NowSymFunc  &amp;#34;CURRENT_TIMESTAMP/LOCALTIME/LOCALTIMESTAMP/NOW&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第一部分的最后是对优先级和结合性的定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%precedence sqlCache sqlNoCache
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%precedence lowerThanIntervalKeyword
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%precedence interval
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%precedence lowerThanStringLitToken
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%precedence stringLit
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%right   assignmentEq
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%left  pipes or pipesAsOr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%left  xor
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%left  andand and
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;%left  between
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;parser.y&lt;/code&gt;文件的第二部分是&lt;code&gt;SQL&lt;/code&gt;语法的产生式和每个规则对应的 &lt;code&gt;aciton&lt;/code&gt; 。SQL语法非常复杂，&lt;code&gt;parser.y&lt;/code&gt; 的大部分内容都是产生式的定义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SQL&lt;/code&gt; 语法可以参照MySQL参考手册的&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/5.7/en/sql-syntax.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SQL Statement Syntax&lt;/a&gt; 部分，例如 &lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/5.7/en/select.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SELECT&lt;/a&gt; 语法的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SELECT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    [ALL | DISTINCT | DISTINCTROW ]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      [HIGH_PRIORITY]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      [STRAIGHT_JOIN]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    select_expr [, select_expr ...]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    [FROM table_references
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      [PARTITION partition_list]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    [WHERE where_condition]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    [GROUP BY {col_name | expr | position}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      [ASC | DESC], ... [WITH ROLLUP]]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    [HAVING where_condition]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    [ORDER BY {col_name | expr | position}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      [ASC | DESC], ...]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    [LIMIT {[offset,] row_count | row_count OFFSET offset}]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    [PROCEDURE procedure_name(argument_list)]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    [INTO OUTFILE &amp;#39;file_name&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        [CHARACTER SET charset_name]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        export_options
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      | INTO DUMPFILE &amp;#39;file_name&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      | INTO var_name [, var_name]]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    [FOR UPDATE | LOCK IN SHARE MODE]]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们可以在 &lt;code&gt;parser.y&lt;/code&gt; 中找到 &lt;code&gt;SELECT&lt;/code&gt; 语句的产生式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SelectStmt:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &amp;#34;SELECT&amp;#34; SelectStmtOpts SelectStmtFieldList OrderByOptional SelectStmtLimit SelectLockOpt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    { ... }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   &amp;#34;SELECT&amp;#34; SelectStmtOpts SelectStmtFieldList FromDual WhereClauseOptional SelectStmtLimit SelectLockOpt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    { ... }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   &amp;#34;SELECT&amp;#34; SelectStmtOpts SelectStmtFieldList &amp;#34;FROM&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; TableRefsClause WhereClauseOptional SelectStmtGroup HavingClause OrderByOptional
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; SelectStmtLimit SelectLockOpt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    { ... } 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;产生式 &lt;code&gt;SelectStmt&lt;/code&gt; 和 &lt;code&gt;SELECT&lt;/code&gt; 语法是对应的。&lt;/p&gt;
&lt;p&gt;我省略了大括号中的 &lt;code&gt;action&lt;/code&gt; ，这部分代码会构建出 &lt;code&gt;AST&lt;/code&gt; 的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/3ac2b34a3491e809a96db358ee2ce8d11a66abb6/ast/dml.go#L451&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ast.SelectStmt&lt;/a&gt; 节点：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;type SelectStmt struct {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; dmlNode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; resultSetNode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // SelectStmtOpts wraps around select hints and switches.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *SelectStmtOpts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // Distinct represents whether the select has distinct option.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Distinct bool
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // From is the from clause of the query.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; From *TableRefsClause
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // Where is the where clause in select statement.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Where ExprNode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // Fields is the select expression list.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Fields *FieldList
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // GroupBy is the group by expression list.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; GroupBy *GroupByClause
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // Having is the having condition.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Having *HavingClause
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // OrderBy is the ordering expression list.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; OrderBy *OrderByClause
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // Limit is the limit clause.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Limit *Limit
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // LockTp is the lock type
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; LockTp SelectLockType
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // TableHints represents the level Optimizer Hint
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; TableHints []*TableOptimizerHint
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看出，&lt;code&gt;ast.SelectStmt&lt;/code&gt; 结构体内包含的内容和 &lt;code&gt;SELECT&lt;/code&gt;  语法也是一一对应的。&lt;/p&gt;
&lt;p&gt;其他的产生式也都是根据对应的 &lt;code&gt;SQL&lt;/code&gt; 语法来编写的。从 &lt;code&gt;parser.y&lt;/code&gt; 的注释看到，这个文件最初是用&lt;a class=&#34;link&#34; href=&#34;https://github.com/cznic/ebnf2y&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;工具&lt;/a&gt;从 &lt;code&gt;BNF&lt;/code&gt; 转化生成的，从头手写这个规则文件，工作量会非常大。&lt;/p&gt;
&lt;p&gt;完成了语法规则文件 &lt;code&gt;parser.y&lt;/code&gt; 的定义，就可以使用 &lt;code&gt;goyacc&lt;/code&gt; 生成语法解析器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bin/goyacc -o parser/parser.go parser/parser.y 2&amp;gt;&amp;amp;1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;TiDB对 &lt;code&gt;lexer&lt;/code&gt; 和 &lt;code&gt;parser.go&lt;/code&gt; 进行了封装，对外提供 &lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb/blob/master/parser/yy_parser.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;parser.yy_parser&lt;/a&gt;  进行SQL语句的解析：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// Parse parses a query string to raw ast.StmtNode.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func (parser *Parser) Parse(sql, charset, collation string) ([]ast.StmtNode, error) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最后，我写了一个简单的例子，使用TiDB的 &lt;code&gt;SQL Parser&lt;/code&gt; 进行SQL语法解析，构建出 &lt;code&gt;AST&lt;/code&gt;，然后利用 &lt;code&gt;visitor&lt;/code&gt; 遍历 &lt;code&gt;AST&lt;/code&gt; ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;github.com/pingcap/tidb/parser&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;github.com/pingcap/tidb/ast&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;visitor&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;visitor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Enter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;skipChildren&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%T\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;visitor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Leave&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nx&#34;&gt;sql&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;SELECT /*+ TIDB_SMJ(employees) */ emp_no, first_name, last_name &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s&#34;&gt;&amp;#34;FROM employees USE INDEX (last_name) &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s&#34;&gt;&amp;#34;where last_name=&amp;#39;Aamodt&amp;#39; and gender=&amp;#39;F&amp;#39; and birth_date &amp;gt; &amp;#39;1960-01-01&amp;#39;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nx&#34;&gt;sqlParser&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;parser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nx&#34;&gt;stmtNodes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sqlParser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Parse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;parse error:\n%v\n%s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stmtNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stmtNodes&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;visitor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;stmtNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Accept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我实现的 &lt;code&gt;visitor&lt;/code&gt; 什么也没干，只是输出了节点的类型。 这段代码的运行结果如下，依次输出遍历过程中遇到的节点类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.SelectStmt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.TableOptimizerHint
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.TableRefsClause
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.Join
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.TableSource
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.TableName
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.BinaryOperationExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.BinaryOperationExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.BinaryOperationExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnNameExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnName
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ValueExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.BinaryOperationExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnNameExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnName
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ValueExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.BinaryOperationExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnNameExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnName
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ValueExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.FieldList
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.SelectField
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnNameExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnName
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.SelectField
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnNameExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnName
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.SelectField
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnNameExpr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*ast.ColumnName
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;了解了TiDB &lt;code&gt;SQL Parser&lt;/code&gt; 的实现，我们就有可能实现TiDB当前不支持的语法，例如添加内置函数，也为我们学习查询计划以及优化打下了基础。希望这篇文章对你能有所帮助。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>基于代价优化（CBO）实现代码导读</title>
        <link>https://mazhen.tech/p/%E5%9F%BA%E4%BA%8E%E4%BB%A3%E4%BB%B7%E4%BC%98%E5%8C%96cbo%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%AF%BB/</link>
        <pubDate>Tue, 08 May 2018 14:40:17 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E5%9F%BA%E4%BA%8E%E4%BB%A3%E4%BB%B7%E4%BC%98%E5%8C%96cbo%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%AF%BB/</guid>
        <description>&lt;p&gt;配合这篇&lt;a class=&#34;link&#34; href=&#34;https://pingcap.com/blog-cn/tidb-source-code-reading-8/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《基于代价的优化》&lt;/a&gt; 阅读。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CBO的整体思路&lt;/strong&gt;是：从逻辑查询计划树，自上而下枚举每个逻辑运算符可能的物理算子，从所有可能的执行路径中选择一条评估代价最小的作为物理查询计划。&lt;/p&gt;
&lt;p&gt;一个逻辑运算符受两个因素的影响，导致生成多个候选的物理执行计划：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑运算符可能有多种候选的物理算子供选择，如下表：&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;有些物理算子会根据参与运算的属性、属性的顺序等因素，生成多种物理执行计划，例如&lt;code&gt;Join&lt;/code&gt;的物理算子会根据参与连接的表的顺序，生成多种可能的执行计划。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CBO核心流程的代码在&lt;code&gt;plan/optimizer.go&lt;/code&gt;中的&lt;code&gt;physicalOptimize&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func physicalOptimize(logic LogicalPlan) (PhysicalPlan, error) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; logic.preparePossibleProperties()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; _, err := logic.deriveStats()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if err != nil {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  return nil, errors.Trace(err)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; t, err := logic.findBestTask(&amp;amp;requiredProp{taskTp: rootTaskType, expectedCnt: math.MaxFloat64})
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if err != nil {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  return nil, errors.Trace(err)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; p := t.plan()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; p.ResolveIndices()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return p, nil
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;三行关键的代码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;logic.preparePossibleProperties()&lt;/code&gt;：裁剪参与运算的属性，从而尽可能早的裁减掉成物理计划搜索路径上的分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logic.deriveStats()&lt;/code&gt;：为每个逻辑计划节点生成统计信息，为评估物理计划的代价做准备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;![&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;logic.findBestTask&lt;/code&gt;：生成执行代价最小的&lt;code&gt;task&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;findBestTask&lt;/code&gt;的核心逻辑：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;for _, pp := range p.self.exhaustPhysicalPlans(prop) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // find best child tasks firstly.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; childTasks = childTasks[:0]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; for i, child := range p.children {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  childTask, err := child.findBestTask(pp.getChildReqProps(i))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  if err != nil {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   return nil, errors.Trace(err)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  childTasks = append(childTasks, childTask)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // combine best child tasks with parent physical plan.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; curTask := pp.attach2Task(childTasks...)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // get the most efficient one.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if curTask.cost() &amp;lt; bestTask.cost() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  bestTask = curTask
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;首先枚举可能的物理执行计划&lt;code&gt;p.self.exhaustPhysicalPlans&lt;/code&gt;，然后遍历每种候选计划，找到代价最小的&lt;code&gt;task&lt;/code&gt;。这是个递归的过程，当前节点的代价是由所有子节点的代价组成的，所以在遍历的过程中，又会调用&lt;code&gt;child.findBestTask(pp.getChildReqProps(i))&lt;/code&gt;找到子节点的最佳&lt;code&gt;task&lt;/code&gt;。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如何评估物理执行计划的代价呢？根据参与运算的关系（表）的统计信息进行评估。代价评估相关逻辑涉及的代码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算关系的统计信息：&lt;code&gt;plan/stats.go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;计算task的代价：&lt;code&gt;plan/task.go&lt;/code&gt;中的&lt;code&gt;attach2Task&lt;/code&gt;系列方法。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>利用docker compose在单机上玩转TiDB</title>
        <link>https://mazhen.tech/p/%E5%88%A9%E7%94%A8docker-compose%E5%9C%A8%E5%8D%95%E6%9C%BA%E4%B8%8A%E7%8E%A9%E8%BD%ACtidb/</link>
        <pubDate>Fri, 09 Feb 2018 14:32:20 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/%E5%88%A9%E7%94%A8docker-compose%E5%9C%A8%E5%8D%95%E6%9C%BA%E4%B8%8A%E7%8E%A9%E8%BD%ACtidb/</guid>
        <description>&lt;p&gt;TiDB提供了&lt;code&gt;docker compose&lt;/code&gt;的部署方式，可以很方便的在单机上搭建一个TiDB集群作为开发测试环境。如果修改了&lt;code&gt;TiDB&lt;/code&gt;源码，可以使用这样方式，先在本机部署集群做一些验证。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先本机要安装&lt;code&gt;docker&lt;/code&gt;和&lt;code&gt;docker compose&lt;/code&gt;，建议参考官方文档&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/installation/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Install Docker&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/compose/install/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Install Docker Compose&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载&lt;code&gt;tidb-docker-compose&lt;/code&gt;项目&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/pingcap/tidb-docker-compose.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;docker compose&lt;/code&gt;启动TiDB集群&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cd tidb-docker-compose &amp;amp;&amp;amp; sudo docker-compose up -d
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;就这么简单，集群启动成功了。使用&lt;code&gt;docker ps&lt;/code&gt;查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011433415.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;可以看到，已经启动了三个&lt;code&gt;tikv&lt;/code&gt;实例，一个&lt;code&gt;tidb&lt;/code&gt;实例，三个&lt;code&gt;pd&lt;/code&gt;实例，还有监控和&lt;code&gt;tidb-vision&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;监控的访问地址是 &lt;a class=&#34;link&#34; href=&#34;http://localhost:3000&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://localhost:3000&lt;/a&gt;，用户名/密码：admin/admin。&lt;/p&gt;
&lt;p&gt;tidb-vision 的访问地址是 &lt;a class=&#34;link&#34; href=&#34;http://localhost:8010&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://localhost:8010&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;MySQL&lt;/code&gt;客户端访问&lt;code&gt;TiDB&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果本机有&lt;code&gt;MySQL&lt;/code&gt;客户端，可以直接连接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mysql -h 127.0.0.1 -P 4000 -u root
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果本机没有&lt;code&gt;MySQL&lt;/code&gt;客户端，可以使用docker启动一个&lt;code&gt;MySQL&lt;/code&gt;容器，然后登录到容器内，再使用&lt;code&gt;MySQL&lt;/code&gt;客户端连接&lt;code&gt;TiDB&lt;/code&gt;集群。这种方式比较环保，只要有docker环境就行。先查看&lt;code&gt;TiDB&lt;/code&gt;集群的&lt;code&gt;docker&lt;/code&gt;网络：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011434062.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然后启动MySQL容器，注意要加入&lt;code&gt;TiDB&lt;/code&gt;集群的&lt;code&gt;docker&lt;/code&gt;网络：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo docker run --network=tidbdockercompose_default --rm -it mysql /bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;因为和&lt;code&gt;TiDB&lt;/code&gt;集群在同一个docker网络，在MySQL容器内，可以使用&lt;code&gt;tidb&lt;/code&gt;名称访问到&lt;code&gt;TiDB&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mysql -h tidb -P 4000 -u root
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;停止集群&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo docker-compose down
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果自己build了&lt;code&gt;TiDB&lt;/code&gt;版本想在本机run集群，&lt;a class=&#34;link&#34; href=&#34;https://github.com/pingcap/tidb-docker-compose&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;文档&lt;/a&gt;写的很清楚，告诉你镜像应该放在什么位置。&lt;/p&gt;
&lt;p&gt;Have fun!&lt;/p&gt;
</description>
        </item>
        <item>
        <title>TiDB初探</title>
        <link>https://mazhen.tech/p/tidb%E5%88%9D%E6%8E%A2/</link>
        <pubDate>Fri, 09 Feb 2018 14:28:29 +0800</pubDate>
        
        <guid>https://mazhen.tech/p/tidb%E5%88%9D%E6%8E%A2/</guid>
        <description>&lt;p&gt;翻了一下&lt;code&gt;TiDB&lt;/code&gt;的文档，对&lt;code&gt;TiDB&lt;/code&gt;有了个大概的了解。简单说，&lt;code&gt;TiDB&lt;/code&gt;的实现架构是：底层是分布式KV引擎&lt;code&gt;TiKV&lt;/code&gt;，上层是SQL引擎&lt;code&gt;TiDB Servers&lt;/code&gt;。一般传统数据库也是这么分层实现的，只不过&lt;code&gt;TiKV&lt;/code&gt;实现了一个分布式、强一致、支持事务的K/V，不像数据库是单机版K/V。在TiKV之上实现SQL引擎就简化了很多，因此&lt;code&gt;TiDB Servers&lt;/code&gt;是无状态的。&lt;/p&gt;
&lt;p&gt;简化的抽象架构分层：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011429441.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;db-architecture&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;TiDB官方文档里的架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mazhen.tech/images/202207011430517.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;可以看出，&lt;code&gt;TiDB&lt;/code&gt;的基础工作和最突出的创新在TiKV，理论上有了这个KV，可以把单机版的SQl引擎实现方式搬过来，就有了一个可扩展的分布式数据库。&lt;/p&gt;
&lt;p&gt;那就看看&lt;code&gt;TiKV&lt;/code&gt;的架构：用&lt;code&gt;RocksDB&lt;/code&gt;作为单机存储引擎，然后上层用&lt;code&gt;Raft&lt;/code&gt;实现了一个分布式、强一致性的K/V。有了这个很强大的分布式K/V，在上面实现了&lt;code&gt;MVCC&lt;/code&gt;层，就是对每个Key加了&lt;code&gt;version&lt;/code&gt;，然后基于MVCC层最终实现了分布式事务。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RocksDB&lt;/code&gt;内部用的是&lt;code&gt;LSM-Tree&lt;/code&gt;，写入性能肯定比MySQL的&lt;code&gt;B+ tree&lt;/code&gt;好。读取性能看实现的优化情况了，不过&lt;code&gt;RocksDB&lt;/code&gt;是Facebook做的，应该没啥问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Raft&lt;/code&gt;的实现和测试用例是从&lt;code&gt;Etcd&lt;/code&gt;完全拷贝过来的，可以认为&lt;code&gt;Raft&lt;/code&gt;的实现也是稳定的。 作者的原话：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;我们做了一件比较疯狂的事情，就是我们把 Etcd 的 Raft 状态机的每一行代码，line by line 的翻译成了 Rust。而我们第一个转的就是所有 Etcd 本身的测试用例。我们写一模一样的 test ，保证这个东西我们 port 的过程是没有问题的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;分布式事务参照的是&lt;code&gt;Percolator&lt;/code&gt;。&lt;code&gt;Percolator&lt;/code&gt;和&lt;code&gt;Spanner&lt;/code&gt;差不多，只不过&lt;code&gt;Spanner&lt;/code&gt;引入了专有硬件原子钟，而&lt;code&gt;Percolator&lt;/code&gt;依靠单点的授时服务器。两者都是对两阶段提交协议的改进。我们搞过J2EE，对两阶段提交协议应该比较熟悉，2PC的问题是：一旦事务参与者投票，它必须等待&lt;code&gt;coordinator&lt;/code&gt;给出指示：提交或放弃。如果这时&lt;code&gt;coordinator&lt;/code&gt;挂了，事务参与者除了等待什么也做不了。事务处于未决状态，事务的最终结果记录在&lt;code&gt;coordinator&lt;/code&gt;的事务日志中，只能等它&lt;code&gt;recovery&lt;/code&gt;（&lt;code&gt;HeuristicCommitException&lt;/code&gt;、&lt;code&gt;HeuristicMixedException&lt;/code&gt;、&lt;code&gt;HeuristicRollbackException&lt;/code&gt;等异常就是遇到了这种情况，只好资源自己做了决定）。这么看在本质上，2PC为了达到一致性，实际上是退化到由&lt;code&gt;coordinator&lt;/code&gt;单节点来实现&lt;code&gt;atomic commit&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Spanner&lt;/code&gt;引入了&lt;code&gt;trueTime api&lt;/code&gt;，底下存储是MVCC，每行数据都带一个时间戳做&lt;code&gt;version&lt;/code&gt;，&lt;code&gt;TrueTime API&lt;/code&gt;就是打时间戳的，用时间戳标识事务顺序，解决2PC依赖单点&lt;code&gt;coordinator&lt;/code&gt;的问题。而依赖单点的授时服务器的问题，他们是这样解释的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 TSO 的逻辑极其简单，只需要保证对于每一个请求返回单调递增的 id 即可，通过一些简单的优化手段（比如 pipeline）性能可以达到每秒生成百万 id 以上，同时 TSO 本身的高可用方案也非常好做，所以整个 &lt;code&gt;Percolator&lt;/code&gt; 模型的分布式程度很高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TiDB的事务隔离级别实现了&lt;code&gt;Read committed&lt;/code&gt;和&lt;code&gt;Repeatable read&lt;/code&gt;，没有实现最严格的&lt;code&gt;Serializable&lt;/code&gt;。不过串行化的隔离级别在现实中很少使用，性能会很差。oracle 11g也没有实现它。oracle实现的是&lt;code&gt;snapshot isolation&lt;/code&gt;，实际上比串行化的保证要弱。TiDB和oracle都用是&lt;code&gt;MVCC&lt;/code&gt;保证了&lt;code&gt;Repeatable read&lt;/code&gt;，简单说就是每个事务都读取一个一致性的&lt;code&gt;snapshot&lt;/code&gt;，这个&lt;code&gt;snapshot&lt;/code&gt;肯定就是完整状态。所以叫做&lt;code&gt;snapshot isolation&lt;/code&gt;。按照TiDB的文档，TiDB 实现的 snapshot 隔离级别，该隔离级别不会出现&lt;code&gt;幻读&lt;/code&gt;，但是会出现&lt;code&gt;写偏斜&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;写偏斜&lt;/code&gt;是什么，举个简单的例子：两个事务都先分别查询在线值班的医生总数，发现还有两个在线的医生，然后各自更新不同的记录，分别让不同的医生下线。事务提交后，两个医生都下线了，没有一个医生在线值班，出现错误的业务场景。这种异常情况是两个事务分别更新不同的记录。引起写倾斜的的模式：先查询很多列看是否满足某种条件，然后依赖查询结果写入数据并提交。解决的方法有：真正的串行化隔离级别，或者显示的锁定事务依赖的行。&lt;/p&gt;
&lt;p&gt;从文档看，TiDB利用了成熟的开源项目，自己实现了分布式事务、分布式存储和SQL引擎，整体方案诱人，至于软件成熟程度，还需要经过实际的使用测试。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
